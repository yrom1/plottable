(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ascending", {
  enumerable: true,
  get: function () {
    return _ascending.default;
  }
});
Object.defineProperty(exports, "bisect", {
  enumerable: true,
  get: function () {
    return _bisect.default;
  }
});
Object.defineProperty(exports, "bisectLeft", {
  enumerable: true,
  get: function () {
    return _bisect.bisectLeft;
  }
});
Object.defineProperty(exports, "bisectRight", {
  enumerable: true,
  get: function () {
    return _bisect.bisectRight;
  }
});
Object.defineProperty(exports, "bisector", {
  enumerable: true,
  get: function () {
    return _bisector.default;
  }
});
Object.defineProperty(exports, "cross", {
  enumerable: true,
  get: function () {
    return _cross.default;
  }
});
Object.defineProperty(exports, "descending", {
  enumerable: true,
  get: function () {
    return _descending.default;
  }
});
Object.defineProperty(exports, "deviation", {
  enumerable: true,
  get: function () {
    return _deviation.default;
  }
});
Object.defineProperty(exports, "extent", {
  enumerable: true,
  get: function () {
    return _extent.default;
  }
});
Object.defineProperty(exports, "histogram", {
  enumerable: true,
  get: function () {
    return _histogram.default;
  }
});
Object.defineProperty(exports, "max", {
  enumerable: true,
  get: function () {
    return _max.default;
  }
});
Object.defineProperty(exports, "mean", {
  enumerable: true,
  get: function () {
    return _mean.default;
  }
});
Object.defineProperty(exports, "median", {
  enumerable: true,
  get: function () {
    return _median.default;
  }
});
Object.defineProperty(exports, "merge", {
  enumerable: true,
  get: function () {
    return _merge.default;
  }
});
Object.defineProperty(exports, "min", {
  enumerable: true,
  get: function () {
    return _min.default;
  }
});
Object.defineProperty(exports, "pairs", {
  enumerable: true,
  get: function () {
    return _pairs.default;
  }
});
Object.defineProperty(exports, "permute", {
  enumerable: true,
  get: function () {
    return _permute.default;
  }
});
Object.defineProperty(exports, "quantile", {
  enumerable: true,
  get: function () {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "range", {
  enumerable: true,
  get: function () {
    return _range.default;
  }
});
Object.defineProperty(exports, "scan", {
  enumerable: true,
  get: function () {
    return _scan.default;
  }
});
Object.defineProperty(exports, "shuffle", {
  enumerable: true,
  get: function () {
    return _shuffle.default;
  }
});
Object.defineProperty(exports, "sum", {
  enumerable: true,
  get: function () {
    return _sum.default;
  }
});
Object.defineProperty(exports, "thresholdFreedmanDiaconis", {
  enumerable: true,
  get: function () {
    return _freedmanDiaconis.default;
  }
});
Object.defineProperty(exports, "thresholdScott", {
  enumerable: true,
  get: function () {
    return _scott.default;
  }
});
Object.defineProperty(exports, "thresholdSturges", {
  enumerable: true,
  get: function () {
    return _sturges.default;
  }
});
Object.defineProperty(exports, "tickIncrement", {
  enumerable: true,
  get: function () {
    return _ticks.tickIncrement;
  }
});
Object.defineProperty(exports, "tickStep", {
  enumerable: true,
  get: function () {
    return _ticks.tickStep;
  }
});
Object.defineProperty(exports, "ticks", {
  enumerable: true,
  get: function () {
    return _ticks.default;
  }
});
Object.defineProperty(exports, "transpose", {
  enumerable: true,
  get: function () {
    return _transpose.default;
  }
});
Object.defineProperty(exports, "variance", {
  enumerable: true,
  get: function () {
    return _variance.default;
  }
});
Object.defineProperty(exports, "zip", {
  enumerable: true,
  get: function () {
    return _zip.default;
  }
});

var _bisect = _interopRequireWildcard(require("./src/bisect"));

var _ascending = _interopRequireDefault(require("./src/ascending"));

var _bisector = _interopRequireDefault(require("./src/bisector"));

var _cross = _interopRequireDefault(require("./src/cross"));

var _descending = _interopRequireDefault(require("./src/descending"));

var _deviation = _interopRequireDefault(require("./src/deviation"));

var _extent = _interopRequireDefault(require("./src/extent"));

var _histogram = _interopRequireDefault(require("./src/histogram"));

var _freedmanDiaconis = _interopRequireDefault(require("./src/threshold/freedmanDiaconis"));

var _scott = _interopRequireDefault(require("./src/threshold/scott"));

var _sturges = _interopRequireDefault(require("./src/threshold/sturges"));

var _max = _interopRequireDefault(require("./src/max"));

var _mean = _interopRequireDefault(require("./src/mean"));

var _median = _interopRequireDefault(require("./src/median"));

var _merge = _interopRequireDefault(require("./src/merge"));

var _min = _interopRequireDefault(require("./src/min"));

var _pairs = _interopRequireDefault(require("./src/pairs"));

var _permute = _interopRequireDefault(require("./src/permute"));

var _quantile = _interopRequireDefault(require("./src/quantile"));

var _range = _interopRequireDefault(require("./src/range"));

var _scan = _interopRequireDefault(require("./src/scan"));

var _shuffle = _interopRequireDefault(require("./src/shuffle"));

var _sum = _interopRequireDefault(require("./src/sum"));

var _ticks = _interopRequireWildcard(require("./src/ticks"));

var _transpose = _interopRequireDefault(require("./src/transpose"));

var _variance = _interopRequireDefault(require("./src/variance"));

var _zip = _interopRequireDefault(require("./src/zip"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./src/ascending":3,"./src/bisect":4,"./src/bisector":5,"./src/cross":7,"./src/descending":8,"./src/deviation":9,"./src/extent":10,"./src/histogram":11,"./src/max":13,"./src/mean":14,"./src/median":15,"./src/merge":16,"./src/min":17,"./src/pairs":19,"./src/permute":20,"./src/quantile":21,"./src/range":22,"./src/scan":23,"./src/shuffle":24,"./src/sum":25,"./src/threshold/freedmanDiaconis":26,"./src/threshold/scott":27,"./src/threshold/sturges":28,"./src/ticks":29,"./src/transpose":30,"./src/variance":31,"./src/zip":32}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = exports.map = void 0;
var array = Array.prototype;
var slice = array.slice;
exports.slice = slice;
var map = array.map;
exports.map = map;

},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.bisectRight = exports.bisectLeft = void 0;

var _ascending = _interopRequireDefault(require("./ascending"));

var _bisector = _interopRequireDefault(require("./bisector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ascendingBisect = (0, _bisector.default)(_ascending.default);
var bisectRight = ascendingBisect.right;
exports.bisectRight = bisectRight;
var bisectLeft = ascendingBisect.left;
exports.bisectLeft = bisectLeft;
var _default = bisectRight;
exports.default = _default;

},{"./ascending":3,"./bisector":5}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(require("./ascending"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function (a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      }

      return lo;
    },
    right: function (a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
      }

      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function (d, x) {
    return (0, _ascending.default)(f(d), x);
  };
}

},{"./ascending":3}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return function () {
    return x;
  };
}

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _pairs = require("./pairs");

function _default(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;
  if (reduce == null) reduce = _pairs.pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

},{"./pairs":19}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _variance = _interopRequireDefault(require("./variance"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(array, f) {
  var v = (0, _variance.default)(array, f);
  return v ? Math.sqrt(v) : v;
}

},{"./variance":31}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("./array");

var _bisect = _interopRequireDefault(require("./bisect"));

var _constant = _interopRequireDefault(require("./constant"));

var _extent = _interopRequireDefault(require("./extent"));

var _identity = _interopRequireDefault(require("./identity"));

var _range = _interopRequireDefault(require("./range"));

var _ticks = require("./ticks");

var _sturges = _interopRequireDefault(require("./threshold/sturges"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var value = _identity.default,
      domain = _extent.default,
      threshold = _sturges.default;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds.

    if (!Array.isArray(tz)) {
      tz = (0, _ticks.tickStep)(x0, x1, tz);
      tz = (0, _range.default)(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    } // Remove any thresholds outside the domain.


    var m = tz.length;

    while (tz[0] <= x0) tz.shift(), --m;

    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin; // Initialize bins.

    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    } // Assign data to bins by value, ignoring any outside the domain.


    for (i = 0; i < n; ++i) {
      x = values[i];

      if (x0 <= x && x <= x1) {
        bins[(0, _bisect.default)(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : (0, _constant.default)([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? (0, _constant.default)(_array.slice.call(_)) : (0, _constant.default)(_), histogram) : threshold;
  };

  return histogram;
}

},{"./array":2,"./bisect":4,"./constant":6,"./extent":10,"./identity":12,"./range":22,"./threshold/sturges":28,"./ticks":29}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return x;
}

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(values[i]))) sum += value;else --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(valueof(values[i], i, values)))) sum += value;else --m;
    }
  }

  if (m) return sum / m;
}

},{"./number":18}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(require("./ascending"));

var _number = _interopRequireDefault(require("./number"));

var _quantile = _interopRequireDefault(require("./quantile"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(values[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return (0, _quantile.default)(numbers.sort(_ascending.default), 0.5);
}

},{"./ascending":3,"./number":18,"./quantile":21}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;

  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;

    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return x === null ? NaN : +x;
}

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.pair = pair;

function _default(array, f) {
  if (f == null) f = pair;
  var i = 0,
      n = array.length - 1,
      p = array[0],
      pairs = new Array(n < 0 ? 0 : n);

  while (i < n) pairs[i] = f(p, p = array[++i]);

  return pairs;
}

function pair(a, b) {
  return [a, b];
}

},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(array, indexes) {
  var i = indexes.length,
      permutes = new Array(i);

  while (i--) permutes[i] = array[indexes[i]];

  return permutes;
}

},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, p, valueof) {
  if (valueof == null) valueof = _number.default;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

},{"./number":18}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

},{}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(require("./ascending"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];
  if (compare == null) compare = _ascending.default;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

},{"./ascending":3}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("../array");

var _ascending = _interopRequireDefault(require("../ascending"));

var _number = _interopRequireDefault(require("../number"));

var _quantile = _interopRequireDefault(require("../quantile"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, min, max) {
  values = _array.map.call(values, _number.default).sort(_ascending.default);
  return Math.ceil((max - min) / (2 * ((0, _quantile.default)(values, 0.75) - (0, _quantile.default)(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

},{"../array":2,"../ascending":3,"../number":18,"../quantile":21}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _deviation = _interopRequireDefault(require("../deviation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, min, max) {
  return Math.ceil((max - min) / (3.5 * (0, _deviation.default)(values) * Math.pow(values.length, -1 / 3)));
}

},{"../deviation":9}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function _default(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));

    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();
  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _min = _interopRequireDefault(require("./min"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(matrix) {
  if (!(n = matrix.length)) return [];

  for (var i = -1, m = (0, _min.default)(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }

  return transpose;
}

function length(d) {
  return d.length;
}

},{"./min":17}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

},{"./number":18}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _transpose = _interopRequireDefault(require("./transpose"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  return (0, _transpose.default)(arguments);
}

},{"./transpose":30}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "axisBottom", {
  enumerable: true,
  get: function () {
    return _axis.axisBottom;
  }
});
Object.defineProperty(exports, "axisLeft", {
  enumerable: true,
  get: function () {
    return _axis.axisLeft;
  }
});
Object.defineProperty(exports, "axisRight", {
  enumerable: true,
  get: function () {
    return _axis.axisRight;
  }
});
Object.defineProperty(exports, "axisTop", {
  enumerable: true,
  get: function () {
    return _axis.axisTop;
  }
});

var _axis = require("./src/axis");

},{"./src/axis":35}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = void 0;
var slice = Array.prototype.slice;
exports.slice = slice;

},{}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;
exports.axisRight = axisRight;
exports.axisTop = axisTop;

var _array = require("./array");

var _identity = _interopRequireDefault(require("./identity"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function (d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.

  if (scale.round()) offset = Math.round(offset);
  return function (d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
        format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity.default : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "#000"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "#000").attr(x + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "#000").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function (d) {
        return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function (d) {
        var p = this.parentNode.__axis;
        return transform(p && isFinite(p = p(d)) ? p : position(d));
      });
    }

    tickExit.remove();
    path.attr("d", orient === left || orient == right ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);
    tick.attr("opacity", 1).attr("transform", function (d) {
      return transform(position(d));
    });
    line.attr(x + "2", k * tickSizeInner);
    text.attr(x, k * spacing).text(format);
    selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection.each(function () {
      this.__axis = position;
    });
  }

  axis.scale = function (_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function () {
    return tickArguments = _array.slice.call(arguments), axis;
  };

  axis.tickArguments = function (_) {
    return arguments.length ? (tickArguments = _ == null ? [] : _array.slice.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function (_) {
    return arguments.length ? (tickValues = _ == null ? null : _array.slice.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function (_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function (_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function (_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function (_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function (_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

},{"./array":34,"./identity":36}],36:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "brush", {
  enumerable: true,
  get: function () {
    return _brush.default;
  }
});
Object.defineProperty(exports, "brushSelection", {
  enumerable: true,
  get: function () {
    return _brush.brushSelection;
  }
});
Object.defineProperty(exports, "brushX", {
  enumerable: true,
  get: function () {
    return _brush.brushX;
  }
});
Object.defineProperty(exports, "brushY", {
  enumerable: true,
  get: function () {
    return _brush.brushY;
  }
});

var _brush = _interopRequireWildcard(require("./src/brush"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./src/brush":38}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brushSelection = brushSelection;
exports.brushX = brushX;
exports.brushY = brushY;
exports.default = _default;

var _d3Dispatch = require("d3-dispatch");

var _d3Drag = require("d3-drag");

var _d3Interpolate = require("d3-interpolate");

var _d3Selection = require("d3-selection");

var _d3Transition = require("d3-transition");

var _constant = _interopRequireDefault(require("./constant"));

var _event = _interopRequireDefault(require("./event"));

var _noevent = _interopRequireWildcard(require("./noevent"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MODE_DRAG = {
  name: "drag"
},
    MODE_SPACE = {
  name: "space"
},
    MODE_HANDLE = {
  name: "handle"
},
    MODE_CENTER = {
  name: "center"
};
var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function (x, e) {
    return x && [[x[0], e[0][1]], [x[1], e[1][1]]];
  },
  output: function (xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function (y, e) {
    return y && [[e[0][0], y[0]], [e[1][0], y[1]]];
  },
  output: function (xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function (xy) {
    return xy;
  },
  output: function (xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};
var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {
    type: t
  };
} // Ignore right-click, since that should open the context menu.


function defaultFilter() {
  return !_d3Selection.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
} // Like d3.local, but with the name “__brush” rather than auto-generated.


function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;

  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush(X);
}

function brushY() {
  return brush(Y);
}

function _default() {
  return brush(XY);
}

function brush(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = (0, _d3Dispatch.dispatch)(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function () {
      var extent = local(this).extent;
      (0, _d3Selection.select)(this).attr("x", extent[0][0]).attr("y", extent[0][1]).attr("width", extent[1][0] - extent[0][0]).attr("height", extent[1][1] - extent[0][1]);
    });
    group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function (d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function (d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function (d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function (group, selection) {
    if (group.selection) {
      group.on("start.brush", function () {
        emitter(this, arguments).beforestart().start();
      }).on("interrupt.brush end.brush", function () {
        emitter(this, arguments).end();
      }).tween("brush", function () {
        var that = this,
            state = that.__brush,
            emit = emitter(that, arguments),
            selection0 = state.selection,
            selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
            i = (0, _d3Interpolate.interpolate)(selection0, selection1);

        function tween(t) {
          state.selection = t === 1 && empty(selection1) ? null : i(t);
          redraw.call(that);
          emit.brush();
        }

        return selection0 && selection1 ? tween : tween(1);
      });
    } else {
      group.each(function () {
        var that = this,
            args = arguments,
            state = that.__brush,
            selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
            emit = emitter(that, args).beforestart();
        (0, _d3Transition.interrupt)(that);
        state.selection = selection1 == null || empty(selection1) ? null : selection1;
        redraw.call(that);
        emit.start().brush().end();
      });
    }
  };

  function redraw() {
    var group = (0, _d3Selection.select)(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection").style("display", null).attr("x", selection[0][0]).attr("y", selection[0][1]).attr("width", selection[1][0] - selection[0][0]).attr("height", selection[1][1] - selection[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function (d) {
        return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2;
      }).attr("y", function (d) {
        return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2;
      }).attr("width", function (d) {
        return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize;
      }).attr("height", function (d) {
        return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function () {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function () {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function () {
      this.emit("brush");
      return this;
    },
    end: function () {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function (type) {
      (0, _d3Selection.customEvent)(new _event.default(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (_d3Selection.event.touches) {
      if (_d3Selection.event.changedTouches.length < _d3Selection.event.touches.length) return (0, _noevent.default)();
    } else if (touchending) return;

    if (!filter.apply(this, arguments)) return;
    var that = this,
        type = _d3Selection.event.target.__data__.type,
        mode = (_d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : _d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE,
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0],
        w0,
        w1,
        N = extent[0][1],
        n0,
        n1,
        E = extent[1][0],
        e0,
        e1,
        S = extent[1][1],
        s0,
        s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && _d3Selection.event.shiftKey,
        lockX,
        lockY,
        point0 = (0, _d3Selection.mouse)(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [[w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]], [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = (0, _d3Selection.select)(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type]);

    if (_d3Selection.event.touches) {
      group.on("touchmove.brush", moved, true).on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = (0, _d3Selection.select)(_d3Selection.event.view).on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      (0, _d3Drag.dragDisable)(_d3Selection.event.view);
    }

    (0, _noevent.nopropagation)();
    (0, _d3Transition.interrupt)(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = (0, _d3Selection.mouse)(that);

      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;else lockX = true;
      }

      point = point1;
      moving = true;
      (0, _noevent.default)();
      move();
    }

    function move() {
      var t;
      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG:
          {
            if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
            if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
            break;
          }

        case MODE_HANDLE:
          {
            if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
            break;
          }

        case MODE_CENTER:
          {
            if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
            if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
            break;
          }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!

      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1 || selection[0][1] !== n1 || selection[1][0] !== e1 || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      (0, _noevent.nopropagation)();

      if (_d3Selection.event.touches) {
        if (_d3Selection.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function () {
          touchending = null;
        }, 500); // Ghost clicks are delayed!

        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        (0, _d3Drag.dragEnable)(_d3Selection.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }

      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!

      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (_d3Selection.event.keyCode) {
        case 16:
          {
            // SHIFT
            shifting = signX && signY;
            break;
          }

        case 18:
          {
            // ALT
            if (mode === MODE_HANDLE) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
              move();
            }

            break;
          }

        case 32:
          {
            // SPACE; takes priority over ALT
            if (mode === MODE_HANDLE || mode === MODE_CENTER) {
              if (signX < 0) e0 = e1 - dx;else if (signX > 0) w0 = w1 - dx;
              if (signY < 0) s0 = s1 - dy;else if (signY > 0) n0 = n1 - dy;
              mode = MODE_SPACE;
              overlay.attr("cursor", cursors.selection);
              move();
            }

            break;
          }

        default:
          return;
      }

      (0, _noevent.default)();
    }

    function keyupped() {
      switch (_d3Selection.event.keyCode) {
        case 16:
          {
            // SHIFT
            if (shifting) {
              lockX = lockY = shifting = false;
              move();
            }

            break;
          }

        case 18:
          {
            // ALT
            if (mode === MODE_CENTER) {
              if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
              move();
            }

            break;
          }

        case 32:
          {
            // SPACE
            if (mode === MODE_SPACE) {
              if (_d3Selection.event.altKey) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
              } else {
                if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
              }

              overlay.attr("cursor", cursors[type]);
              move();
            }

            break;
          }

        default:
          return;
      }

      (0, _noevent.default)();
    }
  }

  function initialize() {
    var state = this.__brush || {
      selection: null
    };
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0, _constant.default)([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), brush) : filter;
  };

  brush.handleSize = function (_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

},{"./constant":39,"./event":40,"./noevent":41,"d3-dispatch":61,"d3-drag":63,"d3-interpolate":201,"d3-selection":295,"d3-transition":371}],39:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

},{}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.nopropagation = nopropagation;

var _d3Selection = require("d3-selection");

function nopropagation() {
  _d3Selection.event.stopImmediatePropagation();
}

function _default() {
  _d3Selection.event.preventDefault();

  _d3Selection.event.stopImmediatePropagation();
}

},{"d3-selection":295}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "chord", {
  enumerable: true,
  get: function () {
    return _chord.default;
  }
});
Object.defineProperty(exports, "ribbon", {
  enumerable: true,
  get: function () {
    return _ribbon.default;
  }
});

var _chord = _interopRequireDefault(require("./src/chord"));

var _ribbon = _interopRequireDefault(require("./src/ribbon"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/chord":44,"./src/ribbon":47}],43:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Array = require("d3-array");

var _math = require("./math");

function compareValue(compare) {
  return function (a, b) {
    return compare(a.source.value + a.target.value, b.source.value + b.target.value);
  };
}

function _default() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = (0, _d3Array.range)(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j; // Compute the sum.

    k = 0, i = -1;

    while (++i < n) {
      x = 0, j = -1;

      while (++j < n) {
        x += matrix[i][j];
      }

      groupSums.push(x);
      subgroupIndex.push((0, _d3Array.range)(n));
      k += x;
    } // Sort groups…


    if (sortGroups) groupIndex.sort(function (a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    }); // Sort subgroups…

    if (sortSubgroups) subgroupIndex.forEach(function (d, i) {
      d.sort(function (a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    }); // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?

    k = (0, _math.max)(0, _math.tau - padAngle * n) / k;
    dx = k ? padAngle : _math.tau / n; // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!

    x = 0, i = -1;

    while (++i < n) {
      x0 = x, j = -1;

      while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }

      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    } // Generate chords for each (non-empty) subgroup-subgroup link.


    i = -1;

    while (++i < n) {
      j = i - 1;

      while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];

        if (source.value || target.value) {
          chords.push(source.value < target.value ? {
            source: target,
            target: source
          } : {
            source: source,
            target: target
          });
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function (_) {
    return arguments.length ? (padAngle = (0, _math.max)(0, _), chord) : padAngle;
  };

  chord.sortGroups = function (_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function (_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function (_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}

},{"./math":46,"d3-array":1}],45:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tau = exports.sin = exports.pi = exports.max = exports.halfPi = exports.cos = void 0;
var cos = Math.cos;
exports.cos = cos;
var sin = Math.sin;
exports.sin = sin;
var pi = Math.PI;
exports.pi = pi;
var halfPi = pi / 2;
exports.halfPi = halfPi;
var tau = pi * 2;
exports.tau = tau;
var max = Math.max;
exports.max = max;

},{}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("./array");

var _constant = _interopRequireDefault(require("./constant"));

var _math = require("./math");

var _d3Path = require("d3-path");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function _default() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = _array.slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - _math.halfPi,
        sa1 = endAngle.apply(this, argv) - _math.halfPi,
        sx0 = sr * (0, _math.cos)(sa0),
        sy0 = sr * (0, _math.sin)(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - _math.halfPi,
        ta1 = endAngle.apply(this, argv) - _math.halfPi;

    if (!context) context = buffer = (0, _d3Path.path)();
    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);

    if (sa0 !== ta0 || sa1 !== ta1) {
      // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * (0, _math.cos)(ta0), tr * (0, _math.sin)(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }

    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0, _constant.default)(+_), ribbon) : radius;
  };

  ribbon.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), ribbon) : endAngle;
  };

  ribbon.source = function (_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function (_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, ribbon) : context;
  };

  return ribbon;
}

},{"./array":43,"./constant":45,"./math":46,"d3-path":223}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "entries", {
  enumerable: true,
  get: function () {
    return _entries.default;
  }
});
Object.defineProperty(exports, "keys", {
  enumerable: true,
  get: function () {
    return _keys.default;
  }
});
Object.defineProperty(exports, "map", {
  enumerable: true,
  get: function () {
    return _map.default;
  }
});
Object.defineProperty(exports, "nest", {
  enumerable: true,
  get: function () {
    return _nest.default;
  }
});
Object.defineProperty(exports, "set", {
  enumerable: true,
  get: function () {
    return _set.default;
  }
});
Object.defineProperty(exports, "values", {
  enumerable: true,
  get: function () {
    return _values.default;
  }
});

var _nest = _interopRequireDefault(require("./src/nest"));

var _set = _interopRequireDefault(require("./src/set"));

var _map = _interopRequireDefault(require("./src/map"));

var _keys = _interopRequireDefault(require("./src/keys"));

var _values = _interopRequireDefault(require("./src/values"));

var _entries = _interopRequireDefault(require("./src/entries"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/entries":49,"./src/keys":50,"./src/map":51,"./src/nest":52,"./src/set":53,"./src/values":54}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(map) {
  var entries = [];

  for (var key in map) entries.push({
    key: key,
    value: map[key]
  });

  return entries;
}

},{}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(map) {
  var keys = [];

  for (var key in map) keys.push(key);

  return keys;
}

},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefix = exports.default = void 0;
var prefix = "$";
exports.prefix = prefix;

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function (key) {
    return prefix + key in this;
  },
  get: function (key) {
    return this[prefix + key];
  },
  set: function (key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function (key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function () {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function () {
    var keys = [];

    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));

    return keys;
  },
  values: function () {
    var values = [];

    for (var property in this) if (property[0] === prefix) values.push(this[property]);

    return values;
  },
  entries: function () {
    var entries = [];

    for (var property in this) if (property[0] === prefix) entries.push({
      key: property.slice(1),
      value: this[property]
    });

    return entries;
  },
  size: function () {
    var size = 0;

    for (var property in this) if (property[0] === prefix) ++size;

    return size;
  },
  empty: function () {
    for (var property in this) if (property[0] === prefix) return false;

    return true;
  },
  each: function (f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map(); // Copy constructor.

  if (object instanceof Map) object.each(function (value, key) {
    map.set(key, value);
  }); // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;
    if (f == null) while (++i < n) map.set(i, object[i]);else while (++i < n) map.set(f(o = object[i], i, object), o);
  } // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);
  return map;
}

var _default = map;
exports.default = _default;

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _map = _interopRequireDefault(require("./map"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = (0, _map.default)(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function (values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });
    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array,
        sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
      array.push({
        key: k,
        values: entries(v, depth)
      });
    });
    return sortKey != null ? array.sort(function (a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }

  return nest = {
    object: function (array) {
      return apply(array, 0, createObject, setObject);
    },
    map: function (array) {
      return apply(array, 0, createMap, setMap);
    },
    entries: function (array) {
      return entries(apply(array, 0, createMap, setMap), 0);
    },
    key: function (d) {
      keys.push(d);
      return nest;
    },
    sortKeys: function (order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    },
    sortValues: function (order) {
      sortValues = order;
      return nest;
    },
    rollup: function (f) {
      rollup = f;
      return nest;
    }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return (0, _map.default)();
}

function setMap(map, key, value) {
  map.set(key, value);
}

},{"./map":51}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _map = _interopRequireWildcard(require("./map"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function Set() {}

var proto = _map.default.prototype;
Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function (value) {
    value += "";
    this[_map.prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set(); // Copy constructor.

  if (object instanceof Set) object.each(function (value) {
    set.add(value);
  }); // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1,
        n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);else while (++i < n) set.add(f(object[i], i, object));
  }
  return set;
}

var _default = set;
exports.default = _default;

},{"./map":51}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(map) {
  var values = [];

  for (var key in map) values.push(map[key]);

  return values;
}

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "color", {
  enumerable: true,
  get: function () {
    return _color.default;
  }
});
Object.defineProperty(exports, "cubehelix", {
  enumerable: true,
  get: function () {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "hcl", {
  enumerable: true,
  get: function () {
    return _lab.hcl;
  }
});
Object.defineProperty(exports, "hsl", {
  enumerable: true,
  get: function () {
    return _color.hsl;
  }
});
Object.defineProperty(exports, "lab", {
  enumerable: true,
  get: function () {
    return _lab.default;
  }
});
Object.defineProperty(exports, "rgb", {
  enumerable: true,
  get: function () {
    return _color.rgb;
  }
});

var _color = _interopRequireWildcard(require("./src/color"));

var _lab = _interopRequireWildcard(require("./src/lab"));

var _cubehelix = _interopRequireDefault(require("./src/cubehelix"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./src/color":56,"./src/cubehelix":57,"./src/lab":59}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Color = Color;
exports.Rgb = Rgb;
exports.darker = exports.brighter = void 0;
exports.default = color;
exports.hsl = hsl;
exports.hslConvert = hslConvert;
exports.rgb = rgb;
exports.rgbConvert = rgbConvert;

var _define = _interopRequireWildcard(require("./define"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function Color() {}

var darker = 0.7;
exports.darker = darker;
var brighter = 1 / darker;
exports.brighter = brighter;
var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
(0, _define.default)(Color, color, {
  displayable: function () {
    return this.rgb().displayable();
  },
  toString: function () {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  ) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
  : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0, _define.default)(Rgb, rgb, (0, _define.extend)(Color, {
  brighter: function (k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function (k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function () {
    return this;
  },
  displayable: function () {
    return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
  },
  toString: function () {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;

  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }

  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0, _define.default)(Hsl, hsl, (0, _define.extend)(Color, {
  brighter: function (k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function (k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function () {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function () {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  }
}));
/* From FvD 13.37, CSS Color Module Level 3 */

function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

},{"./define":58}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cubehelix = Cubehelix;
exports.default = cubehelix;

var _define = _interopRequireWildcard(require("./define"));

var _color = require("./color");

var _math = require("./math");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color.Rgb)) o = (0, _color.rgbConvert)(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
      // NaN if l=0 or l=1
  h = s ? Math.atan2(k, bl) * _math.rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0, _define.default)(Cubehelix, cubehelix, (0, _define.extend)(_color.Color, {
  brighter: function (k) {
    k = k == null ? _color.brighter : Math.pow(_color.brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function (k) {
    k = k == null ? _color.darker : Math.pow(_color.darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function () {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math.deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color.Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
  }
}));

},{"./color":56,"./define":58,"./math":60}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.extend = extend;

function _default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);

  for (var key in definition) prototype[key] = definition[key];

  return prototype;
}

},{}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hcl = Hcl;
exports.Lab = Lab;
exports.default = lab;
exports.hcl = hcl;

var _define = _interopRequireWildcard(require("./define"));

var _color = require("./color");

var _math = require("./math");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Kn = 18,
    Xn = 0.950470,
    // D65 standard referent
Yn = 1,
    Zn = 1.088830,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);

  if (o instanceof Hcl) {
    var h = o.h * _math.deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }

  if (!(o instanceof _color.Rgb)) o = (0, _color.rgbConvert)(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0, _define.default)(Lab, lab, (0, _define.extend)(_color.Color, {
  brighter: function (k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function (k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function () {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new _color.Rgb(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
    xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);

  var h = Math.atan2(o.b, o.a) * _math.rad2deg;

  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

(0, _define.default)(Hcl, hcl, (0, _define.extend)(_color.Color, {
  brighter: function (k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function (k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function () {
    return labConvert(this).rgb();
  }
}));

},{"./color":56,"./define":58,"./math":60}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rad2deg = exports.deg2rad = void 0;
var deg2rad = Math.PI / 180;
exports.deg2rad = deg2rad;
var rad2deg = 180 / Math.PI;
exports.rad2deg = rad2deg;

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "dispatch", {
  enumerable: true,
  get: function () {
    return _dispatch.default;
  }
});

var _dispatch = _interopRequireDefault(require("./src/dispatch"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/dispatch":62}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var noop = {
  value: function () {}
};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _) throw new Error("illegal type: " + t);
    _[t] = [];
  }

  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {
      type: t,
      name: name
    };
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function (typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length; // If no callback was specified, return the callback of the given type and name.

    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;

      return;
    } // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.


    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function () {
    var copy = {},
        _ = this._;

    for (var t in _) copy[t] = _[t].slice();

    return new Dispatch(copy);
  },
  call: function (type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function (type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }

  if (callback != null) type.push({
    name: name,
    value: callback
  });
  return type;
}

var _default = dispatch;
exports.default = _default;

},{}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "drag", {
  enumerable: true,
  get: function () {
    return _drag.default;
  }
});
Object.defineProperty(exports, "dragDisable", {
  enumerable: true,
  get: function () {
    return _nodrag.default;
  }
});
Object.defineProperty(exports, "dragEnable", {
  enumerable: true,
  get: function () {
    return _nodrag.yesdrag;
  }
});

var _drag = _interopRequireDefault(require("./src/drag"));

var _nodrag = _interopRequireWildcard(require("./src/nodrag"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/drag":65,"./src/nodrag":67}],64:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Dispatch = require("d3-dispatch");

var _d3Selection = require("d3-selection");

var _nodrag = _interopRequireWildcard(require("./nodrag"));

var _noevent = _interopRequireWildcard(require("./noevent"));

var _constant = _interopRequireDefault(require("./constant"));

var _event = _interopRequireDefault(require("./event"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !_d3Selection.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {
    x: _d3Selection.event.x,
    y: _d3Selection.event.y
  } : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function _default() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = (0, _d3Dispatch.dispatch)("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), _d3Selection.mouse, this, arguments);
    if (!gesture) return;
    (0, _d3Selection.select)(_d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    (0, _nodrag.default)(_d3Selection.event.view);
    (0, _noevent.nopropagation)();
    mousemoving = false;
    mousedownx = _d3Selection.event.clientX;
    mousedowny = _d3Selection.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    (0, _noevent.default)();

    if (!mousemoving) {
      var dx = _d3Selection.event.clientX - mousedownx,
          dy = _d3Selection.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }

    gestures.mouse("drag");
  }

  function mouseupped() {
    (0, _d3Selection.select)(_d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
    (0, _nodrag.yesdrag)(_d3Selection.event.view, mousemoving);
    (0, _noevent.default)();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = _d3Selection.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, _d3Selection.touch, this, arguments)) {
        (0, _noevent.nopropagation)();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = _d3Selection.event.changedTouches,
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0, _noevent.default)();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = _d3Selection.event.changedTouches,
        n = touches.length,
        i,
        gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, 500); // Ghost clicks are delayed!

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0, _noevent.nopropagation)();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id),
        s,
        dx,
        dy,
        sublisteners = listeners.copy();
    if (!(0, _d3Selection.customEvent)(new _event.default(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
      if ((_d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;
    return function gesture(type) {
      var p0 = p,
          n;

      switch (type) {
        case "start":
          gestures[id] = gesture, n = active++;
          break;

        case "end":
          delete gestures[id], --active;
        // nobreak

        case "drag":
          p = point(container, id), n = active;
          break;
      }

      (0, _d3Selection.customEvent)(new _event.default(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), drag) : filter;
  };

  drag.container = function (_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : (0, _constant.default)(_), drag) : container;
  };

  drag.subject = function (_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : (0, _constant.default)(_), drag) : subject;
  };

  drag.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0, _constant.default)(!!_), drag) : touchable;
  };

  drag.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

},{"./constant":64,"./event":66,"./nodrag":67,"./noevent":68,"d3-dispatch":61,"d3-selection":295}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DragEvent;

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function () {
  var value = this._.on.apply(this._, arguments);

  return value === this._ ? this : value;
};

},{}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.yesdrag = yesdrag;

var _d3Selection = require("d3-selection");

var _noevent = _interopRequireDefault(require("./noevent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(view) {
  var root = view.document.documentElement,
      selection = (0, _d3Selection.select)(view).on("dragstart.drag", _noevent.default, true);

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent.default, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0, _d3Selection.select)(view).on("dragstart.drag", null);

  if (noclick) {
    selection.on("click.drag", _noevent.default, true);
    setTimeout(function () {
      selection.on("click.drag", null);
    }, 0);
  }

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

},{"./noevent":68,"d3-selection":295}],68:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"d3-selection":295,"dup":41}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "csvFormat", {
  enumerable: true,
  get: function () {
    return _csv.csvFormat;
  }
});
Object.defineProperty(exports, "csvFormatRows", {
  enumerable: true,
  get: function () {
    return _csv.csvFormatRows;
  }
});
Object.defineProperty(exports, "csvParse", {
  enumerable: true,
  get: function () {
    return _csv.csvParse;
  }
});
Object.defineProperty(exports, "csvParseRows", {
  enumerable: true,
  get: function () {
    return _csv.csvParseRows;
  }
});
Object.defineProperty(exports, "dsvFormat", {
  enumerable: true,
  get: function () {
    return _dsv.default;
  }
});
Object.defineProperty(exports, "tsvFormat", {
  enumerable: true,
  get: function () {
    return _tsv.tsvFormat;
  }
});
Object.defineProperty(exports, "tsvFormatRows", {
  enumerable: true,
  get: function () {
    return _tsv.tsvFormatRows;
  }
});
Object.defineProperty(exports, "tsvParse", {
  enumerable: true,
  get: function () {
    return _tsv.tsvParse;
  }
});
Object.defineProperty(exports, "tsvParseRows", {
  enumerable: true,
  get: function () {
    return _tsv.tsvParseRows;
  }
});

var _dsv = _interopRequireDefault(require("./src/dsv"));

var _csv = require("./src/csv");

var _tsv = require("./src/tsv");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/csv":70,"./src/dsv":71,"./src/tsv":72}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.csvParseRows = exports.csvParse = exports.csvFormatRows = exports.csvFormat = void 0;

var _dsv = _interopRequireDefault(require("./dsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var csv = (0, _dsv.default)(",");
var csvParse = csv.parse;
exports.csvParse = csvParse;
var csvParseRows = csv.parseRows;
exports.csvParseRows = csvParseRows;
var csvFormat = csv.format;
exports.csvFormat = csvFormat;
var csvFormatRows = csv.formatRows;
exports.csvFormatRows = csvFormatRows;

},{"./dsv":71}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function (name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function (row, i) {
    return f(object(row), i, columns);
  };
} // Compute unique columns in order of discovery.


function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];
  rows.forEach(function (row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}

function _default(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert,
        columns,
        rows = parseRows(text, function (row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [],
        // output rows
    N = text.length,
        I = 0,
        // current character index
    n = 0,
        // current line number
    t,
        // current token
    eof = N <= 0,
        // current token followed by EOF?
    eol = false; // current token followed by EOL?
    // Strip the trailing newline.

    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL; // Unescape quotes.

      var i,
          j = I,
          c;

      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);

        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      } // Find next delimiter or newline.


      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      } // Return last token before EOF.


      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];

      while (t !== EOL && t !== EOF) row.push(t), t = token();

      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
      return columns.map(function (column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? "" : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\"" : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
}

},{}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tsvParseRows = exports.tsvParse = exports.tsvFormatRows = exports.tsvFormat = void 0;

var _dsv = _interopRequireDefault(require("./dsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tsv = (0, _dsv.default)("\t");
var tsvParse = tsv.parse;
exports.tsvParse = tsvParse;
var tsvParseRows = tsv.parseRows;
exports.tsvParseRows = tsvParseRows;
var tsvFormat = tsv.format;
exports.tsvFormat = tsvFormat;
var tsvFormatRows = tsv.formatRows;
exports.tsvFormatRows = tsvFormatRows;

},{"./dsv":71}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backOut = exports.backInOut = exports.backIn = void 0;
var overshoot = 1.70158;

var backIn = function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;
  return backIn;
}(overshoot);

exports.backIn = backIn;

var backOut = function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;
  return backOut;
}(overshoot);

exports.backOut = backOut;

var backInOut = function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;
  return backInOut;
}(overshoot);

exports.backInOut = backInOut;

},{}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bounceIn = bounceIn;
exports.bounceInOut = bounceInOut;
exports.bounceOut = bounceOut;
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

},{}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleIn = circleIn;
exports.circleInOut = circleInOut;
exports.circleOut = circleOut;

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

},{}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubicIn = cubicIn;
exports.cubicInOut = cubicInOut;
exports.cubicOut = cubicOut;

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

},{}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.elasticOut = exports.elasticInOut = exports.elasticIn = void 0;

var _math = require("./math.js");

var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * (0, _math.tpmt)(- --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticIn.period = function (p) {
    return custom(a, p);
  };

  return elasticIn;
}(amplitude, period);

exports.elasticIn = elasticIn;

var elasticOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * (0, _math.tpmt)(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticOut.period = function (p) {
    return custom(a, p);
  };

  return elasticOut;
}(amplitude, period);

exports.elasticOut = elasticOut;

var elasticInOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0 ? a * (0, _math.tpmt)(-t) * Math.sin((s - t) / p) : 2 - a * (0, _math.tpmt)(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticInOut.period = function (p) {
    return custom(a, p);
  };

  return elasticInOut;
}(amplitude, period);

exports.elasticInOut = elasticInOut;

},{"./math.js":81}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expIn = expIn;
exports.expInOut = expInOut;
exports.expOut = expOut;

var _math = require("./math.js");

function expIn(t) {
  return (0, _math.tpmt)(1 - +t);
}

function expOut(t) {
  return 1 - (0, _math.tpmt)(t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? (0, _math.tpmt)(1 - t) : 2 - (0, _math.tpmt)(t - 1)) / 2;
}

},{"./math.js":81}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "easeBack", {
  enumerable: true,
  get: function () {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeBackIn", {
  enumerable: true,
  get: function () {
    return _back.backIn;
  }
});
Object.defineProperty(exports, "easeBackInOut", {
  enumerable: true,
  get: function () {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeBackOut", {
  enumerable: true,
  get: function () {
    return _back.backOut;
  }
});
Object.defineProperty(exports, "easeBounce", {
  enumerable: true,
  get: function () {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeBounceIn", {
  enumerable: true,
  get: function () {
    return _bounce.bounceIn;
  }
});
Object.defineProperty(exports, "easeBounceInOut", {
  enumerable: true,
  get: function () {
    return _bounce.bounceInOut;
  }
});
Object.defineProperty(exports, "easeBounceOut", {
  enumerable: true,
  get: function () {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeCircle", {
  enumerable: true,
  get: function () {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeCircleIn", {
  enumerable: true,
  get: function () {
    return _circle.circleIn;
  }
});
Object.defineProperty(exports, "easeCircleInOut", {
  enumerable: true,
  get: function () {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeCircleOut", {
  enumerable: true,
  get: function () {
    return _circle.circleOut;
  }
});
Object.defineProperty(exports, "easeCubic", {
  enumerable: true,
  get: function () {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easeCubicIn", {
  enumerable: true,
  get: function () {
    return _cubic.cubicIn;
  }
});
Object.defineProperty(exports, "easeCubicInOut", {
  enumerable: true,
  get: function () {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easeCubicOut", {
  enumerable: true,
  get: function () {
    return _cubic.cubicOut;
  }
});
Object.defineProperty(exports, "easeElastic", {
  enumerable: true,
  get: function () {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeElasticIn", {
  enumerable: true,
  get: function () {
    return _elastic.elasticIn;
  }
});
Object.defineProperty(exports, "easeElasticInOut", {
  enumerable: true,
  get: function () {
    return _elastic.elasticInOut;
  }
});
Object.defineProperty(exports, "easeElasticOut", {
  enumerable: true,
  get: function () {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeExp", {
  enumerable: true,
  get: function () {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeExpIn", {
  enumerable: true,
  get: function () {
    return _exp.expIn;
  }
});
Object.defineProperty(exports, "easeExpInOut", {
  enumerable: true,
  get: function () {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeExpOut", {
  enumerable: true,
  get: function () {
    return _exp.expOut;
  }
});
Object.defineProperty(exports, "easeLinear", {
  enumerable: true,
  get: function () {
    return _linear.linear;
  }
});
Object.defineProperty(exports, "easePoly", {
  enumerable: true,
  get: function () {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easePolyIn", {
  enumerable: true,
  get: function () {
    return _poly.polyIn;
  }
});
Object.defineProperty(exports, "easePolyInOut", {
  enumerable: true,
  get: function () {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easePolyOut", {
  enumerable: true,
  get: function () {
    return _poly.polyOut;
  }
});
Object.defineProperty(exports, "easeQuad", {
  enumerable: true,
  get: function () {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeQuadIn", {
  enumerable: true,
  get: function () {
    return _quad.quadIn;
  }
});
Object.defineProperty(exports, "easeQuadInOut", {
  enumerable: true,
  get: function () {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeQuadOut", {
  enumerable: true,
  get: function () {
    return _quad.quadOut;
  }
});
Object.defineProperty(exports, "easeSin", {
  enumerable: true,
  get: function () {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeSinIn", {
  enumerable: true,
  get: function () {
    return _sin.sinIn;
  }
});
Object.defineProperty(exports, "easeSinInOut", {
  enumerable: true,
  get: function () {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeSinOut", {
  enumerable: true,
  get: function () {
    return _sin.sinOut;
  }
});

var _linear = require("./linear.js");

var _quad = require("./quad.js");

var _cubic = require("./cubic.js");

var _poly = require("./poly.js");

var _sin = require("./sin.js");

var _exp = require("./exp.js");

var _circle = require("./circle.js");

var _bounce = require("./bounce.js");

var _back = require("./back.js");

var _elastic = require("./elastic.js");

},{"./back.js":73,"./bounce.js":74,"./circle.js":75,"./cubic.js":76,"./elastic.js":77,"./exp.js":78,"./linear.js":80,"./poly.js":82,"./quad.js":83,"./sin.js":84}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linear = linear;

function linear(t) {
  return +t;
}

},{}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tpmt = tpmt;

// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}

},{}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyOut = exports.polyInOut = exports.polyIn = void 0;
var exponent = 3;

var polyIn = function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;
  return polyIn;
}(exponent);

exports.polyIn = polyIn;

var polyOut = function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;
  return polyOut;
}(exponent);

exports.polyOut = polyOut;

var polyInOut = function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;
  return polyInOut;
}(exponent);

exports.polyInOut = polyInOut;

},{}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.quadIn = quadIn;
exports.quadInOut = quadInOut;
exports.quadOut = quadOut;

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

},{}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sinIn = sinIn;
exports.sinInOut = sinInOut;
exports.sinOut = sinOut;
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

},{}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "forceCenter", {
  enumerable: true,
  get: function () {
    return _center.default;
  }
});
Object.defineProperty(exports, "forceCollide", {
  enumerable: true,
  get: function () {
    return _collide.default;
  }
});
Object.defineProperty(exports, "forceLink", {
  enumerable: true,
  get: function () {
    return _link.default;
  }
});
Object.defineProperty(exports, "forceManyBody", {
  enumerable: true,
  get: function () {
    return _manyBody.default;
  }
});
Object.defineProperty(exports, "forceRadial", {
  enumerable: true,
  get: function () {
    return _radial.default;
  }
});
Object.defineProperty(exports, "forceSimulation", {
  enumerable: true,
  get: function () {
    return _simulation.default;
  }
});
Object.defineProperty(exports, "forceX", {
  enumerable: true,
  get: function () {
    return _x.default;
  }
});
Object.defineProperty(exports, "forceY", {
  enumerable: true,
  get: function () {
    return _y.default;
  }
});

var _center = _interopRequireDefault(require("./src/center"));

var _collide = _interopRequireDefault(require("./src/collide"));

var _link = _interopRequireDefault(require("./src/link"));

var _manyBody = _interopRequireDefault(require("./src/manyBody"));

var _radial = _interopRequireDefault(require("./src/radial"));

var _simulation = _interopRequireDefault(require("./src/simulation"));

var _x = _interopRequireDefault(require("./src/x"));

var _y = _interopRequireDefault(require("./src/y"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/center":86,"./src/collide":87,"./src/link":90,"./src/manyBody":91,"./src/radial":92,"./src/simulation":93,"./src/x":94,"./src/y":95}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, y) {
  var nodes;
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function (_) {
    nodes = _;
  };

  force.x = function (_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function (_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _jiggle = _interopRequireDefault(require("./jiggle"));

var _d3Quadtree = require("d3-quadtree");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function _default(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;
  if (typeof radius !== "function") radius = (0, _constant.default)(radius == null ? 1 : +radius);

  function force() {
    var i,
        n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0, _d3Quadtree.quadtree)(nodes, x, y).visitAfter(prepare);

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data,
          rj = quad.r,
          r = ri + rj;

      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;

          if (l < r * r) {
            if (x === 0) x = (0, _jiggle.default)(), l += x * x;
            if (y === 0) y = (0, _jiggle.default)(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }

        return;
      }

      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];

    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        node;
    radii = new Array(n);

    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : radius;
  };

  return force;
}

},{"./constant":88,"./jiggle":89,"d3-quadtree":232}],88:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return (Math.random() - 0.5) * 1e-6;
}

},{}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _jiggle = _interopRequireDefault(require("./jiggle"));

var _d3Collection = require("d3-collection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

function _default(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = (0, _constant.default)(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;
  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || (0, _jiggle.default)();
        y = target.y + target.vy - source.y - source.vy || (0, _jiggle.default)();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        m = links.length,
        nodeById = (0, _d3Collection.map)(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.links = function (_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function (_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initializeStrength(), force) : strength;
  };

  force.distance = function (_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : (0, _constant.default)(+_), initializeDistance(), force) : distance;
  };

  return force;
}

},{"./constant":88,"./jiggle":89,"d3-collection":48}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _jiggle = _interopRequireDefault(require("./jiggle"));

var _d3Quadtree = require("d3-quadtree");

var _simulation = require("./simulation");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var nodes,
      node,
      alpha,
      strength = (0, _constant.default)(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i,
        n = nodes.length,
        tree = (0, _d3Quadtree.quadtree)(nodes, _simulation.x, _simulation.y).visitAfter(accumulate);

    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        node;
    strengths = new Array(n);

    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0,
        q,
        c,
        weight = 0,
        x,
        y,
        i; // For internal nodes, accumulate forces from child quadrants.

    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }

      quad.x = x / weight;
      quad.y = y / weight;
    } // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;

      do strength += strengths[q.data.index]; while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;
    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y; // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.

    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = (0, _jiggle.default)(), l += x * x;
        if (y === 0) y = (0, _jiggle.default)(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }

      return true;
    } // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return; // Limit forces for very close nodes; randomize direction if coincident.


    if (quad.data !== node || quad.next) {
      if (x === 0) x = (0, _jiggle.default)(), l += x * x;
      if (y === 0) y = (0, _jiggle.default)(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : strength;
  };

  force.distanceMin = function (_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function (_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function (_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}

},{"./constant":88,"./jiggle":89,"./simulation":93,"d3-quadtree":232}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(radius, x, y) {
  var nodes,
      strength = (0, _constant.default)(0.1),
      strengths,
      radiuses;
  if (typeof radius !== "function") radius = (0, _constant.default)(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);

    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _, initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : strength;
  };

  force.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : radius;
  };

  force.x = function (_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function (_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

},{"./constant":88}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.x = x;
exports.y = y;

var _d3Dispatch = require("d3-dispatch");

var _d3Collection = require("d3-collection");

var _d3Timer = require("d3-timer");

function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

function _default(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = (0, _d3Collection.map)(),
      stepper = (0, _d3Timer.timer)(step),
      event = (0, _d3Dispatch.dispatch)("tick", "end");
  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);

    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i,
        n = nodes.length,
        node;
    alpha += (alphaTarget - alpha) * alphaDecay;
    forces.each(function (force) {
      force(alpha);
    });

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (node.fx == null) node.x += node.vx *= velocityDecay;else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= velocityDecay;else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;

      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i),
            angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }

      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();
  return simulation = {
    tick: tick,
    restart: function () {
      return stepper.restart(step), simulation;
    },
    stop: function () {
      return stepper.stop(), simulation;
    },
    nodes: function (_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },
    alpha: function (_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },
    alphaMin: function (_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },
    alphaDecay: function (_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },
    alphaTarget: function (_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },
    velocityDecay: function (_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },
    force: function (name, _) {
      return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },
    find: function (x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;
      if (radius == null) radius = Infinity;else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },
    on: function (name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

},{"d3-collection":48,"d3-dispatch":61,"d3-timer":367}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x) {
  var strength = (0, _constant.default)(0.1),
      nodes,
      strengths,
      xz;
  if (typeof x !== "function") x = (0, _constant.default)(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);

    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : strength;
  };

  force.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : x;
  };

  return force;
}

},{"./constant":88}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(y) {
  var strength = (0, _constant.default)(0.1),
      nodes,
      strengths,
      yz;
  if (typeof y !== "function") y = (0, _constant.default)(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);

    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : strength;
  };

  force.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : y;
  };

  return force;
}

},{"./constant":88}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "format", {
  enumerable: true,
  get: function () {
    return _defaultLocale.format;
  }
});
Object.defineProperty(exports, "formatDefaultLocale", {
  enumerable: true,
  get: function () {
    return _defaultLocale.default;
  }
});
Object.defineProperty(exports, "formatLocale", {
  enumerable: true,
  get: function () {
    return _locale.default;
  }
});
Object.defineProperty(exports, "formatPrefix", {
  enumerable: true,
  get: function () {
    return _defaultLocale.formatPrefix;
  }
});
Object.defineProperty(exports, "formatSpecifier", {
  enumerable: true,
  get: function () {
    return _formatSpecifier.default;
  }
});
Object.defineProperty(exports, "precisionFixed", {
  enumerable: true,
  get: function () {
    return _precisionFixed.default;
  }
});
Object.defineProperty(exports, "precisionPrefix", {
  enumerable: true,
  get: function () {
    return _precisionPrefix.default;
  }
});
Object.defineProperty(exports, "precisionRound", {
  enumerable: true,
  get: function () {
    return _precisionRound.default;
  }
});

var _defaultLocale = _interopRequireWildcard(require("./src/defaultLocale"));

var _locale = _interopRequireDefault(require("./src/locale"));

var _formatSpecifier = _interopRequireDefault(require("./src/formatSpecifier"));

var _precisionFixed = _interopRequireDefault(require("./src/precisionFixed"));

var _precisionPrefix = _interopRequireDefault(require("./src/precisionPrefix"));

var _precisionRound = _interopRequireDefault(require("./src/precisionRound"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./src/defaultLocale":97,"./src/formatSpecifier":105,"./src/locale":108,"./src/precisionFixed":109,"./src/precisionPrefix":110,"./src/precisionRound":111}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultLocale;
exports.formatPrefix = exports.format = void 0;

var _locale = _interopRequireDefault(require("./locale"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var locale;
var format;
exports.format = format;
var formatPrefix;
exports.formatPrefix = formatPrefix;
defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0, _locale.default)(definition);
  exports.format = format = locale.format;
  exports.formatPrefix = formatPrefix = locale.formatPrefix;
  return locale;
}

},{"./locale":108}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _formatDecimal = _interopRequireDefault(require("./formatDecimal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x) {
  return x = (0, _formatDecimal.default)(Math.abs(x)), x ? x[1] : NaN;
}

},{"./formatDecimal":99}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function _default(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity

  var i,
      coefficient = x.slice(0, i); // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).

  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
}

},{}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".":
        i0 = i1 = i;
        break;

      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;

      case "e":
        break out;

      default:
        if (i0 > 0) i0 = 0;
        break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
}

},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(grouping, thousands) {
  return function (value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

},{}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(numerals) {
  return function (value) {
    return value.replace(/[0-9]/g, function (i) {
      return numerals[+i];
    });
  };
}

},{}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.prefixExponent = void 0;

var _formatDecimal = _interopRequireDefault(require("./formatDecimal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixExponent;
exports.prefixExponent = prefixExponent;

function _default(x, p) {
  var d = (0, _formatDecimal.default)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (exports.prefixExponent = prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + (0, _formatDecimal.default)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

},{"./formatDecimal":99}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _formatDecimal = _interopRequireDefault(require("./formatDecimal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x, p) {
  var d = (0, _formatDecimal.default)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

},{"./formatDecimal":99}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatSpecifier;

var _formatTypes = _interopRequireDefault(require("./formatTypes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || ""; // The "n" type is an alias for ",g".

  if (type === "n") comma = true, type = "g"; // Map invalid types to the default format.
  else if (!_formatTypes.default[type]) type = ""; // If zero fill is specified, padding goes after sign and before digits.

  if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function () {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + this.type;
};

},{"./formatTypes":106}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _formatDefault = _interopRequireDefault(require("./formatDefault"));

var _formatPrefixAuto = _interopRequireDefault(require("./formatPrefixAuto"));

var _formatRounded = _interopRequireDefault(require("./formatRounded"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  "": _formatDefault.default,
  "%": function (x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function (x) {
    return Math.round(x).toString(2);
  },
  "c": function (x) {
    return x + "";
  },
  "d": function (x) {
    return Math.round(x).toString(10);
  },
  "e": function (x, p) {
    return x.toExponential(p);
  },
  "f": function (x, p) {
    return x.toFixed(p);
  },
  "g": function (x, p) {
    return x.toPrecision(p);
  },
  "o": function (x) {
    return Math.round(x).toString(8);
  },
  "p": function (x, p) {
    return (0, _formatRounded.default)(x * 100, p);
  },
  "r": _formatRounded.default,
  "s": _formatPrefixAuto.default,
  "X": function (x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function (x) {
    return Math.round(x).toString(16);
  }
};
exports.default = _default;

},{"./formatDefault":100,"./formatPrefixAuto":103,"./formatRounded":104}],107:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _exponent = _interopRequireDefault(require("./exponent"));

var _formatGroup = _interopRequireDefault(require("./formatGroup"));

var _formatNumerals = _interopRequireDefault(require("./formatNumerals"));

var _formatSpecifier = _interopRequireDefault(require("./formatSpecifier"));

var _formatTypes = _interopRequireDefault(require("./formatTypes"));

var _formatPrefixAuto = require("./formatPrefixAuto");

var _identity = _interopRequireDefault(require("./identity"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

function _default(locale) {
  var group = locale.grouping && locale.thousands ? (0, _formatGroup.default)(locale.grouping, locale.thousands) : _identity.default,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? (0, _formatNumerals.default)(locale.numerals) : _identity.default,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = (0, _formatSpecifier.default)(specifier);
    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type; // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.

    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : ""; // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?

    var formatType = _formatTypes.default[type],
        maybeSuffix = !type || /[defgprs%]/.test(type); // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].

    precision = precision == null ? type ? 6 : 12 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i,
          n,
          c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value; // Perform the initial formatting.

        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision); // If a negative value rounds to zero during formatting, treat as positive.

        if (valueNegative && +value === 0) valueNegative = false; // Compute the prefix and suffix.

        valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : ""); // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.

        if (maybeSuffix) {
          i = -1, n = value.length;

          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      } // If the fill character is not "0", grouping is applied before padding.


      if (comma && !zero) value = group(value, Infinity); // Compute the padding.

      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : ""; // If the fill character is "0", grouping is applied after padding.

      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = ""; // Reconstruct the final output based on the desired alignment.

      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;

        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;

        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;

        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }

      return numerals(value);
    }

    format.toString = function () {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0, _formatSpecifier.default)(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0, _exponent.default)(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function (value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

},{"./exponent":98,"./formatGroup":101,"./formatNumerals":102,"./formatPrefixAuto":103,"./formatSpecifier":105,"./formatTypes":106,"./identity":107}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _exponent = _interopRequireDefault(require("./exponent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(step) {
  return Math.max(0, -(0, _exponent.default)(Math.abs(step)));
}

},{"./exponent":98}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _exponent = _interopRequireDefault(require("./exponent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0, _exponent.default)(value) / 3))) * 3 - (0, _exponent.default)(Math.abs(step)));
}

},{"./exponent":98}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _exponent = _interopRequireDefault(require("./exponent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0, _exponent.default)(max) - (0, _exponent.default)(step)) + 1;
}

},{"./exponent":98}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "geoAlbers", {
  enumerable: true,
  get: function () {
    return _albers.default;
  }
});
Object.defineProperty(exports, "geoAlbersUsa", {
  enumerable: true,
  get: function () {
    return _albersUsa.default;
  }
});
Object.defineProperty(exports, "geoArea", {
  enumerable: true,
  get: function () {
    return _area.default;
  }
});
Object.defineProperty(exports, "geoAzimuthalEqualArea", {
  enumerable: true,
  get: function () {
    return _azimuthalEqualArea.default;
  }
});
Object.defineProperty(exports, "geoAzimuthalEqualAreaRaw", {
  enumerable: true,
  get: function () {
    return _azimuthalEqualArea.azimuthalEqualAreaRaw;
  }
});
Object.defineProperty(exports, "geoAzimuthalEquidistant", {
  enumerable: true,
  get: function () {
    return _azimuthalEquidistant.default;
  }
});
Object.defineProperty(exports, "geoAzimuthalEquidistantRaw", {
  enumerable: true,
  get: function () {
    return _azimuthalEquidistant.azimuthalEquidistantRaw;
  }
});
Object.defineProperty(exports, "geoBounds", {
  enumerable: true,
  get: function () {
    return _bounds.default;
  }
});
Object.defineProperty(exports, "geoCentroid", {
  enumerable: true,
  get: function () {
    return _centroid.default;
  }
});
Object.defineProperty(exports, "geoCircle", {
  enumerable: true,
  get: function () {
    return _circle.default;
  }
});
Object.defineProperty(exports, "geoClipAntimeridian", {
  enumerable: true,
  get: function () {
    return _antimeridian.default;
  }
});
Object.defineProperty(exports, "geoClipCircle", {
  enumerable: true,
  get: function () {
    return _circle2.default;
  }
});
Object.defineProperty(exports, "geoClipExtent", {
  enumerable: true,
  get: function () {
    return _extent.default;
  }
});
Object.defineProperty(exports, "geoClipRectangle", {
  enumerable: true,
  get: function () {
    return _rectangle.default;
  }
});
Object.defineProperty(exports, "geoConicConformal", {
  enumerable: true,
  get: function () {
    return _conicConformal.default;
  }
});
Object.defineProperty(exports, "geoConicConformalRaw", {
  enumerable: true,
  get: function () {
    return _conicConformal.conicConformalRaw;
  }
});
Object.defineProperty(exports, "geoConicEqualArea", {
  enumerable: true,
  get: function () {
    return _conicEqualArea.default;
  }
});
Object.defineProperty(exports, "geoConicEqualAreaRaw", {
  enumerable: true,
  get: function () {
    return _conicEqualArea.conicEqualAreaRaw;
  }
});
Object.defineProperty(exports, "geoConicEquidistant", {
  enumerable: true,
  get: function () {
    return _conicEquidistant.default;
  }
});
Object.defineProperty(exports, "geoConicEquidistantRaw", {
  enumerable: true,
  get: function () {
    return _conicEquidistant.conicEquidistantRaw;
  }
});
Object.defineProperty(exports, "geoContains", {
  enumerable: true,
  get: function () {
    return _contains.default;
  }
});
Object.defineProperty(exports, "geoDistance", {
  enumerable: true,
  get: function () {
    return _distance.default;
  }
});
Object.defineProperty(exports, "geoEquirectangular", {
  enumerable: true,
  get: function () {
    return _equirectangular.default;
  }
});
Object.defineProperty(exports, "geoEquirectangularRaw", {
  enumerable: true,
  get: function () {
    return _equirectangular.equirectangularRaw;
  }
});
Object.defineProperty(exports, "geoGnomonic", {
  enumerable: true,
  get: function () {
    return _gnomonic.default;
  }
});
Object.defineProperty(exports, "geoGnomonicRaw", {
  enumerable: true,
  get: function () {
    return _gnomonic.gnomonicRaw;
  }
});
Object.defineProperty(exports, "geoGraticule", {
  enumerable: true,
  get: function () {
    return _graticule.default;
  }
});
Object.defineProperty(exports, "geoGraticule10", {
  enumerable: true,
  get: function () {
    return _graticule.graticule10;
  }
});
Object.defineProperty(exports, "geoIdentity", {
  enumerable: true,
  get: function () {
    return _identity.default;
  }
});
Object.defineProperty(exports, "geoInterpolate", {
  enumerable: true,
  get: function () {
    return _interpolate.default;
  }
});
Object.defineProperty(exports, "geoLength", {
  enumerable: true,
  get: function () {
    return _length.default;
  }
});
Object.defineProperty(exports, "geoMercator", {
  enumerable: true,
  get: function () {
    return _mercator.default;
  }
});
Object.defineProperty(exports, "geoMercatorRaw", {
  enumerable: true,
  get: function () {
    return _mercator.mercatorRaw;
  }
});
Object.defineProperty(exports, "geoNaturalEarth1", {
  enumerable: true,
  get: function () {
    return _naturalEarth.default;
  }
});
Object.defineProperty(exports, "geoNaturalEarth1Raw", {
  enumerable: true,
  get: function () {
    return _naturalEarth.naturalEarth1Raw;
  }
});
Object.defineProperty(exports, "geoOrthographic", {
  enumerable: true,
  get: function () {
    return _orthographic.default;
  }
});
Object.defineProperty(exports, "geoOrthographicRaw", {
  enumerable: true,
  get: function () {
    return _orthographic.orthographicRaw;
  }
});
Object.defineProperty(exports, "geoPath", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
Object.defineProperty(exports, "geoProjection", {
  enumerable: true,
  get: function () {
    return _index2.default;
  }
});
Object.defineProperty(exports, "geoProjectionMutator", {
  enumerable: true,
  get: function () {
    return _index2.projectionMutator;
  }
});
Object.defineProperty(exports, "geoRotation", {
  enumerable: true,
  get: function () {
    return _rotation.default;
  }
});
Object.defineProperty(exports, "geoStereographic", {
  enumerable: true,
  get: function () {
    return _stereographic.default;
  }
});
Object.defineProperty(exports, "geoStereographicRaw", {
  enumerable: true,
  get: function () {
    return _stereographic.stereographicRaw;
  }
});
Object.defineProperty(exports, "geoStream", {
  enumerable: true,
  get: function () {
    return _stream.default;
  }
});
Object.defineProperty(exports, "geoTransform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});
Object.defineProperty(exports, "geoTransverseMercator", {
  enumerable: true,
  get: function () {
    return _transverseMercator.default;
  }
});
Object.defineProperty(exports, "geoTransverseMercatorRaw", {
  enumerable: true,
  get: function () {
    return _transverseMercator.transverseMercatorRaw;
  }
});

var _area = _interopRequireDefault(require("./src/area"));

var _bounds = _interopRequireDefault(require("./src/bounds"));

var _centroid = _interopRequireDefault(require("./src/centroid"));

var _circle = _interopRequireDefault(require("./src/circle"));

var _antimeridian = _interopRequireDefault(require("./src/clip/antimeridian"));

var _circle2 = _interopRequireDefault(require("./src/clip/circle"));

var _extent = _interopRequireDefault(require("./src/clip/extent"));

var _rectangle = _interopRequireDefault(require("./src/clip/rectangle"));

var _contains = _interopRequireDefault(require("./src/contains"));

var _distance = _interopRequireDefault(require("./src/distance"));

var _graticule = _interopRequireWildcard(require("./src/graticule"));

var _interpolate = _interopRequireDefault(require("./src/interpolate"));

var _length = _interopRequireDefault(require("./src/length"));

var _index = _interopRequireDefault(require("./src/path/index"));

var _albers = _interopRequireDefault(require("./src/projection/albers"));

var _albersUsa = _interopRequireDefault(require("./src/projection/albersUsa"));

var _azimuthalEqualArea = _interopRequireWildcard(require("./src/projection/azimuthalEqualArea"));

var _azimuthalEquidistant = _interopRequireWildcard(require("./src/projection/azimuthalEquidistant"));

var _conicConformal = _interopRequireWildcard(require("./src/projection/conicConformal"));

var _conicEqualArea = _interopRequireWildcard(require("./src/projection/conicEqualArea"));

var _conicEquidistant = _interopRequireWildcard(require("./src/projection/conicEquidistant"));

var _equirectangular = _interopRequireWildcard(require("./src/projection/equirectangular"));

var _gnomonic = _interopRequireWildcard(require("./src/projection/gnomonic"));

var _identity = _interopRequireDefault(require("./src/projection/identity"));

var _index2 = _interopRequireWildcard(require("./src/projection/index"));

var _mercator = _interopRequireWildcard(require("./src/projection/mercator"));

var _naturalEarth = _interopRequireWildcard(require("./src/projection/naturalEarth1"));

var _orthographic = _interopRequireWildcard(require("./src/projection/orthographic"));

var _stereographic = _interopRequireWildcard(require("./src/projection/stereographic"));

var _transverseMercator = _interopRequireWildcard(require("./src/projection/transverseMercator"));

var _rotation = _interopRequireDefault(require("./src/rotation"));

var _stream = _interopRequireDefault(require("./src/stream"));

var _transform = _interopRequireDefault(require("./src/transform"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/area":114,"./src/bounds":115,"./src/centroid":117,"./src/circle":118,"./src/clip/antimeridian":119,"./src/clip/circle":121,"./src/clip/extent":122,"./src/clip/rectangle":125,"./src/contains":129,"./src/distance":130,"./src/graticule":131,"./src/interpolate":133,"./src/length":134,"./src/path/index":141,"./src/projection/albers":146,"./src/projection/albersUsa":147,"./src/projection/azimuthalEqualArea":149,"./src/projection/azimuthalEquidistant":150,"./src/projection/conicConformal":152,"./src/projection/conicEqualArea":153,"./src/projection/conicEquidistant":154,"./src/projection/equirectangular":156,"./src/projection/gnomonic":158,"./src/projection/identity":159,"./src/projection/index":160,"./src/projection/mercator":161,"./src/projection/naturalEarth1":162,"./src/projection/orthographic":163,"./src/projection/stereographic":165,"./src/projection/transverseMercator":166,"./src/rotation":167,"./src/stream":168,"./src/transform":169}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/
function _default() {
  return new Adder();
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function () {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function (y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;else this.s = temp.t;
  },
  valueOf: function () {
    return this.s;
  }
};
var temp = new Adder();

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = a - av + (b - bv);
}

},{}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areaStream = exports.areaRingSum = void 0;
exports.default = _default;

var _adder = _interopRequireDefault(require("./adder"));

var _math = require("./math");

var _noop = _interopRequireDefault(require("./noop"));

var _stream = _interopRequireDefault(require("./stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var areaRingSum = (0, _adder.default)();
exports.areaRingSum = areaRingSum;
var areaSum = (0, _adder.default)(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;
var areaStream = {
  point: _noop.default,
  lineStart: _noop.default,
  lineEnd: _noop.default,
  polygonStart: function () {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function () {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math.tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop.default;
  },
  sphere: function () {
    areaSum.add(_math.tau);
  }
};
exports.areaStream = areaStream;

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math.radians, phi *= _math.radians;
  lambda0 = lambda, cosPhi0 = (0, _math.cos)(phi = phi / 2 + _math.quarterPi), sinPhi0 = (0, _math.sin)(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  phi = phi / 2 + _math.quarterPi; // half the angular distance from south pole
  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).

  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = (0, _math.cos)(phi),
      sinPhi = (0, _math.sin)(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * (0, _math.cos)(adLambda),
      v = k * sdLambda * (0, _math.sin)(adLambda);
  areaRingSum.add((0, _math.atan2)(v, u)); // Advance the previous points.

  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

function _default(object) {
  areaSum.reset();
  (0, _stream.default)(object, areaStream);
  return areaSum * 2;
}

},{"./adder":113,"./math":135,"./noop":136,"./stream":168}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _adder = _interopRequireDefault(require("./adder"));

var _area = require("./area");

var _cartesian = require("./cartesian");

var _math = require("./math");

var _stream = _interopRequireDefault(require("./stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lambda0,
    phi0,
    lambda1,
    phi1,
    // bounds
lambda2,
    // previous lambda-coordinate
lambda00,
    phi00,
    // first point
p0,
    // previous 3D point
deltaSum = (0, _adder.default)(),
    ranges,
    range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function () {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();

    _area.areaStream.polygonStart();
  },
  polygonEnd: function () {
    _area.areaStream.polygonEnd();

    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > _math.epsilon) phi1 = 90;else if (deltaSum < -_math.epsilon) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = (0, _cartesian.cartesian)([lambda * _math.radians, phi * _math.radians]);

  if (p0) {
    var normal = (0, _cartesian.cartesianCross)(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = (0, _cartesian.cartesianCross)(equatorial, normal);
    (0, _cartesian.cartesianNormalizeInPlace)(inflection);
    inflection = (0, _cartesian.spherical)(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math.degrees * sign,
        phii,
        antimeridian = (0, _math.abs)(delta) > 180;

    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math.degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math.degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }

  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add((0, _math.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }

  _area.areaStream.point(lambda, phi);

  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area.areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);

  _area.areaStream.lineEnd();

  if ((0, _math.abs)(deltaSum) > _math.epsilon) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
} // Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.


function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

function _default(feature) {
  var i, n, a, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  (0, _stream.default)(feature, boundsStream); // First, sort ranges by their minimum longitudes.

  if (n = ranges.length) {
    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.

    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];

      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    } // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.


    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;
  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
}

},{"./adder":113,"./area":114,"./cartesian":116,"./math":135,"./stream":168}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cartesian = cartesian;
exports.cartesianAddInPlace = cartesianAddInPlace;
exports.cartesianCross = cartesianCross;
exports.cartesianDot = cartesianDot;
exports.cartesianNormalizeInPlace = cartesianNormalizeInPlace;
exports.cartesianScale = cartesianScale;
exports.spherical = spherical;

var _math = require("./math");

function spherical(cartesian) {
  return [(0, _math.atan2)(cartesian[1], cartesian[0]), (0, _math.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0],
      phi = spherical[1],
      cosPhi = (0, _math.cos)(phi);
  return [cosPhi * (0, _math.cos)(lambda), cosPhi * (0, _math.sin)(lambda), (0, _math.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // TODO return a


function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
} // TODO return d


function cartesianNormalizeInPlace(d) {
  var l = (0, _math.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

},{"./math":135}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _math = require("./math");

var _noop = _interopRequireDefault(require("./noop"));

var _stream = _interopRequireDefault(require("./stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point
x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop.default,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function () {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function () {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
}; // Arithmetic mean of Cartesian vectors.

function centroidPoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var cosPhi = (0, _math.cos)(phi);
  centroidPointCartesian(cosPhi * (0, _math.cos)(lambda), cosPhi * (0, _math.sin)(lambda), (0, _math.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var cosPhi = (0, _math.cos)(phi);
  x0 = cosPhi * (0, _math.cos)(lambda);
  y0 = cosPhi * (0, _math.sin)(lambda);
  z0 = (0, _math.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var cosPhi = (0, _math.cos)(phi),
      x = cosPhi * (0, _math.cos)(lambda),
      y = cosPhi * (0, _math.sin)(lambda),
      z = (0, _math.sin)(phi),
      w = (0, _math.atan2)((0, _math.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
} // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).


function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math.radians, phi *= _math.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0, _math.cos)(phi);
  x0 = cosPhi * (0, _math.cos)(lambda);
  y0 = cosPhi * (0, _math.sin)(lambda);
  z0 = (0, _math.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var cosPhi = (0, _math.cos)(phi),
      x = cosPhi * (0, _math.cos)(lambda),
      y = cosPhi * (0, _math.sin)(lambda),
      z = (0, _math.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0, _math.sqrt)(cx * cx + cy * cy + cz * cz),
      w = (0, _math.asin)(m),
      // line weight = angle
  v = m && -w / m; // area weight multiplier

  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function _default(object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
  (0, _stream.default)(object, centroidStream);
  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z; // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.

  if (m < _math.epsilon2) {
    x = X1, y = Y1, z = Z1; // If the feature has zero length, fall back to arithmetic mean of point vectors.

    if (W1 < _math.epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z; // If the feature still has an undefined ccentroid, then return.

    if (m < _math.epsilon2) return [NaN, NaN];
  }

  return [(0, _math.atan2)(y, x) * _math.degrees, (0, _math.asin)(z / (0, _math.sqrt)(m)) * _math.degrees];
}

},{"./math":135,"./noop":136,"./stream":168}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleStream = circleStream;
exports.default = _default;

var _cartesian = require("./cartesian");

var _constant = _interopRequireDefault(require("./constant"));

var _math = require("./math");

var _rotation = require("./rotation");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0, _math.cos)(radius),
      sinRadius = (0, _math.sin)(radius),
      step = direction * delta;

  if (t0 == null) {
    t0 = radius + direction * _math.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math.tau;
  }

  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0, _cartesian.spherical)([cosRadius, -sinRadius * (0, _math.cos)(t), -sinRadius * (0, _math.sin)(t)]);
    stream.point(point[0], point[1]);
  }
} // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].


function circleRadius(cosRadius, point) {
  point = (0, _cartesian.cartesian)(point), point[0] -= cosRadius;
  (0, _cartesian.cartesianNormalizeInPlace)(point);
  var radius = (0, _math.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math.tau - _math.epsilon) % _math.tau;
}

function _default() {
  var center = (0, _constant.default)([0, 0]),
      radius = (0, _constant.default)(90),
      precision = (0, _constant.default)(6),
      ring,
      rotate,
      stream = {
    point: point
  };

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math.degrees, x[1] *= _math.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math.radians,
        p = precision.apply(this, arguments) * _math.radians;

    ring = [];
    rotate = (0, _rotation.rotateRadians)(-c[0] * _math.radians, -c[1] * _math.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {
      type: "Polygon",
      coordinates: [ring]
    };
    ring = rotate = null;
    return c;
  }

  circle.center = function (_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0, _constant.default)([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0, _constant.default)(+_), circle) : radius;
  };

  circle.precision = function (_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0, _constant.default)(+_), circle) : precision;
  };

  return circle;
}

},{"./cartesian":116,"./constant":128,"./math":135,"./rotation":167}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = _interopRequireDefault(require("./index"));

var _math = require("../math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _index.default)(function () {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-_math.pi, -_math.halfPi]); // Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.


exports.default = _default;

function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function () {
      stream.lineStart();
      clean = 1;
    },
    point: function (lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math.pi : -_math.pi,
          delta = (0, _math.abs)(lambda1 - lambda0);

      if ((0, _math.abs)(delta - _math.pi) < _math.epsilon) {
        // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math.halfPi : -_math.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math.pi) {
        // line crosses antimeridian
        if ((0, _math.abs)(lambda0 - sign0) < _math.epsilon) lambda0 -= sign0 * _math.epsilon; // handle degeneracies

        if ((0, _math.abs)(lambda1 - sign1) < _math.epsilon) lambda1 -= sign1 * _math.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }

      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function () {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function () {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0, _math.sin)(lambda0 - lambda1);
  return (0, _math.abs)(sinLambda0Lambda1) > _math.epsilon ? (0, _math.atan)(((0, _math.sin)(phi0) * (cosPhi1 = (0, _math.cos)(phi1)) * (0, _math.sin)(lambda1) - (0, _math.sin)(phi1) * (cosPhi0 = (0, _math.cos)(phi0)) * (0, _math.sin)(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;

  if (from == null) {
    phi = direction * _math.halfPi;
    stream.point(-_math.pi, phi);
    stream.point(0, phi);
    stream.point(_math.pi, phi);
    stream.point(_math.pi, 0);
    stream.point(_math.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math.pi, -phi);
    stream.point(-_math.pi, 0);
    stream.point(-_math.pi, phi);
  } else if ((0, _math.abs)(from[0] - to[0]) > _math.epsilon) {
    var lambda = from[0] < to[0] ? _math.pi : -_math.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

},{"../math":135,"./index":123}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var lines = [],
      line;
  return {
    point: function (x, y) {
      line.push([x, y]);
    },
    lineStart: function () {
      lines.push(line = []);
    },
    lineEnd: _noop.default,
    rejoin: function () {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function () {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

},{"../noop":136}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _cartesian = require("../cartesian");

var _circle = require("../circle");

var _math = require("../math");

var _pointEqual = _interopRequireDefault(require("../pointEqual"));

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(radius) {
  var cr = (0, _math.cos)(radius),
      delta = 6 * _math.radians,
      smallRadius = cr > 0,
      notHemisphere = (0, _math.abs)(cr) > _math.epsilon; // TODO optimise for this common case


  function interpolate(from, to, direction, stream) {
    (0, _circle.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0, _math.cos)(lambda) * (0, _math.cos)(phi) > cr;
  } // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.


  function clipLine(stream) {
    var point0, // previous point
    c0, // code for previous point
    v0, // visibility of previous point
    v00, // visibility of first point
    clean; // no intersections

    return {
      lineStart: function () {
        v00 = v0 = false;
        clean = 1;
      },
      point: function (lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math.pi : -_math.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart(); // Handle degeneracies.
        // TODO ignore if not clipping polygons.

        if (v !== v0) {
          point2 = intersect(point0, point1);

          if (!point2 || (0, _pointEqual.default)(point0, point2) || (0, _pointEqual.default)(point1, point2)) {
            point1[0] += _math.epsilon;
            point1[1] += _math.epsilon;
            v = visible(point1[0], point1[1]);
          }
        }

        if (v !== v0) {
          clean = 0;

          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }

          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t; // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.

          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;

            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }

        if (v && (!point0 || !(0, _pointEqual.default)(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }

        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function () {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function () {
        return clean | (v00 && v0) << 1;
      }
    };
  } // Intersects the great circle between a and b with the clip circle.


  function intersect(a, b, two) {
    var pa = (0, _cartesian.cartesian)(a),
        pb = (0, _cartesian.cartesian)(b); // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).

    var n1 = [1, 0, 0],
        // normal
    n2 = (0, _cartesian.cartesianCross)(pa, pb),
        n2n2 = (0, _cartesian.cartesianDot)(n2, n2),
        n1n2 = n2[0],
        // cartesianDot(n1, n2),
    determinant = n2n2 - n1n2 * n1n2; // Two polar points.

    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0, _cartesian.cartesianCross)(n1, n2),
        A = (0, _cartesian.cartesianScale)(n1, c1),
        B = (0, _cartesian.cartesianScale)(n2, c2);
    (0, _cartesian.cartesianAddInPlace)(A, B); // Solve |p(t)|^2 = 1.

    var u = n1xn2,
        w = (0, _cartesian.cartesianDot)(A, u),
        uu = (0, _cartesian.cartesianDot)(u, u),
        t2 = w * w - uu * ((0, _cartesian.cartesianDot)(A, A) - 1);
    if (t2 < 0) return;
    var t = (0, _math.sqrt)(t2),
        q = (0, _cartesian.cartesianScale)(u, (-w - t) / uu);
    (0, _cartesian.cartesianAddInPlace)(q, A);
    q = (0, _cartesian.spherical)(q);
    if (!two) return q; // Two intersection points.

    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0, _math.abs)(delta - _math.pi) < _math.epsilon,
        meridian = polar || delta < _math.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.

    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < ((0, _math.abs)(q[0] - lambda0) < _math.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0, _cartesian.cartesianScale)(u, (-w + t) / uu);
      (0, _cartesian.cartesianAddInPlace)(q1, A);
      return [q, (0, _cartesian.spherical)(q1)];
    }
  } // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.


  function code(lambda, phi) {
    var r = smallRadius ? radius : _math.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right

    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above

    return code;
  }

  return (0, _index.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math.pi, radius - _math.pi]);
}

},{"../cartesian":116,"../circle":118,"../math":135,"../pointEqual":144,"./index":123}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _rectangle = _interopRequireDefault(require("./rectangle"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;
  return clip = {
    stream: function (stream) {
      return cache && cacheStream === stream ? cache : cache = (0, _rectangle.default)(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function (_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

},{"./rectangle":125}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _buffer = _interopRequireDefault(require("./buffer"));

var _rejoin = _interopRequireDefault(require("./rejoin"));

var _math = require("../math");

var _polygonContains = _interopRequireDefault(require("../polygonContains"));

var _d3Array = require("d3-array");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(pointVisible, clipLine, interpolate, start) {
  return function (sink) {
    var line = clipLine(sink),
        ringBuffer = (0, _buffer.default)(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;
    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function () {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function () {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0, _d3Array.merge)(segments);
        var startInside = (0, _polygonContains.default)(polygon, start);

        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0, _rejoin.default)(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }

        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function () {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i,
          n = ringSegments.length,
          m,
          segment,
          point;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return; // No intersections.

      if (clean & 1) {
        segment = ringSegments[0];

        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();

          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);

          sink.lineEnd();
        }

        return;
      } // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?


      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
} // Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.


function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math.halfPi - _math.epsilon : _math.halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math.halfPi - _math.epsilon : _math.halfPi - b[1]);
}

},{"../math":135,"../polygonContains":145,"./buffer":120,"./rejoin":126,"d3-array":1}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

},{}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clipRectangle;

var _math = require("../math");

var _buffer = _interopRequireDefault(require("./buffer"));

var _line = _interopRequireDefault(require("./line"));

var _rejoin = _interopRequireDefault(require("./rejoin"));

var _d3Array = require("d3-array");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clipMax = 1e9,
    clipMin = -clipMax; // TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {
  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0,
        a1 = 0;

    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0); while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0, _math.abs)(p[0] - x0) < _math.epsilon ? direction > 0 ? 0 : 3 : (0, _math.abs)(p[0] - x1) < _math.epsilon ? direction > 0 ? 2 : 1 : (0, _math.abs)(p[1] - y0) < _math.epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }

  return function (stream) {
    var activeStream = stream,
        bufferStream = (0, _buffer.default)(),
        segments,
        polygon,
        ring,
        x__,
        y__,
        v__,
        // first point
    x_,
        y_,
        v_,
        // previous point
    first,
        clean;
    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];

          if (a1 <= y1) {
            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
          } else {
            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
          }
        }
      }

      return winding;
    } // Buffer geometry within a polygon and then clip it en masse.


    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0, _d3Array.merge)(segments)).length;

      if (cleanInside || visible) {
        stream.polygonStart();

        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }

        if (visible) {
          (0, _rejoin.default)(segments, compareIntersection, startInside, interpolate, stream);
        }

        stream.polygonEnd();
      }

      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    } // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.


    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }

      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);

      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;

        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];

          if ((0, _line.default)(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }

            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }

      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

},{"../math":135,"./buffer":120,"./line":124,"./rejoin":126,"d3-array":1}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _pointEqual = _interopRequireDefault(require("../pointEqual"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection

  this.e = entry; // is an entry?

  this.v = false; // visited

  this.n = this.p = null; // next & previous
} // A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.


function _default(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;
  segments.forEach(function (segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n,
        p0 = segment[0],
        p1 = segment[n],
        x; // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.

    if ((0, _pointEqual.default)(p0, p1)) {
      stream.lineStart();

      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);

      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;

    while (current.v) if ((current = current.n) === start) return;

    points = current.z;
    stream.lineStart();

    do {
      current.v = current.o.v = true;

      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }

        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;

          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }

        current = current.p;
      }

      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);

    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;

  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }

  a.n = b = array[0];
  b.p = a;
}

},{"../pointEqual":144}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function (x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose;
}

},{}],128:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _polygonContains = _interopRequireDefault(require("./polygonContains"));

var _distance = _interopRequireDefault(require("./distance"));

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var containsObjectType = {
  Feature: function (object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function (object, point) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;

    return false;
  }
};
var containsGeometryType = {
  Sphere: function () {
    return true;
  },
  Point: function (object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsPoint(coordinates[i], point)) return true;

    return false;
  },
  LineString: function (object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsLine(coordinates[i], point)) return true;

    return false;
  },
  Polygon: function (object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;

    return false;
  },
  GeometryCollection: function (object, point) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) if (containsGeometry(geometries[i], point)) return true;

    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
}

function containsPoint(coordinates, point) {
  return (0, _distance.default)(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = (0, _distance.default)(coordinates[0], coordinates[1]),
      ao = (0, _distance.default)(coordinates[0], point),
      ob = (0, _distance.default)(point, coordinates[1]);
  return ao + ob <= ab + _math.epsilon;
}

function containsPolygon(coordinates, point) {
  return !!(0, _polygonContains.default)(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * _math.radians, point[1] * _math.radians];
}

function _default(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
}

},{"./distance":130,"./math":135,"./polygonContains":145}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _length = _interopRequireDefault(require("./length"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var coordinates = [null, null],
    object = {
  type: "LineString",
  coordinates: coordinates
};

function _default(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return (0, _length.default)(object);
}

},{"./length":134}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = graticule;
exports.graticule10 = graticule10;

var _d3Array = require("d3-array");

var _math = require("./math");

function graticuleX(y0, y1, dy) {
  var y = (0, _d3Array.range)(y0, y1 - _math.epsilon, dy).concat(y1);
  return function (x) {
    return y.map(function (y) {
      return [x, y];
    });
  };
}

function graticuleY(x0, x1, dx) {
  var x = (0, _d3Array.range)(x0, x1 - _math.epsilon, dx).concat(x1);
  return function (y) {
    return x.map(function (x) {
      return [x, y];
    });
  };
}

function graticule() {
  var x1,
      x0,
      X1,
      X0,
      y1,
      y0,
      Y1,
      Y0,
      dx = 10,
      dy = dx,
      DX = 90,
      DY = 360,
      x,
      y,
      X,
      Y,
      precision = 2.5;

  function graticule() {
    return {
      type: "MultiLineString",
      coordinates: lines()
    };
  }

  function lines() {
    return (0, _d3Array.range)((0, _math.ceil)(X0 / DX) * DX, X1, DX).map(X).concat((0, _d3Array.range)((0, _math.ceil)(Y0 / DY) * DY, Y1, DY).map(Y)).concat((0, _d3Array.range)((0, _math.ceil)(x0 / dx) * dx, x1, dx).filter(function (x) {
      return (0, _math.abs)(x % DX) > _math.epsilon;
    }).map(x)).concat((0, _d3Array.range)((0, _math.ceil)(y0 / dy) * dy, y1, dy).filter(function (y) {
      return (0, _math.abs)(y % DY) > _math.epsilon;
    }).map(y));
  }

  graticule.lines = function () {
    return lines().map(function (coordinates) {
      return {
        type: "LineString",
        coordinates: coordinates
      };
    });
  };

  graticule.outline = function () {
    return {
      type: "Polygon",
      coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
    };
  };

  graticule.extent = function (_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function (_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function (_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function (_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function (_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function (_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function (_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule.extentMajor([[-180, -90 + _math.epsilon], [180, 90 - _math.epsilon]]).extentMinor([[-180, -80 - _math.epsilon], [180, 80 + _math.epsilon]]);
}

function graticule10() {
  return graticule()();
}

},{"./math":135,"d3-array":1}],132:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _math = require("./math");

function _default(a, b) {
  var x0 = a[0] * _math.radians,
      y0 = a[1] * _math.radians,
      x1 = b[0] * _math.radians,
      y1 = b[1] * _math.radians,
      cy0 = (0, _math.cos)(y0),
      sy0 = (0, _math.sin)(y0),
      cy1 = (0, _math.cos)(y1),
      sy1 = (0, _math.sin)(y1),
      kx0 = cy0 * (0, _math.cos)(x0),
      ky0 = cy0 * (0, _math.sin)(x0),
      kx1 = cy1 * (0, _math.cos)(x1),
      ky1 = cy1 * (0, _math.sin)(x1),
      d = 2 * (0, _math.asin)((0, _math.sqrt)((0, _math.haversin)(y1 - y0) + cy0 * cy1 * (0, _math.haversin)(x1 - x0))),
      k = (0, _math.sin)(d);
  var interpolate = d ? function (t) {
    var B = (0, _math.sin)(t *= d) / k,
        A = (0, _math.sin)(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [(0, _math.atan2)(y, x) * _math.degrees, (0, _math.atan2)(z, (0, _math.sqrt)(x * x + y * y)) * _math.degrees];
  } : function () {
    return [x0 * _math.degrees, y0 * _math.degrees];
  };
  interpolate.distance = d;
  return interpolate;
}

},{"./math":135}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _adder = _interopRequireDefault(require("./adder"));

var _math = require("./math");

var _noop = _interopRequireDefault(require("./noop"));

var _stream = _interopRequireDefault(require("./stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lengthSum = (0, _adder.default)(),
    lambda0,
    sinPhi0,
    cosPhi0;
var lengthStream = {
  sphere: _noop.default,
  point: _noop.default,
  lineStart: lengthLineStart,
  lineEnd: _noop.default,
  polygonStart: _noop.default,
  polygonEnd: _noop.default
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = _noop.default;
}

function lengthPointFirst(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  lambda0 = lambda, sinPhi0 = (0, _math.sin)(phi), cosPhi0 = (0, _math.cos)(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var sinPhi = (0, _math.sin)(phi),
      cosPhi = (0, _math.cos)(phi),
      delta = (0, _math.abs)(lambda - lambda0),
      cosDelta = (0, _math.cos)(delta),
      sinDelta = (0, _math.sin)(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add((0, _math.atan2)((0, _math.sqrt)(x * x + y * y), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}

function _default(object) {
  lengthSum.reset();
  (0, _stream.default)(object, lengthStream);
  return +lengthSum;
}

},{"./adder":113,"./math":135,"./noop":136,"./stream":168}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abs = void 0;
exports.acos = acos;
exports.asin = asin;
exports.halfPi = exports.floor = exports.exp = exports.epsilon2 = exports.epsilon = exports.degrees = exports.cos = exports.ceil = exports.atan2 = exports.atan = void 0;
exports.haversin = haversin;
exports.tau = exports.tan = exports.sqrt = exports.sin = exports.sign = exports.radians = exports.quarterPi = exports.pow = exports.pi = exports.log = void 0;
var epsilon = 1e-6;
exports.epsilon = epsilon;
var epsilon2 = 1e-12;
exports.epsilon2 = epsilon2;
var pi = Math.PI;
exports.pi = pi;
var halfPi = pi / 2;
exports.halfPi = halfPi;
var quarterPi = pi / 4;
exports.quarterPi = quarterPi;
var tau = pi * 2;
exports.tau = tau;
var degrees = 180 / pi;
exports.degrees = degrees;
var radians = pi / 180;
exports.radians = radians;
var abs = Math.abs;
exports.abs = abs;
var atan = Math.atan;
exports.atan = atan;
var atan2 = Math.atan2;
exports.atan2 = atan2;
var cos = Math.cos;
exports.cos = cos;
var ceil = Math.ceil;
exports.ceil = ceil;
var exp = Math.exp;
exports.exp = exp;
var floor = Math.floor;
exports.floor = floor;
var log = Math.log;
exports.log = log;
var pow = Math.pow;
exports.pow = pow;
var sin = Math.sin;
exports.sin = sin;

var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};

exports.sign = sign;
var sqrt = Math.sqrt;
exports.sqrt = sqrt;
var tan = Math.tan;
exports.tan = tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}

},{}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = noop;

function noop() {}

},{}],137:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _adder = _interopRequireDefault(require("../adder"));

var _math = require("../math");

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var areaSum = (0, _adder.default)(),
    areaRingSum = (0, _adder.default)(),
    x00,
    y00,
    x0,
    y0;
var areaStream = {
  point: _noop.default,
  lineStart: _noop.default,
  lineEnd: _noop.default,
  polygonStart: function () {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function () {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop.default;
    areaSum.add((0, _math.abs)(areaRingSum));
    areaRingSum.reset();
  },
  result: function () {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

var _default = areaStream;
exports.default = _default;

},{"../adder":113,"../math":135,"../noop":136}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: _noop.default,
  lineEnd: _noop.default,
  polygonStart: _noop.default,
  polygonEnd: _noop.default,
  result: function () {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

var _default = boundsStream;
exports.default = _default;

},{"../noop":136}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("../math");

// TODO Enforce positive area for exterior, negative area for interior?
var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function () {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function () {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function () {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0, _math.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0, _math.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

var _default = centroidStream;
exports.default = _default;

},{"../math":135}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PathContext;

var _math = require("../math");

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function (_) {
    return this._radius = _, this;
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function (x, y) {
    switch (this._point) {
      case 0:
        {
          this._context.moveTo(x, y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._context.lineTo(x, y);

          break;
        }

      default:
        {
          this._context.moveTo(x + this._radius, y);

          this._context.arc(x, y, this._radius, 0, _math.tau);

          break;
        }
    }
  },
  result: _noop.default
};

},{"../math":135,"../noop":136}],141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _identity = _interopRequireDefault(require("../identity"));

var _stream = _interopRequireDefault(require("../stream"));

var _area = _interopRequireDefault(require("./area"));

var _bounds = _interopRequireDefault(require("./bounds"));

var _centroid = _interopRequireDefault(require("./centroid"));

var _context = _interopRequireDefault(require("./context"));

var _measure = _interopRequireDefault(require("./measure"));

var _string = _interopRequireDefault(require("./string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0, _stream.default)(object, projectionStream(contextStream));
    }

    return contextStream.result();
  }

  path.area = function (object) {
    (0, _stream.default)(object, projectionStream(_area.default));
    return _area.default.result();
  };

  path.measure = function (object) {
    (0, _stream.default)(object, projectionStream(_measure.default));
    return _measure.default.result();
  };

  path.bounds = function (object) {
    (0, _stream.default)(object, projectionStream(_bounds.default));
    return _bounds.default.result();
  };

  path.centroid = function (object) {
    (0, _stream.default)(object, projectionStream(_centroid.default));
    return _centroid.default.result();
  };

  path.projection = function (_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity.default) : (projection = _).stream, path) : projection;
  };

  path.context = function (_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string.default()) : new _context.default(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function (_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

},{"../identity":132,"../stream":168,"./area":137,"./bounds":138,"./centroid":139,"./context":140,"./measure":142,"./string":143}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _adder = _interopRequireDefault(require("../adder"));

var _math = require("../math");

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lengthSum = (0, _adder.default)(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;
var lengthStream = {
  point: _noop.default,
  lineStart: function () {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function () {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop.default;
  },
  polygonStart: function () {
    lengthRing = true;
  },
  polygonEnd: function () {
    lengthRing = null;
  },
  result: function () {
    var length = +lengthSum;
    lengthSum.reset();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0, _math.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

var _default = lengthStream;
exports.default = _default;

},{"../adder":113,"../math":135,"../noop":136}],143:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PathString;

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function (_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function (x, y) {
    switch (this._point) {
      case 0:
        {
          this._string.push("M", x, ",", y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._string.push("L", x, ",", y);

          break;
        }

      default:
        {
          if (this._circle == null) this._circle = circle(this._radius);

          this._string.push("M", x, ",", y, this._circle);

          break;
        }
    }
  },
  result: function () {
    if (this._string.length) {
      var result = this._string.join("");

      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

},{}],144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _math = require("./math");

function _default(a, b) {
  return (0, _math.abs)(a[0] - b[0]) < _math.epsilon && (0, _math.abs)(a[1] - b[1]) < _math.epsilon;
}

},{"./math":135}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _adder = _interopRequireDefault(require("./adder"));

var _cartesian = require("./cartesian");

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sum = (0, _adder.default)();

function _default(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [(0, _math.sin)(lambda), -(0, _math.cos)(lambda), 0],
      angle = 0,
      winding = 0;
  sum.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + _math.quarterPi,
        sinPhi0 = (0, _math.sin)(phi0),
        cosPhi0 = (0, _math.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + _math.quarterPi,
          sinPhi1 = (0, _math.sin)(phi1),
          cosPhi1 = (0, _math.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math.pi,
          k = sinPhi0 * sinPhi1;
      sum.add((0, _math.atan2)(k * sign * (0, _math.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0, _math.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math.tau : delta; // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?

      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0, _cartesian.cartesianCross)((0, _cartesian.cartesian)(point0), (0, _cartesian.cartesian)(point1));
        (0, _cartesian.cartesianNormalizeInPlace)(arc);
        var intersection = (0, _cartesian.cartesianCross)(normal, arc);
        (0, _cartesian.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0, _math.asin)(intersection[2]);

        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  } // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.


  return (angle < -_math.epsilon || angle < _math.epsilon && sum < -_math.epsilon) ^ winding & 1;
}

},{"./adder":113,"./cartesian":116,"./math":135}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _conicEqualArea = _interopRequireDefault(require("./conicEqualArea"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  return (0, _conicEqualArea.default)().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

},{"./conicEqualArea":153}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _math = require("../math");

var _albers = _interopRequireDefault(require("./albers"));

var _conicEqualArea = _interopRequireDefault(require("./conicEqualArea"));

var _fit = require("./fit");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function (x, y) {
      var i = -1;

      while (++i < n) streams[i].point(x, y);
    },
    sphere: function () {
      var i = -1;

      while (++i < n) streams[i].sphere();
    },
    lineStart: function () {
      var i = -1;

      while (++i < n) streams[i].lineStart();
    },
    lineEnd: function () {
      var i = -1;

      while (++i < n) streams[i].lineEnd();
    },
    polygonStart: function () {
      var i = -1;

      while (++i < n) streams[i].polygonStart();
    },
    polygonEnd: function () {
      var i = -1;

      while (++i < n) streams[i].polygonEnd();
    }
  };
} // A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers


function _default() {
  var cache,
      cacheStream,
      lower48 = (0, _albers.default)(),
      lower48Point,
      alaska = (0, _conicEqualArea.default)().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      alaskaPoint,
      // EPSG:3338
  hawaii = (0, _conicEqualArea.default)().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      hawaiiPoint,
      // ESRI:102007
  point,
      pointStream = {
    point: function (x, y) {
      point = [x, y];
    }
  };

  function albersUsa(coordinates) {
    var x = coordinates[0],
        y = coordinates[1];
    return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function (coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
  };

  albersUsa.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function (_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function (_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function (_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(),
        x = +_[0],
        y = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + _math.epsilon, y + 0.120 * k + _math.epsilon], [x - 0.214 * k - _math.epsilon, y + 0.234 * k - _math.epsilon]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + _math.epsilon, y + 0.166 * k + _math.epsilon], [x - 0.115 * k - _math.epsilon, y + 0.234 * k - _math.epsilon]]).stream(pointStream);
    return reset();
  };

  albersUsa.fitExtent = function (extent, object) {
    return (0, _fit.fitExtent)(albersUsa, extent, object);
  };

  albersUsa.fitSize = function (size, object) {
    return (0, _fit.fitSize)(albersUsa, size, object);
  };

  albersUsa.fitWidth = function (width, object) {
    return (0, _fit.fitWidth)(albersUsa, width, object);
  };

  albersUsa.fitHeight = function (height, object) {
    return (0, _fit.fitHeight)(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

},{"../math":135,"./albers":146,"./conicEqualArea":153,"./fit":157}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.azimuthalInvert = azimuthalInvert;
exports.azimuthalRaw = azimuthalRaw;

var _math = require("../math");

function azimuthalRaw(scale) {
  return function (x, y) {
    var cx = (0, _math.cos)(x),
        cy = (0, _math.cos)(y),
        k = scale(cx * cy);
    return [k * cy * (0, _math.sin)(x), k * (0, _math.sin)(y)];
  };
}

function azimuthalInvert(angle) {
  return function (x, y) {
    var z = (0, _math.sqrt)(x * x + y * y),
        c = angle(z),
        sc = (0, _math.sin)(c),
        cc = (0, _math.cos)(c);
    return [(0, _math.atan2)(x * sc, z * cc), (0, _math.asin)(z && y * sc / z)];
  };
}

},{"../math":135}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.azimuthalEqualAreaRaw = void 0;
exports.default = _default;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var azimuthalEqualAreaRaw = (0, _azimuthal.azimuthalRaw)(function (cxcy) {
  return (0, _math.sqrt)(2 / (1 + cxcy));
});
exports.azimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
azimuthalEqualAreaRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
  return 2 * (0, _math.asin)(z / 2);
});

function _default() {
  return (0, _index.default)(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

},{"../math":135,"./azimuthal":148,"./index":160}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.azimuthalEquidistantRaw = void 0;
exports.default = _default;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var azimuthalEquidistantRaw = (0, _azimuthal.azimuthalRaw)(function (c) {
  return (c = (0, _math.acos)(c)) && c / (0, _math.sin)(c);
});
exports.azimuthalEquidistantRaw = azimuthalEquidistantRaw;
azimuthalEquidistantRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
  return z;
});

function _default() {
  return (0, _index.default)(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

},{"../math":135,"./azimuthal":148,"./index":160}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conicProjection = conicProjection;

var _math = require("../math");

var _index = require("./index");

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math.pi / 3,
      m = (0, _index.projectionMutator)(projectAt),
      p = m(phi0, phi1);

  p.parallels = function (_) {
    return arguments.length ? m(phi0 = _[0] * _math.radians, phi1 = _[1] * _math.radians) : [phi0 * _math.degrees, phi1 * _math.degrees];
  };

  return p;
}

},{"../math":135,"./index":160}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conicConformalRaw = conicConformalRaw;
exports.default = _default;

var _math = require("../math");

var _conic = require("./conic");

var _mercator = require("./mercator");

function tany(y) {
  return (0, _math.tan)((_math.halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = (0, _math.cos)(y0),
      n = y0 === y1 ? (0, _math.sin)(y0) : (0, _math.log)(cy0 / (0, _math.cos)(y1)) / (0, _math.log)(tany(y1) / tany(y0)),
      f = cy0 * (0, _math.pow)(tany(y0), n) / n;
  if (!n) return _mercator.mercatorRaw;

  function project(x, y) {
    if (f > 0) {
      if (y < -_math.halfPi + _math.epsilon) y = -_math.halfPi + _math.epsilon;
    } else {
      if (y > _math.halfPi - _math.epsilon) y = _math.halfPi - _math.epsilon;
    }

    var r = f / (0, _math.pow)(tany(y), n);
    return [r * (0, _math.sin)(n * x), f - r * (0, _math.cos)(n * x)];
  }

  project.invert = function (x, y) {
    var fy = f - y,
        r = (0, _math.sign)(n) * (0, _math.sqrt)(x * x + fy * fy);
    return [(0, _math.atan2)(x, (0, _math.abs)(fy)) / n * (0, _math.sign)(fy), 2 * (0, _math.atan)((0, _math.pow)(f / r, 1 / n)) - _math.halfPi];
  };

  return project;
}

function _default() {
  return (0, _conic.conicProjection)(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

},{"../math":135,"./conic":151,"./mercator":161}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conicEqualAreaRaw = conicEqualAreaRaw;
exports.default = _default;

var _math = require("../math");

var _conic = require("./conic");

var _cylindricalEqualArea = require("./cylindricalEqualArea");

function conicEqualAreaRaw(y0, y1) {
  var sy0 = (0, _math.sin)(y0),
      n = (sy0 + (0, _math.sin)(y1)) / 2; // Are the parallels symmetrical around the Equator?

  if ((0, _math.abs)(n) < _math.epsilon) return (0, _cylindricalEqualArea.cylindricalEqualAreaRaw)(y0);
  var c = 1 + sy0 * (2 * n - sy0),
      r0 = (0, _math.sqrt)(c) / n;

  function project(x, y) {
    var r = (0, _math.sqrt)(c - 2 * n * (0, _math.sin)(y)) / n;
    return [r * (0, _math.sin)(x *= n), r0 - r * (0, _math.cos)(x)];
  }

  project.invert = function (x, y) {
    var r0y = r0 - y;
    return [(0, _math.atan2)(x, (0, _math.abs)(r0y)) / n * (0, _math.sign)(r0y), (0, _math.asin)((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

function _default() {
  return (0, _conic.conicProjection)(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

},{"../math":135,"./conic":151,"./cylindricalEqualArea":155}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conicEquidistantRaw = conicEquidistantRaw;
exports.default = _default;

var _math = require("../math");

var _conic = require("./conic");

var _equirectangular = require("./equirectangular");

function conicEquidistantRaw(y0, y1) {
  var cy0 = (0, _math.cos)(y0),
      n = y0 === y1 ? (0, _math.sin)(y0) : (cy0 - (0, _math.cos)(y1)) / (y1 - y0),
      g = cy0 / n + y0;
  if ((0, _math.abs)(n) < _math.epsilon) return _equirectangular.equirectangularRaw;

  function project(x, y) {
    var gy = g - y,
        nx = n * x;
    return [gy * (0, _math.sin)(nx), g - gy * (0, _math.cos)(nx)];
  }

  project.invert = function (x, y) {
    var gy = g - y;
    return [(0, _math.atan2)(x, (0, _math.abs)(gy)) / n * (0, _math.sign)(gy), g - (0, _math.sign)(n) * (0, _math.sqrt)(x * x + gy * gy)];
  };

  return project;
}

function _default() {
  return (0, _conic.conicProjection)(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

},{"../math":135,"./conic":151,"./equirectangular":156}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cylindricalEqualAreaRaw = cylindricalEqualAreaRaw;

var _math = require("../math");

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = (0, _math.cos)(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, (0, _math.sin)(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, (0, _math.asin)(y * cosPhi0)];
  };

  return forward;
}

},{"../math":135}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.equirectangularRaw = equirectangularRaw;

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

function _default() {
  return (0, _index.default)(equirectangularRaw).scale(152.63);
}

},{"./index":160}],157:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitExtent = fitExtent;
exports.fitHeight = fitHeight;
exports.fitSize = fitSize;
exports.fitWidth = fitWidth;

var _stream = _interopRequireDefault(require("../stream"));

var _bounds = _interopRequireDefault(require("../path/bounds"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0, _stream.default)(object, projection.stream(_bounds.default));
  fitBounds(_bounds.default.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function (b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function (b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function (b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

},{"../path/bounds":138,"../stream":168}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.gnomonicRaw = gnomonicRaw;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function gnomonicRaw(x, y) {
  var cy = (0, _math.cos)(y),
      k = (0, _math.cos)(x) * cy;
  return [cy * (0, _math.sin)(x) / k, (0, _math.sin)(y) / k];
}

gnomonicRaw.invert = (0, _azimuthal.azimuthalInvert)(_math.atan);

function _default() {
  return (0, _index.default)(gnomonicRaw).scale(144.049).clipAngle(60);
}

},{"../math":135,"./azimuthal":148,"./index":160}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _rectangle = _interopRequireDefault(require("../clip/rectangle"));

var _identity = _interopRequireDefault(require("../identity"));

var _transform = require("../transform");

var _fit = require("./fit");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? _identity.default : (0, _transform.transformer)({
    point: function (x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

function _default() {
  var k = 1,
      tx = 0,
      ty = 0,
      sx = 1,
      sy = 1,
      transform = _identity.default,
      // scale, translate and reflect
  x0 = null,
      y0,
      x1,
      y1,
      // clip extent
  postclip = _identity.default,
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function (stream) {
      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
    },
    postclip: function (_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function (_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity.default) : (0, _rectangle.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function (_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function (extent, object) {
      return (0, _fit.fitExtent)(projection, extent, object);
    },
    fitSize: function (size, object) {
      return (0, _fit.fitSize)(projection, size, object);
    },
    fitWidth: function (width, object) {
      return (0, _fit.fitWidth)(projection, width, object);
    },
    fitHeight: function (height, object) {
      return (0, _fit.fitHeight)(projection, height, object);
    }
  };
}

},{"../clip/rectangle":125,"../identity":132,"../transform":169,"./fit":157}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = projection;
exports.projectionMutator = projectionMutator;

var _antimeridian = _interopRequireDefault(require("../clip/antimeridian"));

var _circle = _interopRequireDefault(require("../clip/circle"));

var _rectangle = _interopRequireDefault(require("../clip/rectangle"));

var _compose = _interopRequireDefault(require("../compose"));

var _identity = _interopRequireDefault(require("../identity"));

var _math = require("../math");

var _rotation = require("../rotation");

var _transform = require("../transform");

var _fit = require("./fit");

var _resample = _interopRequireDefault(require("./resample"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var transformRadians = (0, _transform.transformer)({
  point: function (x, y) {
    this.stream.point(x * _math.radians, y * _math.radians);
  }
});

function transformRotate(rotate) {
  return (0, _transform.transformer)({
    point: function (x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function projection(project) {
  return projectionMutator(function () {
    return project;
  })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150,
      // scale
  x = 480,
      y = 250,
      // translate
  dx,
      dy,
      lambda = 0,
      phi = 0,
      // center
  deltaLambda = 0,
      deltaPhi = 0,
      deltaGamma = 0,
      rotate,
      projectRotate,
      // rotate
  theta = null,
      preclip = _antimeridian.default,
      // clip angle
  x0 = null,
      y0,
      x1,
      y1,
      postclip = _identity.default,
      // clip extent
  delta2 = 0.5,
      projectResample = (0, _resample.default)(projectTransform, delta2),
      // precision
  cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * _math.radians, point[1] * _math.radians);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * _math.degrees, point[1] * _math.degrees];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function (_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function (_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function (_) {
    return arguments.length ? (preclip = +_ ? (0, _circle.default)(theta = _ * _math.radians) : (theta = null, _antimeridian.default), reset()) : theta * _math.degrees;
  };

  projection.clipExtent = function (_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity.default) : (0, _rectangle.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function (_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function (_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function (_) {
    return arguments.length ? (lambda = _[0] % 360 * _math.radians, phi = _[1] % 360 * _math.radians, recenter()) : [lambda * _math.degrees, phi * _math.degrees];
  };

  projection.rotate = function (_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math.radians, deltaPhi = _[1] % 360 * _math.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math.radians : 0, recenter()) : [deltaLambda * _math.degrees, deltaPhi * _math.degrees, deltaGamma * _math.degrees];
  };

  projection.precision = function (_) {
    return arguments.length ? (projectResample = (0, _resample.default)(projectTransform, delta2 = _ * _), reset()) : (0, _math.sqrt)(delta2);
  };

  projection.fitExtent = function (extent, object) {
    return (0, _fit.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function (size, object) {
    return (0, _fit.fitSize)(projection, size, object);
  };

  projection.fitWidth = function (width, object) {
    return (0, _fit.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function (height, object) {
    return (0, _fit.fitHeight)(projection, height, object);
  };

  function recenter() {
    projectRotate = (0, _compose.default)(rotate = (0, _rotation.rotateRadians)(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function () {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

},{"../clip/antimeridian":119,"../clip/circle":121,"../clip/rectangle":125,"../compose":127,"../identity":132,"../math":135,"../rotation":167,"../transform":169,"./fit":157,"./resample":164}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.mercatorProjection = mercatorProjection;
exports.mercatorRaw = mercatorRaw;

var _math = require("../math");

var _rotation = _interopRequireDefault(require("../rotation"));

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mercatorRaw(lambda, phi) {
  return [lambda, (0, _math.log)((0, _math.tan)((_math.halfPi + phi) / 2))];
}

mercatorRaw.invert = function (x, y) {
  return [x, 2 * (0, _math.atan)((0, _math.exp)(y)) - _math.halfPi];
};

function _default() {
  return mercatorProjection(mercatorRaw).scale(961 / _math.tau);
}

function mercatorProjection(project) {
  var m = (0, _index.default)(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null,
      y0,
      x1,
      y1; // clip extent

  m.scale = function (_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function (_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function (_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function (_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math.pi * scale(),
        t = m((0, _rotation.default)(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

},{"../math":135,"../rotation":167,"./index":160}],162:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.naturalEarth1Raw = naturalEarth1Raw;

var _index = _interopRequireDefault(require("./index"));

var _math = require("../math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi,
      phi4 = phi2 * phi2;
  return [lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))), phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))];
}

naturalEarth1Raw.invert = function (x, y) {
  var phi = y,
      i = 25,
      delta;

  do {
    var phi2 = phi * phi,
        phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0);

  return [x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))), phi];
};

function _default() {
  return (0, _index.default)(naturalEarth1Raw).scale(175.295);
}

},{"../math":135,"./index":160}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.orthographicRaw = orthographicRaw;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function orthographicRaw(x, y) {
  return [(0, _math.cos)(y) * (0, _math.sin)(x), (0, _math.sin)(y)];
}

orthographicRaw.invert = (0, _azimuthal.azimuthalInvert)(_math.asin);

function _default() {
  return (0, _index.default)(orthographicRaw).scale(249.5).clipAngle(90 + _math.epsilon);
}

},{"../math":135,"./azimuthal":148,"./index":160}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _cartesian = require("../cartesian");

var _math = require("../math");

var _transform = require("../transform");

var maxDepth = 16,
    // maximum depth of subdivision
cosMinDistance = (0, _math.cos)(30 * _math.radians); // cos(minimum angular distance)

function _default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0, _transform.transformer)({
    point: function (x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {
  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;

    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0, _math.sqrt)(a * a + b * b + c * c),
          phi2 = (0, _math.asin)(c /= m),
          lambda2 = (0, _math.abs)((0, _math.abs)(c) - 1) < _math.epsilon || (0, _math.abs)(lambda0 - lambda1) < _math.epsilon ? (lambda0 + lambda1) / 2 : (0, _math.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;

      if (dz * dz / d2 > delta2 // perpendicular projected distance
      || (0, _math.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
      || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }

  return function (stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
    lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function () {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function () {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0, _cartesian.cartesian)([lambda, phi]),
          p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

},{"../cartesian":116,"../math":135,"../transform":169}],165:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.stereographicRaw = stereographicRaw;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stereographicRaw(x, y) {
  var cy = (0, _math.cos)(y),
      k = 1 + (0, _math.cos)(x) * cy;
  return [cy * (0, _math.sin)(x) / k, (0, _math.sin)(y) / k];
}

stereographicRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
  return 2 * (0, _math.atan)(z);
});

function _default() {
  return (0, _index.default)(stereographicRaw).scale(250).clipAngle(142);
}

},{"../math":135,"./azimuthal":148,"./index":160}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.transverseMercatorRaw = transverseMercatorRaw;

var _math = require("../math");

var _mercator = require("./mercator");

function transverseMercatorRaw(lambda, phi) {
  return [(0, _math.log)((0, _math.tan)((_math.halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function (x, y) {
  return [-y, 2 * (0, _math.atan)((0, _math.exp)(x)) - _math.halfPi];
};

function _default() {
  var m = (0, _mercator.mercatorProjection)(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function (_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function (_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90]).scale(159.155);
}

},{"../math":135,"./mercator":161}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.rotateRadians = rotateRadians;

var _compose = _interopRequireDefault(require("./compose"));

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rotationIdentity(lambda, phi) {
  return [lambda > _math.pi ? lambda - _math.tau : lambda < -_math.pi ? lambda + _math.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math.tau) ? deltaPhi || deltaGamma ? (0, _compose.default)(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}

function forwardRotationLambda(deltaLambda) {
  return function (lambda, phi) {
    return lambda += deltaLambda, [lambda > _math.pi ? lambda - _math.tau : lambda < -_math.pi ? lambda + _math.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0, _math.cos)(deltaPhi),
      sinDeltaPhi = (0, _math.sin)(deltaPhi),
      cosDeltaGamma = (0, _math.cos)(deltaGamma),
      sinDeltaGamma = (0, _math.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0, _math.cos)(phi),
        x = (0, _math.cos)(lambda) * cosPhi,
        y = (0, _math.sin)(lambda) * cosPhi,
        z = (0, _math.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [(0, _math.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), (0, _math.asin)(k * cosDeltaGamma + y * sinDeltaGamma)];
  }

  rotation.invert = function (lambda, phi) {
    var cosPhi = (0, _math.cos)(phi),
        x = (0, _math.cos)(lambda) * cosPhi,
        y = (0, _math.sin)(lambda) * cosPhi,
        z = (0, _math.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [(0, _math.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), (0, _math.asin)(k * cosDeltaPhi - x * sinDeltaPhi)];
  };

  return rotation;
}

function _default(rotate) {
  rotate = rotateRadians(rotate[0] * _math.radians, rotate[1] * _math.radians, rotate.length > 2 ? rotate[2] * _math.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math.radians, coordinates[1] * _math.radians);
    return coordinates[0] *= _math.degrees, coordinates[1] *= _math.degrees, coordinates;
  }

  forward.invert = function (coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math.radians, coordinates[1] * _math.radians);
    return coordinates[0] *= _math.degrees, coordinates[1] *= _math.degrees, coordinates;
  };

  return forward;
}

},{"./compose":127,"./math":135}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function (object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function (object, stream) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function (object, stream) {
    stream.sphere();
  },
  Point: function (object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function (object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function (object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function (object, stream) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1,
      n = coordinates.length - closed,
      coordinate;
  stream.lineStart();

  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);

  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1,
      n = coordinates.length;
  stream.polygonStart();

  while (++i < n) streamLine(coordinates[i], stream, 1);

  stream.polygonEnd();
}

function _default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

},{}],169:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.transformer = transformer;

function _default(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function (stream) {
    var s = new TransformStream();

    for (var key in methods) s[key] = methods[key];

    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function (x, y) {
    this.stream.point(x, y);
  },
  sphere: function () {
    this.stream.sphere();
  },
  lineStart: function () {
    this.stream.lineStart();
  },
  lineEnd: function () {
    this.stream.lineEnd();
  },
  polygonStart: function () {
    this.stream.polygonStart();
  },
  polygonEnd: function () {
    this.stream.polygonEnd();
  }
};

},{}],170:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "cluster", {
  enumerable: true,
  get: function () {
    return _cluster.default;
  }
});
Object.defineProperty(exports, "hierarchy", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
Object.defineProperty(exports, "pack", {
  enumerable: true,
  get: function () {
    return _index2.default;
  }
});
Object.defineProperty(exports, "packEnclose", {
  enumerable: true,
  get: function () {
    return _enclose.default;
  }
});
Object.defineProperty(exports, "packSiblings", {
  enumerable: true,
  get: function () {
    return _siblings.default;
  }
});
Object.defineProperty(exports, "partition", {
  enumerable: true,
  get: function () {
    return _partition.default;
  }
});
Object.defineProperty(exports, "stratify", {
  enumerable: true,
  get: function () {
    return _stratify.default;
  }
});
Object.defineProperty(exports, "tree", {
  enumerable: true,
  get: function () {
    return _tree.default;
  }
});
Object.defineProperty(exports, "treemap", {
  enumerable: true,
  get: function () {
    return _index3.default;
  }
});
Object.defineProperty(exports, "treemapBinary", {
  enumerable: true,
  get: function () {
    return _binary.default;
  }
});
Object.defineProperty(exports, "treemapDice", {
  enumerable: true,
  get: function () {
    return _dice.default;
  }
});
Object.defineProperty(exports, "treemapResquarify", {
  enumerable: true,
  get: function () {
    return _resquarify.default;
  }
});
Object.defineProperty(exports, "treemapSlice", {
  enumerable: true,
  get: function () {
    return _slice.default;
  }
});
Object.defineProperty(exports, "treemapSliceDice", {
  enumerable: true,
  get: function () {
    return _sliceDice.default;
  }
});
Object.defineProperty(exports, "treemapSquarify", {
  enumerable: true,
  get: function () {
    return _squarify.default;
  }
});

var _cluster = _interopRequireDefault(require("./src/cluster"));

var _index = _interopRequireDefault(require("./src/hierarchy/index"));

var _index2 = _interopRequireDefault(require("./src/pack/index"));

var _siblings = _interopRequireDefault(require("./src/pack/siblings"));

var _enclose = _interopRequireDefault(require("./src/pack/enclose"));

var _partition = _interopRequireDefault(require("./src/partition"));

var _stratify = _interopRequireDefault(require("./src/stratify"));

var _tree = _interopRequireDefault(require("./src/tree"));

var _index3 = _interopRequireDefault(require("./src/treemap/index"));

var _binary = _interopRequireDefault(require("./src/treemap/binary"));

var _dice = _interopRequireDefault(require("./src/treemap/dice"));

var _slice = _interopRequireDefault(require("./src/treemap/slice"));

var _sliceDice = _interopRequireDefault(require("./src/treemap/sliceDice"));

var _squarify = _interopRequireDefault(require("./src/treemap/squarify"));

var _resquarify = _interopRequireDefault(require("./src/treemap/resquarify"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/cluster":173,"./src/hierarchy/index":181,"./src/pack/enclose":187,"./src/pack/index":188,"./src/pack/siblings":189,"./src/partition":190,"./src/stratify":191,"./src/tree":192,"./src/treemap/binary":193,"./src/treemap/dice":194,"./src/treemap/index":195,"./src/treemap/resquarify":196,"./src/treemap/slice":198,"./src/treemap/sliceDice":199,"./src/treemap/squarify":200}],171:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.optional = optional;
exports.required = required;

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

},{}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shuffle = shuffle;
exports.slice = void 0;
var slice = Array.prototype.slice;
exports.slice = slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

},{}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;

  while (children = node.children) node = children[0];

  return node;
}

function leafRight(node) {
  var children;

  while (children = node.children) node = children[children.length - 1];

  return node;
}

function _default() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0; // First walk, computing the initial x & y values.

    root.eachAfter(function (node) {
      var children = node.children;

      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2; // Second walk, normalizing x & y to the desired size.

    return root.eachAfter(nodeSize ? function (node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function (node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function (x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
  };

  cluster.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
  };

  return cluster;
}

},{}],174:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constantZero = constantZero;
exports.default = _default;

function constantZero() {
  return 0;
}

function _default(x) {
  return function () {
    return x;
  };
}

},{}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var node = this,
      nodes = [node];

  while (node = node.parent) {
    nodes.push(node);
  }

  return nodes;
}

},{}],176:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function _default() {
  return this.eachAfter(count);
}

},{}],177:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var nodes = [];
  this.each(function (node) {
    nodes.push(node);
  });
  return nodes;
}

},{}],178:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback) {
  var node = this,
      current,
      next = [node],
      children,
      i,
      n;

  do {
    current = next.reverse(), next = [];

    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);

  return this;
}

},{}],179:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback) {
  var node = this,
      nodes = [node],
      next = [],
      children,
      i,
      n;

  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }

  while (node = next.pop()) {
    callback(node);
  }

  return this;
}

},{}],180:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback) {
  var node = this,
      nodes = [node],
      children,
      i;

  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }

  return this;
}

},{}],181:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Node = Node;
exports.computeHeight = computeHeight;
exports.default = hierarchy;

var _count = _interopRequireDefault(require("./count"));

var _each = _interopRequireDefault(require("./each"));

var _eachBefore = _interopRequireDefault(require("./eachBefore"));

var _eachAfter = _interopRequireDefault(require("./eachAfter"));

var _sum = _interopRequireDefault(require("./sum"));

var _sort = _interopRequireDefault(require("./sort"));

var _path = _interopRequireDefault(require("./path"));

var _ancestors = _interopRequireDefault(require("./ancestors"));

var _descendants = _interopRequireDefault(require("./descendants"));

var _leaves = _interopRequireDefault(require("./leaves"));

var _links = _interopRequireDefault(require("./links"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;
  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;

    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);

      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;

  do node.height = height; while ((node = node.parent) && node.height < ++height);
}

function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: _count.default,
  each: _each.default,
  eachAfter: _eachAfter.default,
  eachBefore: _eachBefore.default,
  sum: _sum.default,
  sort: _sort.default,
  path: _path.default,
  ancestors: _ancestors.default,
  descendants: _descendants.default,
  leaves: _leaves.default,
  links: _links.default,
  copy: node_copy
};

},{"./ancestors":175,"./count":176,"./descendants":177,"./each":178,"./eachAfter":179,"./eachBefore":180,"./leaves":182,"./links":183,"./path":184,"./sort":185,"./sum":186}],182:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var leaves = [];
  this.eachBefore(function (node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

},{}],183:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var root = this,
      links = [];
  root.each(function (node) {
    if (node !== root) {
      // Don’t include the root’s parent, if any.
      links.push({
        source: node.parent,
        target: node
      });
    }
  });
  return links;
}

},{}],184:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];

  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }

  var k = nodes.length;

  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }

  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();

  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }

  return c;
}

},{}],185:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(compare) {
  return this.eachBefore(function (node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

},{}],186:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(value) {
  return this.eachAfter(function (node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;

    while (--i >= 0) sum += children[i].value;

    node.value = sum;
  });
}

},{}],187:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("../array");

function _default(circles) {
  var i = 0,
      n = (circles = (0, _array.shuffle)(_array.slice.call(circles))).length,
      B = [],
      p,
      e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B)) return [p]; // If we get here then B must have at least one element.

  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  } // If we get here then B must have at least two elements.


  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  } // If we get here then something is very wrong.


  throw new Error();
}

function enclosesNot(a, b) {
  var dr = a.r - b.r,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }

  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);

    case 2:
      return encloseBasis2(B[0], B[1]);

    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x21 = x2 - x1,
      y21 = y2 - y1,
      r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x3 = c.x,
      y3 = c.y,
      r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

},{"../array":172}],188:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _siblings = require("./siblings");

var _accessors = require("../accessors");

var _constant = _interopRequireWildcard(require("../constant"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function _default() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = _constant.constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;

    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(_constant.constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }

    return root;
  }

  pack.radius = function (x) {
    return arguments.length ? (radius = (0, _accessors.optional)(x), pack) : radius;
  };

  pack.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function (x) {
    return arguments.length ? (padding = typeof x === "function" ? x : (0, _constant.default)(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function (node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function (node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;
      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = (0, _siblings.packEnclose)(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function (node) {
    var parent = node.parent;
    node.r *= k;

    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

},{"../accessors":171,"../constant":174,"./siblings":189}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.packEnclose = packEnclose;

var _enclose = _interopRequireDefault(require("./enclose"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;

  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk; // Place the first circle.

  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r; // Place the second circle.

  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r; // Place the third circle.

  place(b, a, c = circles[2]); // Initialize the front-chain using the first three circles a, b and c.

  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a; // Attempt to place each remaining circle…

  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c); // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.

    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;

    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }

        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }

        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next); // Success! Insert the new circle c between a and b.


    c.previous = a, c.next = b, a.next = b.previous = b = c; // Compute the new closest circle pair to the centroid.

    aa = score(a);

    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }

    b = a.next;
  } // Compute the enclosing circle of the front chain.


  a = [b._], c = b;

  while ((c = c.next) !== b) a.push(c._);

  c = (0, _enclose.default)(a); // Translate the circles to put the enclosing circle around the origin.

  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function _default(circles) {
  packEnclose(circles);
  return circles;
}

},{"./enclose":187}],190:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _round = _interopRequireDefault(require("./treemap/round"));

var _dice = _interopRequireDefault(require("./treemap/dice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(_round.default);
    return root;
  }

  function positionNode(dy, n) {
    return function (node) {
      if (node.children) {
        (0, _dice.default)(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }

      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function (x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function (x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

},{"./treemap/dice":194,"./treemap/round":197}],191:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _accessors = require("./accessors");

var _index = require("./hierarchy/index");

var keyPrefix = "$",
    // Protect against keys like “__proto__”.
preroot = {
  depth: -1
},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function _default() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new _index.Node(d);

      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);

      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function (node) {
      node.depth = node.parent.depth + 1;
      --n;
    }).eachBefore(_index.computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");
    return root;
  }

  stratify.id = function (x) {
    return arguments.length ? (id = (0, _accessors.required)(x), stratify) : id;
  };

  stratify.parentId = function (x) {
    return arguments.length ? (parentId = (0, _accessors.required)(x), stratify) : parentId;
  };

  return stratify;
}

},{"./accessors":171,"./hierarchy/index":181}],192:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./hierarchy/index");

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
} // function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }
// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.


function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
} // This function works analogously to nextLeft.


function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
} // Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.


function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
} // All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).


function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;

  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
} // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.


function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor

  this.a = this; // ancestor

  this.z = 0; // prelim

  this.m = 0; // mod

  this.c = 0; // change

  this.s = 0; // shift

  this.t = null; // thread

  this.i = i; // number
}

TreeNode.prototype = Object.create(_index.Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);

      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
} // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm


function _default() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root); // Compute the layout using Buchheim et al.’s algorithm.

    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y.

    if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function (node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function (node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root;
  } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.


  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;

    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;

      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }

    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  } // Computes all real x-coordinates by summing up the modifiers recursively.


  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  } // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).


  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;

      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);

        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }

        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }

      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }

      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }

    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function (x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
  };

  tree.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
  };

  return tree;
}

},{"./hierarchy/index":181}],193:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i,
      n = nodes.length,
      sum,
      sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = value / 2 + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;else hi = mid;
    }

    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k;
    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if (x1 - x0 > y1 - y0) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

},{}],194:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

},{}],195:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _round = _interopRequireDefault(require("./round"));

var _squarify = _interopRequireDefault(require("./squarify"));

var _accessors = require("../accessors");

var _constant = _interopRequireWildcard(require("../constant"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var tile = _squarify.default,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = _constant.constantZero,
      paddingTop = _constant.constantZero,
      paddingRight = _constant.constantZero,
      paddingBottom = _constant.constantZero,
      paddingLeft = _constant.constantZero;

  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(_round.default);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;

    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function (x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function (x) {
    return arguments.length ? (tile = (0, _accessors.required)(x), treemap) : tile;
  };

  treemap.padding = function (x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function (x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function (x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function (x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function (x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function (x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function (x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingLeft;
  };

  return treemap;
}

},{"../accessors":171,"../constant":174,"./round":197,"./squarify":200}],196:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dice = _interopRequireDefault(require("./dice"));

var _slice = _interopRequireDefault(require("./slice"));

var _squarify = require("./squarify");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function custom(ratio) {
  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;

        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;

        if (row.dice) (0, _dice.default)(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);else (0, _slice.default)(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = (0, _squarify.squarifyRatio)(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
}(_squarify.phi);

exports.default = _default;

},{"./dice":194,"./slice":198,"./squarify":200}],197:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

},{}],198:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

},{}],199:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _dice = _interopRequireDefault(require("./dice"));

var _slice = _interopRequireDefault(require("./slice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? _slice.default : _dice.default)(parent, x0, y0, x1, y1);
}

},{"./dice":194,"./slice":198}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phi = exports.default = void 0;
exports.squarifyRatio = squarifyRatio;

var _dice = _interopRequireDefault(require("./dice"));

var _slice = _interopRequireDefault(require("./slice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var phi = (1 + Math.sqrt(5)) / 2;
exports.phi = phi;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx,
      dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0; // Find the next non-empty node.

    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);

    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue); // Keep adding nodes while the aspect ratio maintains or improves.

    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);

      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }

      minRatio = newRatio;
    } // Position and record the row orientation.


    rows.push(row = {
      value: sumValue,
      dice: dx < dy,
      children: nodes.slice(i0, i1)
    });
    if (row.dice) (0, _dice.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else (0, _slice.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var _default = function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
}(phi);

exports.default = _default;

},{"./dice":194,"./slice":198}],201:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "interpolate", {
  enumerable: true,
  get: function () {
    return _value.default;
  }
});
Object.defineProperty(exports, "interpolateArray", {
  enumerable: true,
  get: function () {
    return _array.default;
  }
});
Object.defineProperty(exports, "interpolateBasis", {
  enumerable: true,
  get: function () {
    return _basis.default;
  }
});
Object.defineProperty(exports, "interpolateBasisClosed", {
  enumerable: true,
  get: function () {
    return _basisClosed.default;
  }
});
Object.defineProperty(exports, "interpolateCubehelix", {
  enumerable: true,
  get: function () {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "interpolateCubehelixLong", {
  enumerable: true,
  get: function () {
    return _cubehelix.cubehelixLong;
  }
});
Object.defineProperty(exports, "interpolateDate", {
  enumerable: true,
  get: function () {
    return _date.default;
  }
});
Object.defineProperty(exports, "interpolateHcl", {
  enumerable: true,
  get: function () {
    return _hcl.default;
  }
});
Object.defineProperty(exports, "interpolateHclLong", {
  enumerable: true,
  get: function () {
    return _hcl.hclLong;
  }
});
Object.defineProperty(exports, "interpolateHsl", {
  enumerable: true,
  get: function () {
    return _hsl.default;
  }
});
Object.defineProperty(exports, "interpolateHslLong", {
  enumerable: true,
  get: function () {
    return _hsl.hslLong;
  }
});
Object.defineProperty(exports, "interpolateLab", {
  enumerable: true,
  get: function () {
    return _lab.default;
  }
});
Object.defineProperty(exports, "interpolateNumber", {
  enumerable: true,
  get: function () {
    return _number.default;
  }
});
Object.defineProperty(exports, "interpolateObject", {
  enumerable: true,
  get: function () {
    return _object.default;
  }
});
Object.defineProperty(exports, "interpolateRgb", {
  enumerable: true,
  get: function () {
    return _rgb.default;
  }
});
Object.defineProperty(exports, "interpolateRgbBasis", {
  enumerable: true,
  get: function () {
    return _rgb.rgbBasis;
  }
});
Object.defineProperty(exports, "interpolateRgbBasisClosed", {
  enumerable: true,
  get: function () {
    return _rgb.rgbBasisClosed;
  }
});
Object.defineProperty(exports, "interpolateRound", {
  enumerable: true,
  get: function () {
    return _round.default;
  }
});
Object.defineProperty(exports, "interpolateString", {
  enumerable: true,
  get: function () {
    return _string.default;
  }
});
Object.defineProperty(exports, "interpolateTransformCss", {
  enumerable: true,
  get: function () {
    return _index.interpolateTransformCss;
  }
});
Object.defineProperty(exports, "interpolateTransformSvg", {
  enumerable: true,
  get: function () {
    return _index.interpolateTransformSvg;
  }
});
Object.defineProperty(exports, "interpolateZoom", {
  enumerable: true,
  get: function () {
    return _zoom.default;
  }
});
Object.defineProperty(exports, "quantize", {
  enumerable: true,
  get: function () {
    return _quantize.default;
  }
});

var _value = _interopRequireDefault(require("./src/value"));

var _array = _interopRequireDefault(require("./src/array"));

var _basis = _interopRequireDefault(require("./src/basis"));

var _basisClosed = _interopRequireDefault(require("./src/basisClosed"));

var _date = _interopRequireDefault(require("./src/date"));

var _number = _interopRequireDefault(require("./src/number"));

var _object = _interopRequireDefault(require("./src/object"));

var _round = _interopRequireDefault(require("./src/round"));

var _string = _interopRequireDefault(require("./src/string"));

var _index = require("./src/transform/index");

var _zoom = _interopRequireDefault(require("./src/zoom"));

var _rgb = _interopRequireWildcard(require("./src/rgb"));

var _hsl = _interopRequireWildcard(require("./src/hsl"));

var _lab = _interopRequireDefault(require("./src/lab"));

var _hcl = _interopRequireWildcard(require("./src/hcl"));

var _cubehelix = _interopRequireWildcard(require("./src/cubehelix"));

var _quantize = _interopRequireDefault(require("./src/quantize"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/array":202,"./src/basis":203,"./src/basisClosed":204,"./src/cubehelix":207,"./src/date":208,"./src/hcl":209,"./src/hsl":210,"./src/lab":211,"./src/number":212,"./src/object":213,"./src/quantize":214,"./src/rgb":215,"./src/round":216,"./src/string":217,"./src/transform/index":219,"./src/value":221,"./src/zoom":222}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _value = _interopRequireDefault(require("./value"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0, _value.default)(a[i], b[i]);

  for (; i < nb; ++i) c[i] = b[i];

  return function (t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);

    return c;
  };
}

},{"./value":221}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basis = basis;
exports.default = _default;

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
      t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}

function _default(values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

},{}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _basis = require("./basis");

function _default(values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0, _basis.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}

},{"./basis":203}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nogamma;
exports.gamma = gamma;
exports.hue = hue;

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0, _constant.default)(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : (0, _constant.default)(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0, _constant.default)(isNaN(a) ? b : a);
}

},{"./constant":206}],206:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.cubehelixLong = void 0;

var _d3Color = require("d3-color");

var _color = _interopRequireWildcard(require("./color"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function cubehelix(hue) {
  return function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = (0, _d3Color.cubehelix)(start)).h, (end = (0, _d3Color.cubehelix)(end)).h),
          s = (0, _color.default)(start.s, end.s),
          l = (0, _color.default)(start.l, end.l),
          opacity = (0, _color.default)(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;
    return cubehelix;
  }(1);
}

var _default = cubehelix(_color.hue);

exports.default = _default;
var cubehelixLong = cubehelix(_color.default);
exports.cubehelixLong = cubehelixLong;

},{"./color":205,"d3-color":55}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  var d = new Date();
  return a = +a, b -= a, function (t) {
    return d.setTime(a + b * t), d;
  };
}

},{}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hclLong = exports.default = void 0;

var _d3Color = require("d3-color");

var _color = _interopRequireWildcard(require("./color"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function hcl(hue) {
  return function (start, end) {
    var h = hue((start = (0, _d3Color.hcl)(start)).h, (end = (0, _d3Color.hcl)(end)).h),
        c = (0, _color.default)(start.c, end.c),
        l = (0, _color.default)(start.l, end.l),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

var _default = hcl(_color.hue);

exports.default = _default;
var hclLong = hcl(_color.default);
exports.hclLong = hclLong;

},{"./color":205,"d3-color":55}],210:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hslLong = exports.default = void 0;

var _d3Color = require("d3-color");

var _color = _interopRequireWildcard(require("./color"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function hsl(hue) {
  return function (start, end) {
    var h = hue((start = (0, _d3Color.hsl)(start)).h, (end = (0, _d3Color.hsl)(end)).h),
        s = (0, _color.default)(start.s, end.s),
        l = (0, _color.default)(start.l, end.l),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

var _default = hsl(_color.hue);

exports.default = _default;
var hslLong = hsl(_color.default);
exports.hslLong = hslLong;

},{"./color":205,"d3-color":55}],211:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lab;

var _d3Color = require("d3-color");

var _color = _interopRequireDefault(require("./color"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function lab(start, end) {
  var l = (0, _color.default)((start = (0, _d3Color.lab)(start)).l, (end = (0, _d3Color.lab)(end)).l),
      a = (0, _color.default)(start.a, end.a),
      b = (0, _color.default)(start.b, end.b),
      opacity = (0, _color.default)(start.opacity, end.opacity);
  return function (t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

},{"./color":205,"d3-color":55}],212:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a = +a, b -= a, function (t) {
    return a + b * t;
  };
}

},{}],213:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _value = _interopRequireDefault(require("./value"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(a, b) {
  var i = {},
      c = {},
      k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0, _value.default)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function (t) {
    for (k in i) c[k] = i[k](t);

    return c;
  };
}

},{"./value":221}],214:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(interpolator, n) {
  var samples = new Array(n);

  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));

  return samples;
}

},{}],215:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rgbBasisClosed = exports.rgbBasis = exports.default = void 0;

var _d3Color = require("d3-color");

var _basis = _interopRequireDefault(require("./basis"));

var _basisClosed = _interopRequireDefault(require("./basisClosed"));

var _color = _interopRequireWildcard(require("./color"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function rgbGamma(y) {
  var color = (0, _color.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0, _d3Color.rgb)(start)).r, (end = (0, _d3Color.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;
  return rgb;
}(1);

exports.default = _default;

function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i,
        color;

    for (i = 0; i < n; ++i) {
      color = (0, _d3Color.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }

    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis.default);
exports.rgbBasis = rgbBasis;
var rgbBasisClosed = rgbSpline(_basisClosed.default);
exports.rgbBasisClosed = rgbBasisClosed;

},{"./basis":203,"./basisClosed":204,"./color":205,"d3-color":55}],216:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a = +a, b -= a, function (t) {
    return Math.round(a + b * t);
  };
}

},{}],217:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function () {
    return b;
  };
}

function one(b) {
  return function (t) {
    return b(t) + "";
  };
}

function _default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      // scan index for next number in b
  am,
      // current match in a
  bm,
      // current match in b
  bs,
      // string preceding current number in b, if any
  i = -1,
      // index in s
  s = [],
      // string constants and placeholders
  q = []; // number interpolators
  // Coerce inputs to strings.

  a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: (0, _number.default)(am, bm)
      });
    }

    bi = reB.lastIndex;
  } // Add remains of b.


  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  } // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.


  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);

    return s.join("");
  });
}

},{"./number":212}],218:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.identity = void 0;
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
exports.identity = identity;

function _default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

},{}],219:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolateTransformSvg = exports.interpolateTransformCss = void 0;

var _number = _interopRequireDefault(require("../number"));

var _parse = require("./parse");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: (0, _number.default)(xa, xb)
      }, {
        i: i - 2,
        x: (0, _number.default)(ya, yb)
      });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

      q.push({
        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
        x: (0, _number.default)(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({
        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
        x: (0, _number.default)(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: (0, _number.default)(xa, xb)
      }, {
        i: i - 2,
        x: (0, _number.default)(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function (a, b) {
    var s = [],
        // string constants and placeholders
    q = []; // number interpolators

    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc

    return function (t) {
      var i = -1,
          n = q.length,
          o;

      while (++i < n) s[(o = q[i]).i] = o.x(t);

      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse.parseCss, "px, ", "px)", "deg)");
exports.interpolateTransformCss = interpolateTransformCss;
var interpolateTransformSvg = interpolateTransform(_parse.parseSvg, ", ", ")", ")");
exports.interpolateTransformSvg = interpolateTransformSvg;

},{"../number":212,"./parse":220}],220:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCss = parseCss;
exports.parseSvg = parseSvg;

var _decompose = _interopRequireWildcard(require("./decompose"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var cssNode, cssRoot, cssView, svgNode;

function parseCss(value) {
  if (value === "none") return _decompose.identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return (0, _decompose.default)(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return _decompose.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose.identity;
  value = value.matrix;
  return (0, _decompose.default)(value.a, value.b, value.c, value.d, value.e, value.f);
}

},{"./decompose":218}],221:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Color = require("d3-color");

var _rgb = _interopRequireDefault(require("./rgb"));

var _array = _interopRequireDefault(require("./array"));

var _date = _interopRequireDefault(require("./date"));

var _number = _interopRequireDefault(require("./number"));

var _object = _interopRequireDefault(require("./object"));

var _string = _interopRequireDefault(require("./string"));

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(a, b) {
  var t = typeof b,
      c;
  return b == null || t === "boolean" ? (0, _constant.default)(b) : (t === "number" ? _number.default : t === "string" ? (c = (0, _d3Color.color)(b)) ? (b = c, _rgb.default) : _string.default : b instanceof _d3Color.color ? _rgb.default : b instanceof Date ? _date.default : Array.isArray(b) ? _array.default : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object.default : _number.default)(a, b);
}

},{"./array":202,"./constant":206,"./date":208,"./number":212,"./object":213,"./rgb":215,"./string":217,"d3-color":55}],222:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
} // p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]


function _default(p0, p1) {
  var ux0 = p0[0],
      uy0 = p0[1],
      w0 = p0[2],
      ux1 = p1[0],
      uy1 = p1[1],
      w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S; // Special case for u0 ≅ u1.

  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;

    i = function (t) {
      return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
    };
  } // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;

    i = function (t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
    };
  }

  i.duration = S * 1000;
  return i;
}

},{}],223:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "path", {
  enumerable: true,
  get: function () {
    return _path.default;
  }
});

var _path = _interopRequireDefault(require("./src/path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/path":224}],224:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath

  this._ = "";
}

function path() {
  return new Path();
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function (x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function () {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function (x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function (x1, y1, x, y) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function (x1, y1, x2, y2, x, y) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function (x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x1,y1).

    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon)) {} // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.

      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function (x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x0,y0).

    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    } // Is this arc empty? We’re done.


    if (!r) return; // Does the angle go the wrong way? Flip the direction.

    if (da < 0) da = da % tau + tau; // Is this a complete circle? Draw two arcs to complete the circle.

    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function (x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function () {
    return this._;
  }
};
var _default = path;
exports.default = _default;

},{}],225:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "polygonArea", {
  enumerable: true,
  get: function () {
    return _area.default;
  }
});
Object.defineProperty(exports, "polygonCentroid", {
  enumerable: true,
  get: function () {
    return _centroid.default;
  }
});
Object.defineProperty(exports, "polygonContains", {
  enumerable: true,
  get: function () {
    return _contains.default;
  }
});
Object.defineProperty(exports, "polygonHull", {
  enumerable: true,
  get: function () {
    return _hull.default;
  }
});
Object.defineProperty(exports, "polygonLength", {
  enumerable: true,
  get: function () {
    return _length.default;
  }
});

var _area = _interopRequireDefault(require("./src/area"));

var _centroid = _interopRequireDefault(require("./src/centroid"));

var _hull = _interopRequireDefault(require("./src/hull"));

var _contains = _interopRequireDefault(require("./src/contains"));

var _length = _interopRequireDefault(require("./src/length"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/area":226,"./src/centroid":227,"./src/contains":228,"./src/hull":230,"./src/length":231}],226:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
}

},{}],227:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
}

},{}],228:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0],
      y = point[1],
      x0 = p[0],
      y0 = p[1],
      x1,
      y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
}

},{}],229:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function _default(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}

},{}],230:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _cross = _interopRequireDefault(require("./cross"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
} // Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.


function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && (0, _cross.default)(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;

    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function _default(points) {
  if ((n = points.length) < 3) return null;
  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];

  sortedPoints.sort(lexicographicOrder);

  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints); // Construct the hull polygon, removing possible duplicate endpoints.

  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = []; // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.

  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);

  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
}

},{"./cross":229}],231:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
}

},{}],232:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "quadtree", {
  enumerable: true,
  get: function () {
    return _quadtree.default;
  }
});

var _quadtree = _interopRequireDefault(require("./src/quadtree"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/quadtree":239}],233:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAll = addAll;
exports.default = _default;

function _default(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {
    data: d
  },
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j; // If the tree is empty, initialize the root as a leaf.

  if (!node) return tree._root = leaf, tree; // Find the existing leaf for the new point, or add it.

  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  } // Is the new point is exactly coincident with the existing point?


  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; // Otherwise, split the leaf node until the old and new point are separated.

  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));

  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d,
      i,
      n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity; // Compute the points and their extent.

  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  } // If there were no (valid) points, inherit the existing extent.


  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1; // Expand the tree to cover the new points.

  this.cover(x0, y0).cover(x1, y1); // Add the new points.

  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

},{}],234:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1; // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!

  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  } // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    switch (i = (y < (y0 + y1) / 2) << 1 | x < (x0 + x1) / 2) {
      case 0:
        {
          do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1));

          break;
        }

      case 1:
        {
          do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1));

          break;
        }

      case 2:
        {
          do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y));

          break;
        }

      case 3:
        {
          do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y));

          break;
        }
    }

    if (this._root && this._root.length) this._root = node;
  } // If the quadtree covers the point already, just return.
  else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

},{}],235:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var data = [];
  this.visit(function (node) {
    if (!node.length) do data.push(node.data); while (node = node.next);
  });
  return data;
}

},{}],236:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

},{}],237:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;
  if (node) quads.push(new _quad.default(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {
    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue; // Bisect the current quadrant.

    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;
      quads.push(new _quad.default(node[3], xm, ym, x2, y2), new _quad.default(node[2], x1, ym, xm, y2), new _quad.default(node[1], xm, y1, x2, ym), new _quad.default(node[0], x1, y1, xm, ym)); // Visit the closest quadrant first.

      if (i = (y >= ym) << 1 | x >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;

      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

},{"./quad":238}],238:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

},{}],239:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quadtree;

var _add = _interopRequireWildcard(require("./add"));

var _cover = _interopRequireDefault(require("./cover"));

var _data = _interopRequireDefault(require("./data"));

var _extent = _interopRequireDefault(require("./extent"));

var _find = _interopRequireDefault(require("./find"));

var _remove = _interopRequireWildcard(require("./remove"));

var _root = _interopRequireDefault(require("./root"));

var _size = _interopRequireDefault(require("./size"));

var _visit = _interopRequireDefault(require("./visit"));

var _visitAfter = _interopRequireDefault(require("./visitAfter"));

var _x = _interopRequireWildcard(require("./x"));

var _y = _interopRequireWildcard(require("./y"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x.defaultX : x, y == null ? _y.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {
    data: leaf.data
  },
      next = copy;

  while (leaf = leaf.next) next = next.next = {
    data: leaf.data
  };

  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function () {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy(node), copy;
  nodes = [{
    source: node,
    target: copy._root = new Array(4)
  }];

  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({
          source: child,
          target: node.target[i] = new Array(4)
        });else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add.default;
treeProto.addAll = _add.addAll;
treeProto.cover = _cover.default;
treeProto.data = _data.default;
treeProto.extent = _extent.default;
treeProto.find = _find.default;
treeProto.remove = _remove.default;
treeProto.removeAll = _remove.removeAll;
treeProto.root = _root.default;
treeProto.size = _size.default;
treeProto.visit = _visit.default;
treeProto.visitAfter = _visitAfter.default;
treeProto.x = _x.default;
treeProto.y = _y.default;

},{"./add":233,"./cover":234,"./data":235,"./extent":236,"./find":237,"./remove":240,"./root":241,"./size":242,"./visit":243,"./visitAfter":244,"./x":245,"./y":246}],240:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.removeAll = removeAll;

function _default(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j; // If the tree is empty, initialize the root as a leaf.

  if (!node) return this; // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.

  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  } // Find the point to remove.

  while (node.data !== d) if (!(previous = node, node = node.next)) return this;

  if (next = node.next) delete node.next; // If there are multiple coincident points, remove just the point.

  if (previous) return next ? previous.next = next : delete previous.next, this; // If this is the root point, remove it.

  if (!parent) return this._root = next, this; // Remove this leaf.

  next ? parent[i] = next : delete parent[i]; // If the parent now contains exactly one leaf, collapse superfluous parents.

  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);

  return this;
}

},{}],241:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return this._root;
}

},{}],242:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var size = 0;
  this.visit(function (node) {
    if (!node.length) do ++size; while (node = node.next);
  });
  return size;
}

},{}],243:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(callback) {
  var quads = [],
      q,
      node = this._root,
      child,
      x0,
      y0,
      x1,
      y1;
  if (node) quads.push(new _quad.default(node, this._x0, this._y0, this._x1, this._y1));

  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad.default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad.default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad.default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad.default(child, x0, y0, xm, ym));
    }
  }

  return this;
}

},{"./quad":238}],244:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(callback) {
  var quads = [],
      next = [],
      q;
  if (this._root) quads.push(new _quad.default(this._root, this._x0, this._y0, this._x1, this._y1));

  while (q = quads.pop()) {
    var node = q.node;

    if (node.length) {
      var child,
          x0 = q.x0,
          y0 = q.y0,
          x1 = q.x1,
          y1 = q.y1,
          xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad.default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad.default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad.default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad.default(child, xm, ym, x1, y1));
    }

    next.push(q);
  }

  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }

  return this;
}

},{"./quad":238}],245:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.defaultX = defaultX;

function defaultX(d) {
  return d[0];
}

function _default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

},{}],246:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.defaultY = defaultY;

function defaultY(d) {
  return d[1];
}

function _default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

},{}],247:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "queue", {
  enumerable: true,
  get: function () {
    return _queue.default;
  }
});

var _queue = _interopRequireDefault(require("./src/queue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/queue":249}],248:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = void 0;
var slice = [].slice;
exports.slice = slice;

},{}],249:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queue;

var _array = require("./array");

var noabort = {};

function Queue(size) {
  this._size = size;
  this._call = this._error = null;
  this._tasks = [];
  this._data = [];
  this._waiting = this._active = this._ended = this._start = 0; // inside a synchronous task callback?
}

Queue.prototype = queue.prototype = {
  constructor: Queue,
  defer: function (callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("defer after await");
    if (this._error != null) return this;

    var t = _array.slice.call(arguments, 1);

    t.push(callback);
    ++this._waiting, this._tasks.push(t);
    poke(this);
    return this;
  },
  abort: function () {
    if (this._error == null) abort(this, new Error("abort"));
    return this;
  },
  await: function (callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");

    this._call = function (error, results) {
      callback.apply(null, [error].concat(results));
    };

    maybeNotify(this);
    return this;
  },
  awaitAll: function (callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = callback;
    maybeNotify(this);
    return this;
  }
};

function poke(q) {
  if (!q._start) {
    try {
      start(q);
    } // let the current task complete
    catch (e) {
      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
      else if (!q._data) throw e; // await callback errored synchronously
    }
  }
}

function start(q) {
  while (q._start = q._waiting && q._active < q._size) {
    var i = q._ended + q._active,
        t = q._tasks[i],
        j = t.length - 1,
        c = t[j];
    t[j] = end(q, i);
    --q._waiting, ++q._active;
    t = c.apply(null, t);
    if (!q._tasks[i]) continue; // task finished synchronously

    q._tasks[i] = t || noabort;
  }
}

function end(q, i) {
  return function (e, r) {
    if (!q._tasks[i]) return; // ignore multiple callbacks

    --q._active, ++q._ended;
    q._tasks[i] = null;
    if (q._error != null) return; // ignore secondary errors

    if (e != null) {
      abort(q, e);
    } else {
      q._data[i] = r;
      if (q._waiting) poke(q);else maybeNotify(q);
    }
  };
}

function abort(q, e) {
  var i = q._tasks.length,
      t;
  q._error = e; // ignore active callbacks

  q._data = undefined; // allow gc

  q._waiting = NaN; // prevent starting

  while (--i >= 0) {
    if (t = q._tasks[i]) {
      q._tasks[i] = null;

      if (t.abort) {
        try {
          t.abort();
        } catch (e) {
          /* ignore */
        }
      }
    }
  }

  q._active = NaN; // allow notification

  maybeNotify(q);
}

function maybeNotify(q) {
  if (!q._active && q._call) {
    var d = q._data;
    q._data = undefined; // allow gc

    q._call(q._error, d);
  }
}

function queue(concurrency) {
  if (concurrency == null) concurrency = Infinity;else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
  return new Queue(concurrency);
}

},{"./array":248}],250:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "randomBates", {
  enumerable: true,
  get: function () {
    return _bates.default;
  }
});
Object.defineProperty(exports, "randomExponential", {
  enumerable: true,
  get: function () {
    return _exponential.default;
  }
});
Object.defineProperty(exports, "randomIrwinHall", {
  enumerable: true,
  get: function () {
    return _irwinHall.default;
  }
});
Object.defineProperty(exports, "randomLogNormal", {
  enumerable: true,
  get: function () {
    return _logNormal.default;
  }
});
Object.defineProperty(exports, "randomNormal", {
  enumerable: true,
  get: function () {
    return _normal.default;
  }
});
Object.defineProperty(exports, "randomUniform", {
  enumerable: true,
  get: function () {
    return _uniform.default;
  }
});

var _uniform = _interopRequireDefault(require("./src/uniform"));

var _normal = _interopRequireDefault(require("./src/normal"));

var _logNormal = _interopRequireDefault(require("./src/logNormal"));

var _bates = _interopRequireDefault(require("./src/bates"));

var _irwinHall = _interopRequireDefault(require("./src/irwinHall"));

var _exponential = _interopRequireDefault(require("./src/exponential"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/bates":251,"./src/exponential":253,"./src/irwinHall":254,"./src/logNormal":255,"./src/normal":256,"./src/uniform":257}],251:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

var _irwinHall = _interopRequireDefault(require("./irwinHall"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = _irwinHall.default.source(source)(n);

    return function () {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;
  return randomBates;
}(_defaultSource.default);

exports.default = _default;

},{"./defaultSource":252,"./irwinHall":254}],252:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return Math.random();
}

},{}],253:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function () {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;
  return randomExponential;
}(_defaultSource.default);

exports.default = _default;

},{"./defaultSource":252}],254:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function () {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();

      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
}(_defaultSource.default);

exports.default = _default;

},{"./defaultSource":252}],255:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

var _normal = _interopRequireDefault(require("./normal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = _normal.default.source(source).apply(this, arguments);

    return function () {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
}(_defaultSource.default);

exports.default = _default;

},{"./defaultSource":252,"./normal":256}],256:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function () {
      var y; // If available, use the second previously-generated uniform random.

      if (x != null) y = x, x = null; // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);
      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;
  return randomNormal;
}(_defaultSource.default);

exports.default = _default;

},{"./defaultSource":252}],257:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;else max -= min;
    return function () {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;
  return randomUniform;
}(_defaultSource.default);

exports.default = _default;

},{"./defaultSource":252}],258:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "csv", {
  enumerable: true,
  get: function () {
    return _csv.default;
  }
});
Object.defineProperty(exports, "html", {
  enumerable: true,
  get: function () {
    return _html.default;
  }
});
Object.defineProperty(exports, "json", {
  enumerable: true,
  get: function () {
    return _json.default;
  }
});
Object.defineProperty(exports, "request", {
  enumerable: true,
  get: function () {
    return _request.default;
  }
});
Object.defineProperty(exports, "text", {
  enumerable: true,
  get: function () {
    return _text.default;
  }
});
Object.defineProperty(exports, "tsv", {
  enumerable: true,
  get: function () {
    return _tsv.default;
  }
});
Object.defineProperty(exports, "xml", {
  enumerable: true,
  get: function () {
    return _xml.default;
  }
});

var _request = _interopRequireDefault(require("./src/request"));

var _html = _interopRequireDefault(require("./src/html"));

var _json = _interopRequireDefault(require("./src/json"));

var _text = _interopRequireDefault(require("./src/text"));

var _xml = _interopRequireDefault(require("./src/xml"));

var _csv = _interopRequireDefault(require("./src/csv"));

var _tsv = _interopRequireDefault(require("./src/tsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/csv":259,"./src/html":261,"./src/json":262,"./src/request":263,"./src/text":264,"./src/tsv":265,"./src/xml":267}],259:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _d3Dsv = require("d3-dsv");

var _dsv = _interopRequireDefault(require("./dsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _dsv.default)("text/csv", _d3Dsv.csvParse);

exports.default = _default;

},{"./dsv":260,"d3-dsv":69}],260:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _request = _interopRequireDefault(require("./request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(defaultMimeType, parse) {
  return function (url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = (0, _request.default)(url).mimeType(defaultMimeType);

    r.row = function (_) {
      return arguments.length ? r.response(responseOf(parse, row = _)) : row;
    };

    r.row(row);
    return callback ? r.get(callback) : r;
  };
}

function responseOf(parse, row) {
  return function (request) {
    return parse(request.responseText, row);
  };
}

},{"./request":263}],261:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _type = _interopRequireDefault(require("./type"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _type.default)("text/html", function (xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
});

exports.default = _default;

},{"./type":266}],262:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _type = _interopRequireDefault(require("./type"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _type.default)("application/json", function (xhr) {
  return JSON.parse(xhr.responseText);
});

exports.default = _default;

},{"./type":266}],263:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Collection = require("d3-collection");

var _d3Dispatch = require("d3-dispatch");

function _default(url, callback) {
  var request,
      event = (0, _d3Dispatch.dispatch)("beforesend", "progress", "load", "error"),
      mimeType,
      headers = (0, _d3Collection.map)(),
      xhr = new XMLHttpRequest(),
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0; // If IE does not support CORS, use XDomainRequest.

  if (typeof XDomainRequest !== "undefined" && !("withCredentials" in xhr) && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest();
  "onload" in xhr ? xhr.onload = xhr.onerror = xhr.ontimeout = respond : xhr.onreadystatechange = function (o) {
    xhr.readyState > 3 && respond(o);
  };

  function respond(o) {
    var status = xhr.status,
        result;

    if (!status && hasResponse(xhr) || status >= 200 && status < 300 || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }

      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function (e) {
    event.call("progress", request, e);
  };

  request = {
    header: function (name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);else headers.set(name, value + "");
      return request;
    },
    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function (value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },
    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function (value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },
    timeout: function (value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },
    user: function (value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },
    password: function (value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },
    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function (value) {
      response = value;
      return request;
    },
    // Alias for send("GET", …).
    get: function (data, callback) {
      return request.send("GET", data, callback);
    },
    // Alias for send("POST", …).
    post: function (data, callback) {
      return request.send("POST", data, callback);
    },
    // If callback is non-null, it will be used for error and load events.
    send: function (method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function (xhr) {
        callback(null, xhr);
      });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },
    abort: function () {
      xhr.abort();
      return request;
    },
    on: function () {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
}

function fixCallback(callback) {
  return function (error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text" ? xhr.response // null on error
  : xhr.responseText; // "" on error
}

},{"d3-collection":48,"d3-dispatch":61}],264:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _type = _interopRequireDefault(require("./type"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _type.default)("text/plain", function (xhr) {
  return xhr.responseText;
});

exports.default = _default;

},{"./type":266}],265:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _d3Dsv = require("d3-dsv");

var _dsv = _interopRequireDefault(require("./dsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _dsv.default)("text/tab-separated-values", _d3Dsv.tsvParse);

exports.default = _default;

},{"./dsv":260,"d3-dsv":69}],266:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _request = _interopRequireDefault(require("./request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(defaultMimeType, response) {
  return function (url, callback) {
    var r = (0, _request.default)(url).mimeType(defaultMimeType).response(response);

    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }

    return r;
  };
}

},{"./request":263}],267:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _type = _interopRequireDefault(require("./type"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _type.default)("application/xml", function (xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
});

exports.default = _default;

},{"./type":266}],268:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "interpolateCool", {
  enumerable: true,
  get: function () {
    return _rainbow.cool;
  }
});
Object.defineProperty(exports, "interpolateCubehelixDefault", {
  enumerable: true,
  get: function () {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "interpolateInferno", {
  enumerable: true,
  get: function () {
    return _viridis.inferno;
  }
});
Object.defineProperty(exports, "interpolateMagma", {
  enumerable: true,
  get: function () {
    return _viridis.magma;
  }
});
Object.defineProperty(exports, "interpolatePlasma", {
  enumerable: true,
  get: function () {
    return _viridis.plasma;
  }
});
Object.defineProperty(exports, "interpolateRainbow", {
  enumerable: true,
  get: function () {
    return _rainbow.default;
  }
});
Object.defineProperty(exports, "interpolateViridis", {
  enumerable: true,
  get: function () {
    return _viridis.default;
  }
});
Object.defineProperty(exports, "interpolateWarm", {
  enumerable: true,
  get: function () {
    return _rainbow.warm;
  }
});
Object.defineProperty(exports, "scaleBand", {
  enumerable: true,
  get: function () {
    return _band.default;
  }
});
Object.defineProperty(exports, "scaleIdentity", {
  enumerable: true,
  get: function () {
    return _identity.default;
  }
});
Object.defineProperty(exports, "scaleImplicit", {
  enumerable: true,
  get: function () {
    return _ordinal.implicit;
  }
});
Object.defineProperty(exports, "scaleLinear", {
  enumerable: true,
  get: function () {
    return _linear.default;
  }
});
Object.defineProperty(exports, "scaleLog", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "scaleOrdinal", {
  enumerable: true,
  get: function () {
    return _ordinal.default;
  }
});
Object.defineProperty(exports, "scalePoint", {
  enumerable: true,
  get: function () {
    return _band.point;
  }
});
Object.defineProperty(exports, "scalePow", {
  enumerable: true,
  get: function () {
    return _pow.default;
  }
});
Object.defineProperty(exports, "scaleQuantile", {
  enumerable: true,
  get: function () {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "scaleQuantize", {
  enumerable: true,
  get: function () {
    return _quantize.default;
  }
});
Object.defineProperty(exports, "scaleSequential", {
  enumerable: true,
  get: function () {
    return _sequential.default;
  }
});
Object.defineProperty(exports, "scaleSqrt", {
  enumerable: true,
  get: function () {
    return _pow.sqrt;
  }
});
Object.defineProperty(exports, "scaleThreshold", {
  enumerable: true,
  get: function () {
    return _threshold.default;
  }
});
Object.defineProperty(exports, "scaleTime", {
  enumerable: true,
  get: function () {
    return _time.default;
  }
});
Object.defineProperty(exports, "scaleUtc", {
  enumerable: true,
  get: function () {
    return _utcTime.default;
  }
});
Object.defineProperty(exports, "schemeCategory10", {
  enumerable: true,
  get: function () {
    return _category.default;
  }
});
Object.defineProperty(exports, "schemeCategory20", {
  enumerable: true,
  get: function () {
    return _category2.default;
  }
});
Object.defineProperty(exports, "schemeCategory20b", {
  enumerable: true,
  get: function () {
    return _category20b.default;
  }
});
Object.defineProperty(exports, "schemeCategory20c", {
  enumerable: true,
  get: function () {
    return _category20c.default;
  }
});

var _band = _interopRequireWildcard(require("./src/band"));

var _identity = _interopRequireDefault(require("./src/identity"));

var _linear = _interopRequireDefault(require("./src/linear"));

var _log = _interopRequireDefault(require("./src/log"));

var _ordinal = _interopRequireWildcard(require("./src/ordinal"));

var _pow = _interopRequireWildcard(require("./src/pow"));

var _quantile = _interopRequireDefault(require("./src/quantile"));

var _quantize = _interopRequireDefault(require("./src/quantize"));

var _threshold = _interopRequireDefault(require("./src/threshold"));

var _time = _interopRequireDefault(require("./src/time"));

var _utcTime = _interopRequireDefault(require("./src/utcTime"));

var _category = _interopRequireDefault(require("./src/category10"));

var _category20b = _interopRequireDefault(require("./src/category20b"));

var _category20c = _interopRequireDefault(require("./src/category20c"));

var _category2 = _interopRequireDefault(require("./src/category20"));

var _cubehelix = _interopRequireDefault(require("./src/cubehelix"));

var _rainbow = _interopRequireWildcard(require("./src/rainbow"));

var _viridis = _interopRequireWildcard(require("./src/viridis"));

var _sequential = _interopRequireDefault(require("./src/sequential"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./src/band":270,"./src/category10":271,"./src/category20":272,"./src/category20b":273,"./src/category20c":274,"./src/cubehelix":278,"./src/identity":279,"./src/linear":280,"./src/log":281,"./src/ordinal":284,"./src/pow":285,"./src/quantile":286,"./src/quantize":287,"./src/rainbow":288,"./src/sequential":289,"./src/threshold":290,"./src/time":292,"./src/utcTime":293,"./src/viridis":294}],269:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = exports.map = void 0;
var array = Array.prototype;
var map = array.map;
exports.map = map;
var slice = array.slice;
exports.slice = slice;

},{}],270:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = band;
exports.point = point;

var _d3Array = require("d3-array");

var _ordinal = _interopRequireDefault(require("./ordinal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function band() {
  var scale = (0, _ordinal.default)().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;
  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = (0, _d3Array.range)(n).map(function (i) {
      return start + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function (_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function (_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function () {
    return bandwidth;
  };

  scale.step = function () {
    return step;
  };

  scale.round = function (_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function (_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function (_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function (_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function (_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function () {
    return band().domain(domain()).range(range).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function () {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

},{"./ordinal":284,"d3-array":1}],271:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _colors.default)("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

exports.default = _default;

},{"./colors":275}],272:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _colors.default)("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

exports.default = _default;

},{"./colors":275}],273:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _colors.default)("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

exports.default = _default;

},{"./colors":275}],274:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _colors.default)("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

exports.default = _default;

},{"./colors":275}],275:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(s) {
  return s.match(/.{6}/g).map(function (x) {
    return "#" + x;
  });
}

},{}],276:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],277:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.default = continuous;
exports.deinterpolateLinear = deinterpolateLinear;

var _d3Array = require("d3-array");

var _d3Interpolate = require("d3-interpolate");

var _array = require("./array");

var _constant = _interopRequireDefault(require("./constant"));

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= a = +a) ? function (x) {
    return (x - a) / b;
  } : (0, _constant.default)(b);
}

function deinterpolateClamp(deinterpolate) {
  return function (a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function (x) {
      return x <= a ? 0 : x >= b ? 1 : d(x);
    };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function (a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function (t) {
      return t <= 0 ? a : t >= 1 ? b : r(t);
    };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0],
      d1 = domain[1],
      r0 = range[0],
      r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function (x) {
    return r0(d0(x));
  };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1; // Reverse descending domains.

  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function (x) {
    var i = (0, _d3Array.bisect)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp());
} // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].


function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = _d3Interpolate.interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function (y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function (_) {
    return arguments.length ? (domain = _array.map.call(_, _number.default), rescale()) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = _array.slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function (_) {
    return range = _array.slice.call(_), interpolate = _d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function (_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}

},{"./array":269,"./constant":276,"./number":283,"d3-array":1,"d3-interpolate":201}],278:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _d3Color = require("d3-color");

var _d3Interpolate = require("d3-interpolate");

var _default = (0, _d3Interpolate.interpolateCubehelixLong)((0, _d3Color.cubehelix)(300, 0.5, 0.0), (0, _d3Color.cubehelix)(-240, 0.5, 1.0));

exports.default = _default;

},{"d3-color":55,"d3-interpolate":201}],279:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = identity;

var _array = require("./array");

var _linear = require("./linear");

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function (_) {
    return arguments.length ? (domain = _array.map.call(_, _number.default), scale) : domain.slice();
  };

  scale.copy = function () {
    return identity().domain(domain);
  };

  return (0, _linear.linearish)(scale);
}

},{"./array":269,"./linear":280,"./number":283}],280:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = linear;
exports.linearish = linearish;

var _d3Array = require("d3-array");

var _d3Interpolate = require("d3-interpolate");

var _continuous = _interopRequireWildcard(require("./continuous"));

var _tickFormat = _interopRequireDefault(require("./tickFormat"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function (count) {
    var d = domain();
    return (0, _d3Array.ticks)(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function (count, specifier) {
    return (0, _tickFormat.default)(domain(), count, specifier);
  };

  scale.nice = function (count) {
    if (count == null) count = 10;
    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = (0, _d3Array.tickIncrement)(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = (0, _d3Array.tickIncrement)(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = (0, _d3Array.tickIncrement)(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0, _continuous.default)(_continuous.deinterpolateLinear, _d3Interpolate.interpolateNumber);

  scale.copy = function () {
    return (0, _continuous.copy)(scale, linear());
  };

  return linearish(scale);
}

},{"./continuous":277,"./tickFormat":291,"d3-array":1,"d3-interpolate":201}],281:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = log;

var _d3Array = require("d3-array");

var _d3Format = require("d3-format");

var _constant = _interopRequireDefault(require("./constant"));

var _nice = _interopRequireDefault(require("./nice"));

var _continuous = _interopRequireWildcard(require("./continuous"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function deinterpolate(a, b) {
  return (b = Math.log(b / a)) ? function (x) {
    return Math.log(x / a) / b;
  } : (0, _constant.default)(b);
}

function reinterpolate(a, b) {
  return a < 0 ? function (t) {
    return -Math.pow(-b, t) * Math.pow(-a, 1 - t);
  } : function (t) {
    return Math.pow(b, t) * Math.pow(a, 1 - t);
  };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
    return Math.pow(base, x);
  };
}

function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
    return Math.log(x) / base;
  });
}

function reflect(f) {
  return function (x) {
    return -f(-x);
  };
}

function log() {
  var scale = (0, _continuous.default)(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function (_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function (count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;
    if (r = v < u) i = u, u = v, v = i;
    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = (0, _d3Array.ticks)(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function (count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = (0, _d3Format.format)(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?

    return function (d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function () {
    return domain((0, _nice.default)(domain(), {
      floor: function (x) {
        return pows(Math.floor(logs(x)));
      },
      ceil: function (x) {
        return pows(Math.ceil(logs(x)));
      }
    }));
  };

  scale.copy = function () {
    return (0, _continuous.copy)(scale, log().base(base));
  };

  return scale;
}

},{"./constant":276,"./continuous":277,"./nice":282,"d3-array":1,"d3-format":96}],282:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(domain, interval) {
  domain = domain.slice();
  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

},{}],283:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return +x;
}

},{}],284:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ordinal;
exports.implicit = void 0;

var _d3Collection = require("d3-collection");

var _array = require("./array");

var implicit = {
  name: "implicit"
};
exports.implicit = implicit;

function ordinal(range) {
  var index = (0, _d3Collection.map)(),
      domain = [],
      unknown = implicit;
  range = range == null ? [] : _array.slice.call(range);

  function scale(d) {
    var key = d + "",
        i = index.get(key);

    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }

    return range[(i - 1) % range.length];
  }

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = (0, _d3Collection.map)();
    var i = -1,
        n = _.length,
        d,
        key;

    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));

    return scale;
  };

  scale.range = function (_) {
    return arguments.length ? (range = _array.slice.call(_), scale) : range.slice();
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function () {
    return ordinal().domain(domain).range(range).unknown(unknown);
  };

  return scale;
}

},{"./array":269,"d3-collection":48}],285:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pow;
exports.sqrt = sqrt;

var _constant = _interopRequireDefault(require("./constant"));

var _linear = require("./linear");

var _continuous = _interopRequireWildcard(require("./continuous"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = (0, _continuous.default)(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent))) ? function (x) {
      return (raise(x, exponent) - a) / b;
    } : (0, _constant.default)(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function (t) {
      return raise(a + b * t, 1 / exponent);
    };
  }

  scale.exponent = function (_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function () {
    return (0, _continuous.copy)(scale, pow().exponent(exponent));
  };

  return (0, _linear.linearish)(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

},{"./constant":276,"./continuous":277,"./linear":280}],286:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quantile;

var _d3Array = require("d3-array");

var _array = require("./array");

function quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0,
        n = Math.max(1, range.length);
    thresholds = new Array(n - 1);

    while (++i < n) thresholds[i - 1] = (0, _d3Array.quantile)(domain, i / n);

    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[(0, _d3Array.bisect)(thresholds, x)];
  }

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
  };

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [];

    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);

    domain.sort(_d3Array.ascending);
    return rescale();
  };

  scale.range = function (_) {
    return arguments.length ? (range = _array.slice.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function () {
    return thresholds.slice();
  };

  scale.copy = function () {
    return quantile().domain(domain).range(range);
  };

  return scale;
}

},{"./array":269,"d3-array":1}],287:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quantize;

var _d3Array = require("d3-array");

var _array = require("./array");

var _linear = require("./linear");

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[(0, _d3Array.bisect)(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);

    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);

    return scale;
  }

  scale.domain = function (_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function (_) {
    return arguments.length ? (n = (range = _array.slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };

  scale.copy = function () {
    return quantize().domain([x0, x1]).range(range);
  };

  return (0, _linear.linearish)(scale);
}

},{"./array":269,"./linear":280,"d3-array":1}],288:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cool = void 0;
exports.default = _default;
exports.warm = void 0;

var _d3Color = require("d3-color");

var _d3Interpolate = require("d3-interpolate");

var warm = (0, _d3Interpolate.interpolateCubehelixLong)((0, _d3Color.cubehelix)(-100, 0.75, 0.35), (0, _d3Color.cubehelix)(80, 1.50, 0.8));
exports.warm = warm;
var cool = (0, _d3Interpolate.interpolateCubehelixLong)((0, _d3Color.cubehelix)(260, 0.75, 0.35), (0, _d3Color.cubehelix)(80, 1.50, 0.8));
exports.cool = cool;
var rainbow = (0, _d3Color.cubehelix)();

function _default(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
}

},{"d3-color":55,"d3-interpolate":201}],289:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sequential;

var _linear = require("./linear");

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function (_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function () {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return (0, _linear.linearish)(scale);
}

},{"./linear":280}],290:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = threshold;

var _d3Array = require("d3-array");

var _array = require("./array");

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[(0, _d3Array.bisect)(domain, x, 0, n)];
  }

  scale.domain = function (_) {
    return arguments.length ? (domain = _array.slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = _array.slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function () {
    return threshold().domain(domain).range(range);
  };

  return scale;
}

},{"./array":269,"d3-array":1}],291:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Array = require("d3-array");

var _d3Format = require("d3-format");

function _default(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = (0, _d3Array.tickStep)(start, stop, count == null ? 10 : count),
      precision;
  specifier = (0, _d3Format.formatSpecifier)(specifier == null ? ",f" : specifier);

  switch (specifier.type) {
    case "s":
      {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionPrefix)(step, value))) specifier.precision = precision;
        return (0, _d3Format.formatPrefix)(specifier, value);
      }

    case "":
    case "e":
    case "g":
    case "p":
    case "r":
      {
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionRound)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }

    case "f":
    case "%":
      {
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionFixed)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
  }

  return (0, _d3Format.format)(specifier);
}

},{"d3-array":1,"d3-format":96}],292:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calendar = calendar;
exports.default = _default;

var _d3Array = require("d3-array");

var _d3Interpolate = require("d3-interpolate");

var _d3Time = require("d3-time");

var _d3TimeFormat = require("d3-time-format");

var _array = require("./array");

var _continuous = _interopRequireWildcard(require("./continuous"));

var _nice = _interopRequireDefault(require("./nice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = (0, _continuous.default)(_continuous.deinterpolateLinear, _d3Interpolate.interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;
  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");
  var tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 3, 3 * durationHour], [hour, 6, 6 * durationHour], [hour, 12, 12 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10; // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.

    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = (0, _d3Array.bisector)(function (i) {
        return i[2];
      }).right(tickIntervals, target);

      if (i === tickIntervals.length) {
        step = (0, _d3Array.tickStep)(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max((0, _d3Array.tickStep)(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function (y) {
    return new Date(invert(y));
  };

  scale.domain = function (_) {
    return arguments.length ? domain(_array.map.call(_, number)) : domain().map(date);
  };

  scale.ticks = function (interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop

    return r ? t.reverse() : t;
  };

  scale.tickFormat = function (count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function (interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain((0, _nice.default)(d, interval)) : scale;
  };

  scale.copy = function () {
    return (0, _continuous.copy)(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function _default() {
  return calendar(_d3Time.timeYear, _d3Time.timeMonth, _d3Time.timeWeek, _d3Time.timeDay, _d3Time.timeHour, _d3Time.timeMinute, _d3Time.timeSecond, _d3Time.timeMillisecond, _d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
}

},{"./array":269,"./continuous":277,"./nice":282,"d3-array":1,"d3-interpolate":201,"d3-time":350,"d3-time-format":345}],293:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _time = require("./time");

var _d3TimeFormat = require("d3-time-format");

var _d3Time = require("d3-time");

function _default() {
  return (0, _time.calendar)(_d3Time.utcYear, _d3Time.utcMonth, _d3Time.utcWeek, _d3Time.utcDay, _d3Time.utcHour, _d3Time.utcMinute, _d3Time.utcSecond, _d3Time.utcMillisecond, _d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
}

},{"./time":292,"d3-time":350,"d3-time-format":345}],294:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plasma = exports.magma = exports.inferno = exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ramp(range) {
  var n = range.length;
  return function (t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var _default = ramp((0, _colors.default)("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

exports.default = _default;
var magma = ramp((0, _colors.default)("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
exports.magma = magma;
var inferno = ramp((0, _colors.default)("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
exports.inferno = inferno;
var plasma = ramp((0, _colors.default)("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
exports.plasma = plasma;

},{"./colors":275}],295:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "clientPoint", {
  enumerable: true,
  get: function () {
    return _point.default;
  }
});
Object.defineProperty(exports, "create", {
  enumerable: true,
  get: function () {
    return _create.default;
  }
});
Object.defineProperty(exports, "creator", {
  enumerable: true,
  get: function () {
    return _creator.default;
  }
});
Object.defineProperty(exports, "customEvent", {
  enumerable: true,
  get: function () {
    return _on.customEvent;
  }
});
Object.defineProperty(exports, "event", {
  enumerable: true,
  get: function () {
    return _on.event;
  }
});
Object.defineProperty(exports, "local", {
  enumerable: true,
  get: function () {
    return _local.default;
  }
});
Object.defineProperty(exports, "matcher", {
  enumerable: true,
  get: function () {
    return _matcher.default;
  }
});
Object.defineProperty(exports, "mouse", {
  enumerable: true,
  get: function () {
    return _mouse.default;
  }
});
Object.defineProperty(exports, "namespace", {
  enumerable: true,
  get: function () {
    return _namespace.default;
  }
});
Object.defineProperty(exports, "namespaces", {
  enumerable: true,
  get: function () {
    return _namespaces.default;
  }
});
Object.defineProperty(exports, "select", {
  enumerable: true,
  get: function () {
    return _select.default;
  }
});
Object.defineProperty(exports, "selectAll", {
  enumerable: true,
  get: function () {
    return _selectAll.default;
  }
});
Object.defineProperty(exports, "selection", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
Object.defineProperty(exports, "selector", {
  enumerable: true,
  get: function () {
    return _selector.default;
  }
});
Object.defineProperty(exports, "selectorAll", {
  enumerable: true,
  get: function () {
    return _selectorAll.default;
  }
});
Object.defineProperty(exports, "style", {
  enumerable: true,
  get: function () {
    return _style.styleValue;
  }
});
Object.defineProperty(exports, "touch", {
  enumerable: true,
  get: function () {
    return _touch.default;
  }
});
Object.defineProperty(exports, "touches", {
  enumerable: true,
  get: function () {
    return _touches.default;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _window.default;
  }
});

var _create = _interopRequireDefault(require("./src/create"));

var _creator = _interopRequireDefault(require("./src/creator"));

var _local = _interopRequireDefault(require("./src/local"));

var _matcher = _interopRequireDefault(require("./src/matcher"));

var _mouse = _interopRequireDefault(require("./src/mouse"));

var _namespace = _interopRequireDefault(require("./src/namespace"));

var _namespaces = _interopRequireDefault(require("./src/namespaces"));

var _point = _interopRequireDefault(require("./src/point"));

var _select = _interopRequireDefault(require("./src/select"));

var _selectAll = _interopRequireDefault(require("./src/selectAll"));

var _index = _interopRequireDefault(require("./src/selection/index"));

var _selector = _interopRequireDefault(require("./src/selector"));

var _selectorAll = _interopRequireDefault(require("./src/selectorAll"));

var _style = require("./src/selection/style");

var _touch = _interopRequireDefault(require("./src/touch"));

var _touches = _interopRequireDefault(require("./src/touches"));

var _window = _interopRequireDefault(require("./src/window"));

var _on = require("./src/selection/on");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/create":297,"./src/creator":298,"./src/local":299,"./src/matcher":300,"./src/mouse":301,"./src/namespace":302,"./src/namespaces":303,"./src/point":304,"./src/select":305,"./src/selectAll":306,"./src/selection/index":321,"./src/selection/on":327,"./src/selection/style":337,"./src/selector":339,"./src/selectorAll":340,"./src/touch":342,"./src/touches":343,"./src/window":344}],296:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],297:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _creator = _interopRequireDefault(require("./creator"));

var _select = _interopRequireDefault(require("./select"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(name) {
  return (0, _select.default)((0, _creator.default)(name).call(document.documentElement));
}

},{"./creator":298,"./select":305}],298:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _namespace = _interopRequireDefault(require("./namespace"));

var _namespaces = require("./namespaces");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function creatorInherit(name) {
  return function () {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces.xhtml && document.documentElement.namespaceURI === _namespaces.xhtml ? document.createElement(name) : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function () {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function _default(name) {
  var fullname = (0, _namespace.default)(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

},{"./namespace":302,"./namespaces":303}],299:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = local;
var nextId = 0;

function local() {
  return new Local();
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function (node) {
    var id = this._;

    while (!(id in node)) if (!(node = node.parentNode)) return;

    return node[id];
  },
  set: function (node, value) {
    return node[this._] = value;
  },
  remove: function (node) {
    return this._ in node && delete node[this._];
  },
  toString: function () {
    return this._;
  }
};

},{}],300:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var matcher = function (selector) {
  return function () {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;

    matcher = function (selector) {
      return function () {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var _default = matcher;
exports.default = _default;

},{}],301:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _sourceEvent = _interopRequireDefault(require("./sourceEvent"));

var _point = _interopRequireDefault(require("./point"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(node) {
  var event = (0, _sourceEvent.default)();
  if (event.changedTouches) event = event.changedTouches[0];
  return (0, _point.default)(node, event);
}

},{"./point":304,"./sourceEvent":341}],302:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _namespaces = _interopRequireDefault(require("./namespaces"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(name) {
  var prefix = name += "",
      i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces.default.hasOwnProperty(prefix) ? {
    space: _namespaces.default[prefix],
    local: name
  } : name;
}

},{"./namespaces":303}],303:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.xhtml = exports.default = void 0;
var xhtml = "http://www.w3.org/1999/xhtml";
exports.xhtml = xhtml;
var _default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
exports.default = _default;

},{}],304:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

},{}],305:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./selection/index");

function _default(selector) {
  return typeof selector === "string" ? new _index.Selection([[document.querySelector(selector)]], [document.documentElement]) : new _index.Selection([[selector]], _index.root);
}

},{"./selection/index":321}],306:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./selection/index");

function _default(selector) {
  return typeof selector === "string" ? new _index.Selection([document.querySelectorAll(selector)], [document.documentElement]) : new _index.Selection([selector == null ? [] : selector], _index.root);
}

},{"./selection/index":321}],307:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _creator = _interopRequireDefault(require("../creator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(name) {
  var create = typeof name === "function" ? name : (0, _creator.default)(name);
  return this.select(function () {
    return this.appendChild(create.apply(this, arguments));
  });
}

},{"../creator":298}],308:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _namespace = _interopRequireDefault(require("../namespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function () {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function () {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function _default(name, value) {
  var fullname = (0, _namespace.default)(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }

  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

},{"../namespace":302}],309:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

},{}],310:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function (name) {
    var i = this._names.indexOf(name);

    if (i < 0) {
      this._names.push(name);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function (name) {
    var i = this._names.indexOf(name);

    if (i >= 0) {
      this._names.splice(i, 1);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function (name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function () {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function () {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function () {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function _default(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()),
        i = -1,
        n = names.length;

    while (++i < n) if (!list.contains(names[i])) return false;

    return true;
  }

  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

},{}],311:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function _default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

},{}],312:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _enter = require("./enter");

var _constant = _interopRequireDefault(require("../constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length; // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.

  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter.EnterNode(parent, data[i]);
    }
  } // Put any non-null nodes that don’t fit into exit.


  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue; // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.

  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);

      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  } // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.


  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);

    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter.EnterNode(parent, data[i]);
    }
  } // Add any remaining nodes that were not bound to data to exit.


  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}

function _default(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function (d) {
      data[++j] = d;
    });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;
  if (typeof value !== "function") value = (0, _constant.default)(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.

    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;

        while (!(next = updateGroup[i1]) && ++i1 < dataLength);

        previous._next = next || null;
      }
    }
  }

  update = new _index.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

},{"../constant":296,"./enter":317,"./index":321}],313:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

},{}],314:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _window = _interopRequireDefault(require("../window"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function dispatchEvent(node, type, params) {
  var window = (0, _window.default)(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function () {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function () {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function _default(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

},{"../window":344}],315:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

},{}],316:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return !this.node();
}

},{}],317:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnterNode = EnterNode;
exports.default = _default;

var _sparse = _interopRequireDefault(require("./sparse"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  return new _index.Selection(this._enter || this._groups.map(_sparse.default), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function (child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function (child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function (selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function (selector) {
    return this._parent.querySelectorAll(selector);
  }
};

},{"./index":321,"./sparse":336}],318:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _sparse = _interopRequireDefault(require("./sparse"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  return new _index.Selection(this._exit || this._groups.map(_sparse.default), this._parents);
}

},{"./index":321,"./sparse":336}],319:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _matcher = _interopRequireDefault(require("../matcher"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(match) {
  if (typeof match !== "function") match = (0, _matcher.default)(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index.Selection(subgroups, this._parents);
}

},{"../matcher":300,"./index":321}],320:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function () {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function _default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

},{}],321:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Selection = Selection;
exports.root = exports.default = void 0;

var _select = _interopRequireDefault(require("./select"));

var _selectAll = _interopRequireDefault(require("./selectAll"));

var _filter = _interopRequireDefault(require("./filter"));

var _data = _interopRequireDefault(require("./data"));

var _enter = _interopRequireDefault(require("./enter"));

var _exit = _interopRequireDefault(require("./exit"));

var _merge = _interopRequireDefault(require("./merge"));

var _order = _interopRequireDefault(require("./order"));

var _sort = _interopRequireDefault(require("./sort"));

var _call = _interopRequireDefault(require("./call"));

var _nodes = _interopRequireDefault(require("./nodes"));

var _node = _interopRequireDefault(require("./node"));

var _size = _interopRequireDefault(require("./size"));

var _empty = _interopRequireDefault(require("./empty"));

var _each = _interopRequireDefault(require("./each"));

var _attr = _interopRequireDefault(require("./attr"));

var _style = _interopRequireDefault(require("./style"));

var _property = _interopRequireDefault(require("./property"));

var _classed = _interopRequireDefault(require("./classed"));

var _text = _interopRequireDefault(require("./text"));

var _html = _interopRequireDefault(require("./html"));

var _raise = _interopRequireDefault(require("./raise"));

var _lower = _interopRequireDefault(require("./lower"));

var _append = _interopRequireDefault(require("./append"));

var _insert = _interopRequireDefault(require("./insert"));

var _remove = _interopRequireDefault(require("./remove"));

var _clone = _interopRequireDefault(require("./clone"));

var _datum = _interopRequireDefault(require("./datum"));

var _on = _interopRequireDefault(require("./on"));

var _dispatch = _interopRequireDefault(require("./dispatch"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var root = [null];
exports.root = root;

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select.default,
  selectAll: _selectAll.default,
  filter: _filter.default,
  data: _data.default,
  enter: _enter.default,
  exit: _exit.default,
  merge: _merge.default,
  order: _order.default,
  sort: _sort.default,
  call: _call.default,
  nodes: _nodes.default,
  node: _node.default,
  size: _size.default,
  empty: _empty.default,
  each: _each.default,
  attr: _attr.default,
  style: _style.default,
  property: _property.default,
  classed: _classed.default,
  text: _text.default,
  html: _html.default,
  raise: _raise.default,
  lower: _lower.default,
  append: _append.default,
  insert: _insert.default,
  remove: _remove.default,
  clone: _clone.default,
  datum: _datum.default,
  on: _on.default,
  dispatch: _dispatch.default
};
var _default = selection;
exports.default = _default;

},{"./append":307,"./attr":308,"./call":309,"./classed":310,"./clone":311,"./data":312,"./datum":313,"./dispatch":314,"./each":315,"./empty":316,"./enter":317,"./exit":318,"./filter":319,"./html":320,"./insert":322,"./lower":323,"./merge":324,"./node":325,"./nodes":326,"./on":327,"./order":328,"./property":329,"./raise":330,"./remove":331,"./select":332,"./selectAll":333,"./size":334,"./sort":335,"./style":337,"./text":338}],322:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _creator = _interopRequireDefault(require("../creator"));

var _selector = _interopRequireDefault(require("../selector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function constantNull() {
  return null;
}

function _default(name, before) {
  var create = typeof name === "function" ? name : (0, _creator.default)(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0, _selector.default)(before);
  return this.select(function () {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

},{"../creator":298,"../selector":339}],323:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function _default() {
  return this.each(lower);
}

},{}],324:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

function _default(selection) {
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index.Selection(merges, this._parents);
}

},{"./index":321}],325:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

},{}],326:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var nodes = new Array(this.size()),
      i = -1;
  this.each(function () {
    nodes[++i] = this;
  });
  return nodes;
}

},{}],327:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.customEvent = customEvent;
exports.default = _default;
exports.event = void 0;
var filterEvents = {};
var event = null;
exports.event = event;

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!("onmouseenter" in element)) {
    filterEvents = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    };
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function (event) {
    var related = event.relatedTarget;

    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function (event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).

    exports.event = event = event1;

    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {
      type: t,
      name: name
    };
  });
}

function onRemove(typename) {
  return function () {
    var on = this.__on;
    if (!on) return;

    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }

    if (++i) on.length = i;else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function (d, i, group) {
    var on = this.__on,
        o,
        listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {
      type: typename.type,
      name: typename.name,
      value: value,
      listener: listener,
      capture: capture
    };
    if (!on) this.__on = [o];else on.push(o);
  };
}

function _default(typename, value, capture) {
  var typenames = parseTypenames(typename + ""),
      i,
      n = typenames.length,
      t;

  if (arguments.length < 2) {
    var on = this.node().__on;

    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;

  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));

  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  exports.event = event = event1;

  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event = event0;
  }
}

},{}],328:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

},{}],329:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function propertyRemove(name) {
  return function () {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function () {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];else this[name] = v;
  };
}

function _default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

},{}],330:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function _default() {
  return this.each(raise);
}

},{}],331:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function _default() {
  return this.each(remove);
}

},{}],332:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _selector = _interopRequireDefault(require("../selector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(select) {
  if (typeof select !== "function") select = (0, _selector.default)(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index.Selection(subgroups, this._parents);
}

},{"../selector":339,"./index":321}],333:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _selectorAll = _interopRequireDefault(require("../selectorAll"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(select) {
  if (typeof select !== "function") select = (0, _selectorAll.default)(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index.Selection(subgroups, parents);
}

},{"../selectorAll":340,"./index":321}],334:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var size = 0;
  this.each(function () {
    ++size;
  });
  return size;
}

},{}],335:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

function _default(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }

    sortgroup.sort(compareNode);
  }

  return new _index.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

},{"./index":321}],336:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(update) {
  return new Array(update.length);
}

},{}],337:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.styleValue = styleValue;

var _window = _interopRequireDefault(require("../window"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function () {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
  };
}

function _default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name) || (0, _window.default)(node).getComputedStyle(node, null).getPropertyValue(name);
}

},{"../window":344}],338:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function _default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

},{}],339:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function none() {}

function _default(selector) {
  return selector == null ? none : function () {
    return this.querySelector(selector);
  };
}

},{}],340:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function empty() {
  return [];
}

function _default(selector) {
  return selector == null ? empty : function () {
    return this.querySelectorAll(selector);
  };
}

},{}],341:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _on = require("./selection/on");

function _default() {
  var current = _on.event,
      source;

  while (source = current.sourceEvent) current = source;

  return current;
}

},{"./selection/on":327}],342:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _sourceEvent = _interopRequireDefault(require("./sourceEvent"));

var _point = _interopRequireDefault(require("./point"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = (0, _sourceEvent.default)().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return (0, _point.default)(node, touch);
    }
  }

  return null;
}

},{"./point":304,"./sourceEvent":341}],343:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _sourceEvent = _interopRequireDefault(require("./sourceEvent"));

var _point = _interopRequireDefault(require("./point"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(node, touches) {
  if (touches == null) touches = (0, _sourceEvent.default)().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = (0, _point.default)(node, touches[i]);
  }

  return points;
}

},{"./point":304,"./sourceEvent":341}],344:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView // node is a Node
  || node.document && node // node is a Window
  || node.defaultView; // node is a Document
}

},{}],345:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isoFormat", {
  enumerable: true,
  get: function () {
    return _isoFormat.default;
  }
});
Object.defineProperty(exports, "isoParse", {
  enumerable: true,
  get: function () {
    return _isoParse.default;
  }
});
Object.defineProperty(exports, "timeFormat", {
  enumerable: true,
  get: function () {
    return _defaultLocale.timeFormat;
  }
});
Object.defineProperty(exports, "timeFormatDefaultLocale", {
  enumerable: true,
  get: function () {
    return _defaultLocale.default;
  }
});
Object.defineProperty(exports, "timeFormatLocale", {
  enumerable: true,
  get: function () {
    return _locale.default;
  }
});
Object.defineProperty(exports, "timeParse", {
  enumerable: true,
  get: function () {
    return _defaultLocale.timeParse;
  }
});
Object.defineProperty(exports, "utcFormat", {
  enumerable: true,
  get: function () {
    return _defaultLocale.utcFormat;
  }
});
Object.defineProperty(exports, "utcParse", {
  enumerable: true,
  get: function () {
    return _defaultLocale.utcParse;
  }
});

var _defaultLocale = _interopRequireWildcard(require("./src/defaultLocale"));

var _locale = _interopRequireDefault(require("./src/locale"));

var _isoFormat = _interopRequireDefault(require("./src/isoFormat"));

var _isoParse = _interopRequireDefault(require("./src/isoParse"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./src/defaultLocale":346,"./src/isoFormat":347,"./src/isoParse":348,"./src/locale":349}],346:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultLocale;
exports.utcParse = exports.utcFormat = exports.timeParse = exports.timeFormat = void 0;

var _locale = _interopRequireDefault(require("./locale"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var locale;
var timeFormat;
exports.timeFormat = timeFormat;
var timeParse;
exports.timeParse = timeParse;
var utcFormat;
exports.utcFormat = utcFormat;
var utcParse;
exports.utcParse = utcParse;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = (0, _locale.default)(definition);
  exports.timeFormat = timeFormat = locale.format;
  exports.timeParse = timeParse = locale.parse;
  exports.utcFormat = utcFormat = locale.utcFormat;
  exports.utcParse = utcParse = locale.utcParse;
  return locale;
}

},{"./locale":349}],347:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isoSpecifier = exports.default = void 0;

var _defaultLocale = require("./defaultLocale");

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
exports.isoSpecifier = isoSpecifier;

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString ? formatIsoNative : (0, _defaultLocale.utcFormat)(isoSpecifier);
var _default = formatIso;
exports.default = _default;

},{"./defaultLocale":346}],348:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isoFormat = require("./isoFormat");

var _defaultLocale = require("./defaultLocale");

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : (0, _defaultLocale.utcParse)(_isoFormat.isoSpecifier);
var _default = parseIso;
exports.default = _default;

},{"./defaultLocale":346,"./isoFormat":347}],349:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatLocale;

var _d3Time = require("d3-time");

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }

  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }

  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {
    y: y,
    m: 0,
    d: 1,
    H: 0,
    M: 0,
    S: 0,
    L: 0
  };
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;
  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  }; // These recursive directive definitions must be deferred.

  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function (date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;
      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function (string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week,
          day;
      if (i != string.length) return null; // If a UNIX timestamp is specified, return it.

      if ("Q" in d) return new Date(d.Q); // The am-pm flag is 0 for AM, and 1 for PM.

      if ("p" in d) d.H = d.H % 12 + d.p * 12; // Convert day-of-week and week-of-year to day-of-year.

      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;

        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? _d3Time.utcMonday.ceil(week) : (0, _d3Time.utcMonday)(week);
          week = _d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? _d3Time.timeMonday.ceil(week) : (0, _d3Time.timeMonday)(week);
          week = _d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      } // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.


      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      } // Otherwise, all fields are in local time.


      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);

      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function (specifier) {
      var f = newFormat(specifier += "", formats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    parse: function (specifier) {
      var p = newParse(specifier += "", localDate);

      p.toString = function () {
        return specifier;
      };

      return p;
    },
    utcFormat: function (specifier) {
      var f = newFormat(specifier += "", utcFormats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    utcParse: function (specifier) {
      var p = newParse(specifier, utcDate);

      p.toString = function () {
        return specifier;
      };

      return p;
    }
  };
}

var pads = {
  "-": "",
  "_": " ",
  "0": "0"
},
    numberRe = /^\s*\d+/,
    // note: ignores next directive
percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {},
      i = -1,
      n = names.length;

  while (++i < n) map[names[i].toLowerCase()] = i;

  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0] * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + _d3Time.timeDay.count((0, _d3Time.timeYear)(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(_d3Time.timeSunday.count((0, _d3Time.timeYear)(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? (0, _d3Time.timeThursday)(d) : _d3Time.timeThursday.ceil(d);
  return pad(_d3Time.timeThursday.count((0, _d3Time.timeYear)(d), d) + ((0, _d3Time.timeYear)(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(_d3Time.timeMonday.count((0, _d3Time.timeYear)(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + _d3Time.utcDay.count((0, _d3Time.utcYear)(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(_d3Time.utcSunday.count((0, _d3Time.utcYear)(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? (0, _d3Time.utcThursday)(d) : _d3Time.utcThursday.ceil(d);
  return pad(_d3Time.utcThursday.count((0, _d3Time.utcYear)(d), d) + ((0, _d3Time.utcYear)(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(_d3Time.utcMonday.count((0, _d3Time.utcYear)(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

},{"d3-time":350}],350:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "timeDay", {
  enumerable: true,
  get: function () {
    return _day.default;
  }
});
Object.defineProperty(exports, "timeDays", {
  enumerable: true,
  get: function () {
    return _day.days;
  }
});
Object.defineProperty(exports, "timeFriday", {
  enumerable: true,
  get: function () {
    return _week.friday;
  }
});
Object.defineProperty(exports, "timeFridays", {
  enumerable: true,
  get: function () {
    return _week.fridays;
  }
});
Object.defineProperty(exports, "timeHour", {
  enumerable: true,
  get: function () {
    return _hour.default;
  }
});
Object.defineProperty(exports, "timeHours", {
  enumerable: true,
  get: function () {
    return _hour.hours;
  }
});
Object.defineProperty(exports, "timeInterval", {
  enumerable: true,
  get: function () {
    return _interval.default;
  }
});
Object.defineProperty(exports, "timeMillisecond", {
  enumerable: true,
  get: function () {
    return _millisecond.default;
  }
});
Object.defineProperty(exports, "timeMilliseconds", {
  enumerable: true,
  get: function () {
    return _millisecond.milliseconds;
  }
});
Object.defineProperty(exports, "timeMinute", {
  enumerable: true,
  get: function () {
    return _minute.default;
  }
});
Object.defineProperty(exports, "timeMinutes", {
  enumerable: true,
  get: function () {
    return _minute.minutes;
  }
});
Object.defineProperty(exports, "timeMonday", {
  enumerable: true,
  get: function () {
    return _week.monday;
  }
});
Object.defineProperty(exports, "timeMondays", {
  enumerable: true,
  get: function () {
    return _week.mondays;
  }
});
Object.defineProperty(exports, "timeMonth", {
  enumerable: true,
  get: function () {
    return _month.default;
  }
});
Object.defineProperty(exports, "timeMonths", {
  enumerable: true,
  get: function () {
    return _month.months;
  }
});
Object.defineProperty(exports, "timeSaturday", {
  enumerable: true,
  get: function () {
    return _week.saturday;
  }
});
Object.defineProperty(exports, "timeSaturdays", {
  enumerable: true,
  get: function () {
    return _week.saturdays;
  }
});
Object.defineProperty(exports, "timeSecond", {
  enumerable: true,
  get: function () {
    return _second.default;
  }
});
Object.defineProperty(exports, "timeSeconds", {
  enumerable: true,
  get: function () {
    return _second.seconds;
  }
});
Object.defineProperty(exports, "timeSunday", {
  enumerable: true,
  get: function () {
    return _week.sunday;
  }
});
Object.defineProperty(exports, "timeSundays", {
  enumerable: true,
  get: function () {
    return _week.sundays;
  }
});
Object.defineProperty(exports, "timeThursday", {
  enumerable: true,
  get: function () {
    return _week.thursday;
  }
});
Object.defineProperty(exports, "timeThursdays", {
  enumerable: true,
  get: function () {
    return _week.thursdays;
  }
});
Object.defineProperty(exports, "timeTuesday", {
  enumerable: true,
  get: function () {
    return _week.tuesday;
  }
});
Object.defineProperty(exports, "timeTuesdays", {
  enumerable: true,
  get: function () {
    return _week.tuesdays;
  }
});
Object.defineProperty(exports, "timeWednesday", {
  enumerable: true,
  get: function () {
    return _week.wednesday;
  }
});
Object.defineProperty(exports, "timeWednesdays", {
  enumerable: true,
  get: function () {
    return _week.wednesdays;
  }
});
Object.defineProperty(exports, "timeWeek", {
  enumerable: true,
  get: function () {
    return _week.sunday;
  }
});
Object.defineProperty(exports, "timeWeeks", {
  enumerable: true,
  get: function () {
    return _week.sundays;
  }
});
Object.defineProperty(exports, "timeYear", {
  enumerable: true,
  get: function () {
    return _year.default;
  }
});
Object.defineProperty(exports, "timeYears", {
  enumerable: true,
  get: function () {
    return _year.years;
  }
});
Object.defineProperty(exports, "utcDay", {
  enumerable: true,
  get: function () {
    return _utcDay.default;
  }
});
Object.defineProperty(exports, "utcDays", {
  enumerable: true,
  get: function () {
    return _utcDay.utcDays;
  }
});
Object.defineProperty(exports, "utcFriday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcFriday;
  }
});
Object.defineProperty(exports, "utcFridays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcFridays;
  }
});
Object.defineProperty(exports, "utcHour", {
  enumerable: true,
  get: function () {
    return _utcHour.default;
  }
});
Object.defineProperty(exports, "utcHours", {
  enumerable: true,
  get: function () {
    return _utcHour.utcHours;
  }
});
Object.defineProperty(exports, "utcMillisecond", {
  enumerable: true,
  get: function () {
    return _millisecond.default;
  }
});
Object.defineProperty(exports, "utcMilliseconds", {
  enumerable: true,
  get: function () {
    return _millisecond.milliseconds;
  }
});
Object.defineProperty(exports, "utcMinute", {
  enumerable: true,
  get: function () {
    return _utcMinute.default;
  }
});
Object.defineProperty(exports, "utcMinutes", {
  enumerable: true,
  get: function () {
    return _utcMinute.utcMinutes;
  }
});
Object.defineProperty(exports, "utcMonday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcMonday;
  }
});
Object.defineProperty(exports, "utcMondays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcMondays;
  }
});
Object.defineProperty(exports, "utcMonth", {
  enumerable: true,
  get: function () {
    return _utcMonth.default;
  }
});
Object.defineProperty(exports, "utcMonths", {
  enumerable: true,
  get: function () {
    return _utcMonth.utcMonths;
  }
});
Object.defineProperty(exports, "utcSaturday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSaturday;
  }
});
Object.defineProperty(exports, "utcSaturdays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSaturdays;
  }
});
Object.defineProperty(exports, "utcSecond", {
  enumerable: true,
  get: function () {
    return _second.default;
  }
});
Object.defineProperty(exports, "utcSeconds", {
  enumerable: true,
  get: function () {
    return _second.seconds;
  }
});
Object.defineProperty(exports, "utcSunday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSunday;
  }
});
Object.defineProperty(exports, "utcSundays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSundays;
  }
});
Object.defineProperty(exports, "utcThursday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcThursday;
  }
});
Object.defineProperty(exports, "utcThursdays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcThursdays;
  }
});
Object.defineProperty(exports, "utcTuesday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcTuesday;
  }
});
Object.defineProperty(exports, "utcTuesdays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcTuesdays;
  }
});
Object.defineProperty(exports, "utcWednesday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcWednesday;
  }
});
Object.defineProperty(exports, "utcWednesdays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcWednesdays;
  }
});
Object.defineProperty(exports, "utcWeek", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSunday;
  }
});
Object.defineProperty(exports, "utcWeeks", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSundays;
  }
});
Object.defineProperty(exports, "utcYear", {
  enumerable: true,
  get: function () {
    return _utcYear.default;
  }
});
Object.defineProperty(exports, "utcYears", {
  enumerable: true,
  get: function () {
    return _utcYear.utcYears;
  }
});

var _interval = _interopRequireDefault(require("./src/interval"));

var _millisecond = _interopRequireWildcard(require("./src/millisecond"));

var _second = _interopRequireWildcard(require("./src/second"));

var _minute = _interopRequireWildcard(require("./src/minute"));

var _hour = _interopRequireWildcard(require("./src/hour"));

var _day = _interopRequireWildcard(require("./src/day"));

var _week = require("./src/week");

var _month = _interopRequireWildcard(require("./src/month"));

var _year = _interopRequireWildcard(require("./src/year"));

var _utcMinute = _interopRequireWildcard(require("./src/utcMinute"));

var _utcHour = _interopRequireWildcard(require("./src/utcHour"));

var _utcDay = _interopRequireWildcard(require("./src/utcDay"));

var _utcWeek = require("./src/utcWeek");

var _utcMonth = _interopRequireWildcard(require("./src/utcMonth"));

var _utcYear = _interopRequireWildcard(require("./src/utcYear"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/day":351,"./src/hour":353,"./src/interval":354,"./src/millisecond":355,"./src/minute":356,"./src/month":357,"./src/second":358,"./src/utcDay":359,"./src/utcHour":360,"./src/utcMinute":361,"./src/utcMonth":362,"./src/utcWeek":363,"./src/utcYear":364,"./src/week":365,"./src/year":366}],351:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.days = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var day = (0, _interval.default)(function (date) {
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setDate(date.getDate() + step);
}, function (start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration.durationMinute) / _duration.durationDay;
}, function (date) {
  return date.getDate() - 1;
});
var _default = day;
exports.default = _default;
var days = day.range;
exports.days = days;

},{"./duration":352,"./interval":354}],352:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.durationWeek = exports.durationSecond = exports.durationMinute = exports.durationHour = exports.durationDay = void 0;
var durationSecond = 1e3;
exports.durationSecond = durationSecond;
var durationMinute = 6e4;
exports.durationMinute = durationMinute;
var durationHour = 36e5;
exports.durationHour = durationHour;
var durationDay = 864e5;
exports.durationDay = durationDay;
var durationWeek = 6048e5;
exports.durationWeek = durationWeek;

},{}],353:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hours = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hour = (0, _interval.default)(function (date) {
  var offset = date.getTimezoneOffset() * _duration.durationMinute % _duration.durationHour;

  if (offset < 0) offset += _duration.durationHour;
  date.setTime(Math.floor((+date - offset) / _duration.durationHour) * _duration.durationHour + offset);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationHour);
}, function (start, end) {
  return (end - start) / _duration.durationHour;
}, function (date) {
  return date.getHours();
});
var _default = hour;
exports.default = _default;
var hours = hour.range;
exports.hours = hours;

},{"./duration":352,"./interval":354}],354:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = newInterval;
var t0 = new Date(),
    t1 = new Date();

function newInterval(floori, offseti, count, field) {
  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function (date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function (date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function (date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function (start, stop, step) {
    var range = [],
        previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date

    do range.push(previous = new Date(+start)), offseti(start, step), floori(start); while (previous < start && start < stop);

    return range;
  };

  interval.filter = function (test) {
    return newInterval(function (date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function (date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty

        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty

        }
      }
    });
  };

  if (count) {
    interval.count = function (start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function (step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
        return field(d) % step === 0;
      } : function (d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }

  return interval;
}

},{}],355:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.milliseconds = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var millisecond = (0, _interval.default)(function () {// noop
}, function (date, step) {
  date.setTime(+date + step);
}, function (start, end) {
  return end - start;
}); // An optimized implementation for this simple case.

millisecond.every = function (k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return (0, _interval.default)(function (date) {
    date.setTime(Math.floor(date / k) * k);
  }, function (date, step) {
    date.setTime(+date + step * k);
  }, function (start, end) {
    return (end - start) / k;
  });
};

var _default = millisecond;
exports.default = _default;
var milliseconds = millisecond.range;
exports.milliseconds = milliseconds;

},{"./interval":354}],356:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.minutes = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var minute = (0, _interval.default)(function (date) {
  date.setTime(Math.floor(date / _duration.durationMinute) * _duration.durationMinute);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationMinute);
}, function (start, end) {
  return (end - start) / _duration.durationMinute;
}, function (date) {
  return date.getMinutes();
});
var _default = minute;
exports.default = _default;
var minutes = minute.range;
exports.minutes = minutes;

},{"./duration":352,"./interval":354}],357:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.months = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var month = (0, _interval.default)(function (date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setMonth(date.getMonth() + step);
}, function (start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function (date) {
  return date.getMonth();
});
var _default = month;
exports.default = _default;
var months = month.range;
exports.months = months;

},{"./interval":354}],358:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.seconds = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var second = (0, _interval.default)(function (date) {
  date.setTime(Math.floor(date / _duration.durationSecond) * _duration.durationSecond);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationSecond);
}, function (start, end) {
  return (end - start) / _duration.durationSecond;
}, function (date) {
  return date.getUTCSeconds();
});
var _default = second;
exports.default = _default;
var seconds = second.range;
exports.seconds = seconds;

},{"./duration":352,"./interval":354}],359:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcDays = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcDay = (0, _interval.default)(function (date) {
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
  return (end - start) / _duration.durationDay;
}, function (date) {
  return date.getUTCDate() - 1;
});
var _default = utcDay;
exports.default = _default;
var utcDays = utcDay.range;
exports.utcDays = utcDays;

},{"./duration":352,"./interval":354}],360:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcHours = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcHour = (0, _interval.default)(function (date) {
  date.setUTCMinutes(0, 0, 0);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationHour);
}, function (start, end) {
  return (end - start) / _duration.durationHour;
}, function (date) {
  return date.getUTCHours();
});
var _default = utcHour;
exports.default = _default;
var utcHours = utcHour.range;
exports.utcHours = utcHours;

},{"./duration":352,"./interval":354}],361:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcMinutes = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcMinute = (0, _interval.default)(function (date) {
  date.setUTCSeconds(0, 0);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationMinute);
}, function (start, end) {
  return (end - start) / _duration.durationMinute;
}, function (date) {
  return date.getUTCMinutes();
});
var _default = utcMinute;
exports.default = _default;
var utcMinutes = utcMinute.range;
exports.utcMinutes = utcMinutes;

},{"./duration":352,"./interval":354}],362:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcMonths = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcMonth = (0, _interval.default)(function (date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function (start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function (date) {
  return date.getUTCMonth();
});
var _default = utcMonth;
exports.default = _default;
var utcMonths = utcMonth.range;
exports.utcMonths = utcMonths;

},{"./interval":354}],363:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcWednesdays = exports.utcWednesday = exports.utcTuesdays = exports.utcTuesday = exports.utcThursdays = exports.utcThursday = exports.utcSundays = exports.utcSunday = exports.utcSaturdays = exports.utcSaturday = exports.utcMondays = exports.utcMonday = exports.utcFridays = exports.utcFriday = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function utcWeekday(i) {
  return (0, _interval.default)(function (date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function (start, end) {
    return (end - start) / _duration.durationWeek;
  });
}

var utcSunday = utcWeekday(0);
exports.utcSunday = utcSunday;
var utcMonday = utcWeekday(1);
exports.utcMonday = utcMonday;
var utcTuesday = utcWeekday(2);
exports.utcTuesday = utcTuesday;
var utcWednesday = utcWeekday(3);
exports.utcWednesday = utcWednesday;
var utcThursday = utcWeekday(4);
exports.utcThursday = utcThursday;
var utcFriday = utcWeekday(5);
exports.utcFriday = utcFriday;
var utcSaturday = utcWeekday(6);
exports.utcSaturday = utcSaturday;
var utcSundays = utcSunday.range;
exports.utcSundays = utcSundays;
var utcMondays = utcMonday.range;
exports.utcMondays = utcMondays;
var utcTuesdays = utcTuesday.range;
exports.utcTuesdays = utcTuesdays;
var utcWednesdays = utcWednesday.range;
exports.utcWednesdays = utcWednesdays;
var utcThursdays = utcThursday.range;
exports.utcThursdays = utcThursdays;
var utcFridays = utcFriday.range;
exports.utcFridays = utcFridays;
var utcSaturdays = utcSaturday.range;
exports.utcSaturdays = utcSaturdays;

},{"./duration":352,"./interval":354}],364:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcYears = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcYear = (0, _interval.default)(function (date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function (start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function (date) {
  return date.getUTCFullYear();
}); // An optimized implementation for this simple case.

utcYear.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0, _interval.default)(function (date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var _default = utcYear;
exports.default = _default;
var utcYears = utcYear.range;
exports.utcYears = utcYears;

},{"./interval":354}],365:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wednesdays = exports.wednesday = exports.tuesdays = exports.tuesday = exports.thursdays = exports.thursday = exports.sundays = exports.sunday = exports.saturdays = exports.saturday = exports.mondays = exports.monday = exports.fridays = exports.friday = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function weekday(i) {
  return (0, _interval.default)(function (date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration.durationMinute) / _duration.durationWeek;
  });
}

var sunday = weekday(0);
exports.sunday = sunday;
var monday = weekday(1);
exports.monday = monday;
var tuesday = weekday(2);
exports.tuesday = tuesday;
var wednesday = weekday(3);
exports.wednesday = wednesday;
var thursday = weekday(4);
exports.thursday = thursday;
var friday = weekday(5);
exports.friday = friday;
var saturday = weekday(6);
exports.saturday = saturday;
var sundays = sunday.range;
exports.sundays = sundays;
var mondays = monday.range;
exports.mondays = mondays;
var tuesdays = tuesday.range;
exports.tuesdays = tuesdays;
var wednesdays = wednesday.range;
exports.wednesdays = wednesdays;
var thursdays = thursday.range;
exports.thursdays = thursdays;
var fridays = friday.range;
exports.fridays = fridays;
var saturdays = saturday.range;
exports.saturdays = saturdays;

},{"./duration":352,"./interval":354}],366:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.years = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var year = (0, _interval.default)(function (date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
  return end.getFullYear() - start.getFullYear();
}, function (date) {
  return date.getFullYear();
}); // An optimized implementation for this simple case.

year.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0, _interval.default)(function (date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var _default = year;
exports.default = _default;
var years = year.range;
exports.years = years;

},{"./interval":354}],367:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function () {
    return _interval.default;
  }
});
Object.defineProperty(exports, "now", {
  enumerable: true,
  get: function () {
    return _timer.now;
  }
});
Object.defineProperty(exports, "timeout", {
  enumerable: true,
  get: function () {
    return _timeout.default;
  }
});
Object.defineProperty(exports, "timer", {
  enumerable: true,
  get: function () {
    return _timer.timer;
  }
});
Object.defineProperty(exports, "timerFlush", {
  enumerable: true,
  get: function () {
    return _timer.timerFlush;
  }
});

var _timer = require("./src/timer");

var _timeout = _interopRequireDefault(require("./src/timeout"));

var _interval = _interopRequireDefault(require("./src/interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/interval":368,"./src/timeout":369,"./src/timer":370}],368:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _timer = require("./timer");

function _default(callback, delay, time) {
  var t = new _timer.Timer(),
      total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? (0, _timer.now)() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

},{"./timer":370}],369:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _timer = require("./timer");

function _default(callback, delay, time) {
  var t = new _timer.Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

},{"./timer":370}],370:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timer = Timer;
exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
var frame = 0,
    // is an animation frame pending?
timeout = 0,
    // is a timeout pending?
interval = 0,
    // are any timers active?
pokeDelay = 1000,
    // how frequently we check for clock skew
taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
  setTimeout(f, 17);
};

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call = this._time = this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function (callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }

    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function () {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.

  ++frame; // Pretend we’ve set an alarm, if we haven’t already.

  var t = taskHead,
      e;

  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }

  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;

  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(),
      delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0,
      t1 = taskHead,
      t2,
      time = Infinity;

  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }

  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.

  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

},{}],371:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "active", {
  enumerable: true,
  get: function () {
    return _active.default;
  }
});
Object.defineProperty(exports, "interrupt", {
  enumerable: true,
  get: function () {
    return _interrupt.default;
  }
});
Object.defineProperty(exports, "transition", {
  enumerable: true,
  get: function () {
    return _index2.default;
  }
});

require("./src/selection/index");

var _index2 = _interopRequireDefault(require("./src/transition/index"));

var _active = _interopRequireDefault(require("./src/active"));

var _interrupt = _interopRequireDefault(require("./src/interrupt"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/active":372,"./src/interrupt":373,"./src/selection/index":374,"./src/transition/index":383}],372:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./transition/index");

var _schedule = require("./transition/schedule");

var root = [null];

function _default(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).state > _schedule.SCHEDULED && schedule.name === name) {
        return new _index.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}

},{"./transition/index":383,"./transition/schedule":388}],373:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./transition/schedule");

function _default(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;
  if (!schedules) return;
  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty = false;
      continue;
    }

    active = schedule.state > _schedule.STARTING && schedule.state < _schedule.ENDING;
    schedule.state = _schedule.ENDED;
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

},{"./transition/schedule":388}],374:[function(require,module,exports){
"use strict";

var _d3Selection = require("d3-selection");

var _interrupt = _interopRequireDefault(require("./interrupt"));

var _transition = _interopRequireDefault(require("./transition"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_d3Selection.selection.prototype.interrupt = _interrupt.default;
_d3Selection.selection.prototype.transition = _transition.default;

},{"./interrupt":375,"./transition":376,"d3-selection":295}],375:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _interrupt = _interopRequireDefault(require("../interrupt"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(name) {
  return this.each(function () {
    (0, _interrupt.default)(this, name);
  });
}

},{"../interrupt":373}],376:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("../transition/index");

var _schedule = _interopRequireDefault(require("../transition/schedule"));

var _d3Ease = require("d3-ease");

var _d3Timer = require("d3-timer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: _d3Ease.easeCubicInOut
};

function inherit(node, id) {
  var timing;

  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = (0, _d3Timer.now)(), defaultTiming;
    }
  }

  return timing;
}

function _default(name) {
  var id, timing;

  if (name instanceof _index.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0, _index.newId)(), (timing = defaultTiming).time = (0, _d3Timer.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0, _schedule.default)(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _index.Transition(groups, this._parents, name, id);
}

},{"../transition/index":383,"../transition/schedule":388,"d3-ease":79,"d3-timer":367}],377:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Interpolate = require("d3-interpolate");

var _d3Selection = require("d3-selection");

var _tween = require("./tween");

var _interpolate = _interopRequireDefault(require("./interpolate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function _default(name, value) {
  var fullname = (0, _d3Selection.namespace)(name),
      i = fullname === "transform" ? _d3Interpolate.interpolateTransformSvg : _interpolate.default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0, _tween.tweenValue)(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
}

},{"./interpolate":384,"./tween":396,"d3-interpolate":201,"d3-selection":295}],378:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }

  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttribute(name, i(t));
    };
  }

  tween._value = value;
  return tween;
}

function _default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = (0, _d3Selection.namespace)(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

},{"d3-selection":295}],379:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./schedule");

function delayFunction(id, value) {
  return function () {
    (0, _schedule.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function () {
    (0, _schedule.init)(this, id).delay = value;
  };
}

function _default(value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : (0, _schedule.get)(this.node(), id).delay;
}

},{"./schedule":388}],380:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./schedule");

function durationFunction(id, value) {
  return function () {
    (0, _schedule.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function () {
    (0, _schedule.set)(this, id).duration = value;
  };
}

function _default(value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : (0, _schedule.get)(this.node(), id).duration;
}

},{"./schedule":388}],381:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./schedule");

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error();
  return function () {
    (0, _schedule.set)(this, id).ease = value;
  };
}

function _default(value) {
  var id = this._id;
  return arguments.length ? this.each(easeConstant(id, value)) : (0, _schedule.get)(this.node(), id).ease;
}

},{"./schedule":388}],382:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

var _index = require("./index");

function _default(match) {
  if (typeof match !== "function") match = (0, _d3Selection.matcher)(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index.Transition(subgroups, this._parents, this._name, this._id);
}

},{"./index":383,"d3-selection":295}],383:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transition = Transition;
exports.default = transition;
exports.newId = newId;

var _d3Selection = require("d3-selection");

var _attr = _interopRequireDefault(require("./attr"));

var _attrTween = _interopRequireDefault(require("./attrTween"));

var _delay = _interopRequireDefault(require("./delay"));

var _duration = _interopRequireDefault(require("./duration"));

var _ease = _interopRequireDefault(require("./ease"));

var _filter = _interopRequireDefault(require("./filter"));

var _merge = _interopRequireDefault(require("./merge"));

var _on = _interopRequireDefault(require("./on"));

var _remove = _interopRequireDefault(require("./remove"));

var _select = _interopRequireDefault(require("./select"));

var _selectAll = _interopRequireDefault(require("./selectAll"));

var _selection = _interopRequireDefault(require("./selection"));

var _style = _interopRequireDefault(require("./style"));

var _styleTween = _interopRequireDefault(require("./styleTween"));

var _text = _interopRequireDefault(require("./text"));

var _transition = _interopRequireDefault(require("./transition"));

var _tween = _interopRequireDefault(require("./tween"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0, _d3Selection.selection)().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = _d3Selection.selection.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select.default,
  selectAll: _selectAll.default,
  filter: _filter.default,
  merge: _merge.default,
  selection: _selection.default,
  transition: _transition.default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on.default,
  attr: _attr.default,
  attrTween: _attrTween.default,
  style: _style.default,
  styleTween: _styleTween.default,
  text: _text.default,
  remove: _remove.default,
  tween: _tween.default,
  delay: _delay.default,
  duration: _duration.default,
  ease: _ease.default
};

},{"./attr":377,"./attrTween":378,"./delay":379,"./duration":380,"./ease":381,"./filter":382,"./merge":385,"./on":386,"./remove":387,"./select":389,"./selectAll":390,"./selection":391,"./style":392,"./styleTween":393,"./text":394,"./transition":395,"./tween":396,"d3-selection":295}],384:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Color = require("d3-color");

var _d3Interpolate = require("d3-interpolate");

function _default(a, b) {
  var c;
  return (typeof b === "number" ? _d3Interpolate.interpolateNumber : b instanceof _d3Color.color ? _d3Interpolate.interpolateRgb : (c = (0, _d3Color.color)(b)) ? (b = c, _d3Interpolate.interpolateRgb) : _d3Interpolate.interpolateString)(a, b);
}

},{"d3-color":55,"d3-interpolate":201}],385:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

function _default(transition) {
  if (transition._id !== this._id) throw new Error();

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index.Transition(merges, this._parents, this._name, this._id);
}

},{"./index":383}],386:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./schedule");

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function (t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0,
      on1,
      sit = start(name) ? _schedule.init : _schedule.set;
  return function () {
    var schedule = sit(this, id),
        on = schedule.on; // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.

    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}

function _default(name, listener) {
  var id = this._id;
  return arguments.length < 2 ? (0, _schedule.get)(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
}

},{"./schedule":388}],387:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function removeFunction(id) {
  return function () {
    var parent = this.parentNode;

    for (var i in this.__transition) if (+i !== id) return;

    if (parent) parent.removeChild(this);
  };
}

function _default() {
  return this.on("end.remove", removeFunction(this._id));
}

},{}],388:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STARTING = exports.STARTED = exports.SCHEDULED = exports.RUNNING = exports.ENDING = exports.ENDED = exports.CREATED = void 0;
exports.default = _default;
exports.get = get;
exports.init = init;
exports.set = set;

var _d3Dispatch = require("d3-dispatch");

var _d3Timer = require("d3-timer");

var emptyOn = (0, _d3Dispatch.dispatch)("start", "end", "interrupt");
var emptyTween = [];
var CREATED = 0;
exports.CREATED = CREATED;
var SCHEDULED = 1;
exports.SCHEDULED = SCHEDULED;
var STARTING = 2;
exports.STARTING = STARTING;
var STARTED = 3;
exports.STARTED = STARTED;
var RUNNING = 4;
exports.RUNNING = RUNNING;
var ENDING = 5;
exports.ENDING = ENDING;
var ENDED = 6;
exports.ENDED = ENDED;

function _default(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index,
    // For context during callback.
    group: group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween; // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!

  schedules[id] = self;
  self.timer = (0, _d3Timer.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.

    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.

    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!

      if (o.state === STARTED) return (0, _d3Timer.timeout)(start); // Interrupt the active transition, if any.
      // Dispatch the interrupt event.

      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    } // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.


    (0, _d3Timer.timeout)(function () {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    }); // Dispatch the start event.
    // Note this must be done before the tween are initialized.

    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted

    self.state = STARTED; // Initialize the tween, deleting null tween.

    tween = new Array(n = self.tween.length);

    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }

    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    } // Dispatch the end event.


    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];

    for (var i in schedules) return; // eslint-disable-line no-unused-vars


    delete node.__transition;
  }
}

},{"d3-dispatch":61,"d3-timer":367}],389:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

var _index = require("./index");

var _schedule = _interopRequireWildcard(require("./schedule"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _default(select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = (0, _d3Selection.selector)(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0, _schedule.default)(subgroup[i], name, id, i, subgroup, (0, _schedule.get)(node, id));
      }
    }
  }

  return new _index.Transition(subgroups, this._parents, name, id);
}

},{"./index":383,"./schedule":388,"d3-selection":295}],390:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

var _index = require("./index");

var _schedule = _interopRequireWildcard(require("./schedule"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _default(select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = (0, _d3Selection.selectorAll)(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0, _schedule.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0, _schedule.default)(child, name, id, k, children, inherit);
          }
        }

        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index.Transition(subgroups, parents, name, id);
}

},{"./index":383,"./schedule":388,"d3-selection":295}],391:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

var Selection = _d3Selection.selection.prototype.constructor;

function _default() {
  return new Selection(this._groups, this._parents);
}

},{"d3-selection":295}],392:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Interpolate = require("d3-interpolate");

var _d3Selection = require("d3-selection");

var _tween = require("./tween");

var _interpolate = _interopRequireDefault(require("./interpolate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function styleRemove(name, interpolate) {
  var value00, value10, interpolate0;
  return function () {
    var value0 = (0, _d3Selection.style)(this, name),
        value1 = (this.style.removeProperty(name), (0, _d3Selection.style)(this, name));
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = (0, _d3Selection.style)(this, name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0 = (0, _d3Selection.style)(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), (0, _d3Selection.style)(this, name));
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function _default(name, value, priority) {
  var i = (name += "") === "transform" ? _d3Interpolate.interpolateTransformCss : _interpolate.default;
  return value == null ? this.styleTween(name, styleRemove(name, i)).on("end.style." + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === "function" ? styleFunction(name, i, (0, _tween.tweenValue)(this, "style." + name, value)) : styleConstant(name, i, value + ""), priority);
}

},{"./interpolate":384,"./tween":396,"d3-interpolate":201,"d3-selection":295}],393:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function styleTween(name, value, priority) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.style.setProperty(name, i(t), priority);
    };
  }

  tween._value = value;
  return tween;
}

function _default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

},{}],394:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _tween = require("./tween");

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function _default(value) {
  return this.tween("text", typeof value === "function" ? textFunction((0, _tween.tweenValue)(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}

},{"./tween":396}],395:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _schedule = _interopRequireWildcard(require("./schedule"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _default() {
  var name = this._name,
      id0 = this._id,
      id1 = (0, _index.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0, _schedule.get)(node, id0);
        (0, _schedule.default)(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index.Transition(groups, this._parents, name, id1);
}

},{"./index":383,"./schedule":388}],396:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.tweenValue = tweenValue;

var _schedule = require("./schedule");

function tweenRemove(id, name) {
  var tween0, tween1;
  return function () {
    var schedule = (0, _schedule.set)(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = tween0 = tween;

      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function () {
    var schedule = (0, _schedule.set)(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();

      for (var t = {
        name: name,
        value: value
      }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }

      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function _default(name, value) {
  var id = this._id;
  name += "";

  if (arguments.length < 2) {
    var tween = (0, _schedule.get)(this.node(), id).tween;

    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }

    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;
  transition.each(function () {
    var schedule = (0, _schedule.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function (node) {
    return (0, _schedule.get)(node, id).value[name];
  };
}

},{"./schedule":388}],397:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "voronoi", {
  enumerable: true,
  get: function () {
    return _voronoi.default;
  }
});

var _voronoi = _interopRequireDefault(require("./src/voronoi"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/voronoi":406}],398:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addBeach = addBeach;
exports.removeBeach = removeBeach;

var _RedBlackTree = require("./RedBlackTree");

var _Cell = require("./Cell");

var _Circle = require("./Circle");

var _Edge = require("./Edge");

var _Diagram = require("./Diagram");

var beachPool = [];

function Beach() {
  (0, _RedBlackTree.RedBlackNode)(this);
  this.edge = this.site = this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  (0, _Circle.detachCircle)(beach);

  _Diagram.beaches.remove(beach);

  beachPool.push(beach);
  (0, _RedBlackTree.RedBlackNode)(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;

  while (lArc.circle && Math.abs(x - lArc.circle.x) < _Diagram.epsilon && Math.abs(y - lArc.circle.cy) < _Diagram.epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  (0, _Circle.detachCircle)(lArc);
  var rArc = next;

  while (rArc.circle && Math.abs(x - rArc.circle.x) < _Diagram.epsilon && Math.abs(y - rArc.circle.cy) < _Diagram.epsilon) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  (0, _Circle.detachCircle)(rArc);
  var nArcs = disappearing.length,
      iArc;

  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    (0, _Edge.setEdgeEnd)(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = (0, _Edge.createEdge)(lArc.site, rArc.site, null, vertex);
  (0, _Circle.attachCircle)(lArc);
  (0, _Circle.attachCircle)(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = _Diagram.beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > _Diagram.epsilon) node = node.L;else {
      dxr = x - rightBreakPoint(node, directrix);

      if (dxr > _Diagram.epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }

        node = node.R;
      } else {
        if (dxl > -_Diagram.epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -_Diagram.epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }

        break;
      }
    }
  }

  (0, _Cell.createCell)(site);
  var newArc = createBeach(site);

  _Diagram.beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    (0, _Circle.detachCircle)(lArc);
    rArc = createBeach(lArc.site);

    _Diagram.beaches.insert(newArc, rArc);

    newArc.edge = rArc.edge = (0, _Edge.createEdge)(lArc.site, newArc.site);
    (0, _Circle.attachCircle)(lArc);
    (0, _Circle.attachCircle)(rArc);
    return;
  }

  if (!rArc) {
    // && lArc
    newArc.edge = (0, _Edge.createEdge)(lArc.site, newArc.site);
    return;
  } // else lArc !== rArc


  (0, _Circle.detachCircle)(lArc);
  (0, _Circle.detachCircle)(rArc);
  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
  (0, _Edge.setEdgeEnd)(rArc.edge, lSite, rSite, vertex);
  newArc.edge = (0, _Edge.createEdge)(lSite, site, null, vertex);
  rArc.edge = (0, _Edge.createEdge)(site, rSite, null, vertex);
  (0, _Circle.attachCircle)(lArc);
  (0, _Circle.attachCircle)(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;
  if (!pby2) return rfocx;
  var lArc = arc.P;
  if (!lArc) return -Infinity;
  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;
  if (!plby2) return lfocx;
  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;
  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

},{"./Cell":399,"./Circle":400,"./Diagram":401,"./Edge":402,"./RedBlackTree":403}],399:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cellHalfedgeEnd = cellHalfedgeEnd;
exports.cellHalfedgeStart = cellHalfedgeStart;
exports.clipCells = clipCells;
exports.createCell = createCell;
exports.sortCellHalfedges = sortCellHalfedges;

var _Edge = require("./Edge");

var _Diagram = require("./Diagram");

function createCell(site) {
  return _Diagram.cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = _Diagram.cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = _Diagram.cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);

      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, _Diagram.edges[halfedges[j]]);

      index.sort(function (i, j) {
        return array[j] - array[i];
      });

      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];

      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = _Diagram.cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = _Diagram.cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length; // Remove any dangling clipped edges.

      while (iHalfedge--) {
        if (!_Diagram.edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      } // Insert any border edges as necessary.


      iHalfedge = 0, nHalfedges = halfedges.length;

      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, _Diagram.edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, _Diagram.edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];

        if (Math.abs(endX - startX) > _Diagram.epsilon || Math.abs(endY - startY) > _Diagram.epsilon) {
          halfedges.splice(iHalfedge, 0, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, end, Math.abs(endX - x0) < _Diagram.epsilon && y1 - endY > _Diagram.epsilon ? [x0, Math.abs(startX - x0) < _Diagram.epsilon ? startY : y1] : Math.abs(endY - y1) < _Diagram.epsilon && x1 - endX > _Diagram.epsilon ? [Math.abs(startY - y1) < _Diagram.epsilon ? startX : x1, y1] : Math.abs(endX - x1) < _Diagram.epsilon && endY - y0 > _Diagram.epsilon ? [x1, Math.abs(startX - x1) < _Diagram.epsilon ? startY : y0] : Math.abs(endY - y0) < _Diagram.epsilon && endX - x0 > _Diagram.epsilon ? [Math.abs(startY - y0) < _Diagram.epsilon ? startX : x0, y0] : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  } // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!


  if (cover) {
    var dx,
        dy,
        d2,
        dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = _Diagram.cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0],
          v01 = [x0, y1],
          v11 = [x1, y1],
          v10 = [x1, y0];
      cover.halfedges.push(_Diagram.edges.push((0, _Edge.createBorderEdge)(site = cover.site, v00, v01)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v01, v11)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v11, v10)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v10, v00)) - 1);
    }
  } // Lastly delete any cells with no edges; these were entirely clipped.


  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = _Diagram.cells[iCell]) {
      if (!cell.halfedges.length) {
        delete _Diagram.cells[iCell];
      }
    }
  }
}

},{"./Diagram":401,"./Edge":402}],400:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attachCircle = attachCircle;
exports.detachCircle = detachCircle;
exports.firstCircle = void 0;

var _RedBlackTree = require("./RedBlackTree");

var _Diagram = require("./Diagram");

var circlePool = [];
var firstCircle;
exports.firstCircle = firstCircle;

function Circle() {
  (0, _RedBlackTree.RedBlackNode)(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;
  if (!lArc || !rArc) return;
  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;
  if (lSite === rSite) return;
  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;
  var d = 2 * (ax * cy - ay * cx);
  if (d >= -_Diagram.epsilon2) return;
  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;
  var circle = circlePool.pop() || new Circle();
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;
  var before = null,
      node = _Diagram.circles._;

  while (node) {
    if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
      if (node.L) node = node.L;else {
        before = node.P;
        break;
      }
    } else {
      if (node.R) node = node.R;else {
        before = node;
        break;
      }
    }
  }

  _Diagram.circles.insert(before, circle);

  if (!before) exports.firstCircle = firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;

  if (circle) {
    if (!circle.P) exports.firstCircle = firstCircle = circle.N;

    _Diagram.circles.remove(circle);

    circlePool.push(circle);
    (0, _RedBlackTree.RedBlackNode)(circle);
    arc.circle = null;
  }
}

},{"./Diagram":401,"./RedBlackTree":403}],401:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circles = exports.cells = exports.beaches = void 0;
exports.default = Diagram;
exports.epsilon2 = exports.epsilon = exports.edges = void 0;

var _Beach = require("./Beach");

var _Cell = require("./Cell");

var _Circle = require("./Circle");

var _Edge = require("./Edge");

var _RedBlackTree = _interopRequireDefault(require("./RedBlackTree"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var epsilon = 1e-6;
exports.epsilon = epsilon;
var epsilon2 = 1e-12;
exports.epsilon2 = epsilon2;
var beaches;
exports.beaches = beaches;
var cells;
exports.cells = cells;
var circles;
exports.circles = circles;
var edges;
exports.edges = edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1] || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;
  exports.edges = edges = [];
  exports.cells = cells = new Array(sites.length);
  exports.beaches = beaches = new _RedBlackTree.default();
  exports.circles = circles = new _RedBlackTree.default();

  while (true) {
    circle = _Circle.firstCircle;

    if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
      if (site[0] !== x || site[1] !== y) {
        (0, _Beach.addBeach)(site);
        x = site[0], y = site[1];
      }

      site = sites.pop();
    } else if (circle) {
      (0, _Beach.removeBeach)(circle.arc);
    } else {
      break;
    }
  }

  (0, _Cell.sortCellHalfedges)();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    (0, _Edge.clipEdges)(x0, y0, x1, y1);
    (0, _Cell.clipCells)(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;
  exports.beaches = beaches = exports.circles = circles = exports.edges = edges = exports.cells = cells = null;
}

Diagram.prototype = {
  constructor: Diagram,
  polygons: function () {
    var edges = this.edges;
    return this.cells.map(function (cell) {
      var polygon = cell.halfedges.map(function (i) {
        return (0, _Cell.cellHalfedgeStart)(cell, edges[i]);
      });
      polygon.data = cell.site.data;
      return polygon;
    });
  },
  triangles: function () {
    var triangles = [],
        edges = this.edges;
    this.cells.forEach(function (cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;

        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });
    return triangles;
  },
  links: function () {
    return this.edges.filter(function (edge) {
      return edge.right;
    }).map(function (edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },
  find: function (x, y, radius) {
    var that = this,
        i0,
        i1 = that._found || 0,
        n = that.cells.length,
        cell; // Use the previously-found cell, or start with an arbitrary one.

    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;

    var dx = x - cell.site[0],
        dy = y - cell.site[1],
        d2 = dx * dx + dy * dy; // Traverse the half-edges to find a closer cell, if any.

    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function (e) {
        var edge = that.edges[e],
            v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0],
            vy = y - v[1],
            v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;
    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

},{"./Beach":398,"./Cell":399,"./Circle":400,"./Edge":402,"./RedBlackTree":403}],402:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clipEdges = clipEdges;
exports.createBorderEdge = createBorderEdge;
exports.createEdge = createEdge;
exports.setEdgeEnd = setEdgeEnd;

var _Diagram = require("./Diagram");

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = _Diagram.edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);

  _Diagram.cells[left.index].halfedges.push(index);

  _Diagram.cells[right.index].halfedges.push(index);

  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
} // Liang–Barsky line clipping.


function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;
  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;

    if (lx > rx) {
      if (!v0) v0 = [fx, y0];else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;

    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = _Diagram.edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = _Diagram.edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > _Diagram.epsilon || Math.abs(edge[0][1] - edge[1][1]) > _Diagram.epsilon)) {
      delete _Diagram.edges[i];
    }
  }
}

},{"./Diagram":401}],403:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RedBlackNode = RedBlackNode;
exports.default = void 0;

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,
  insert: function (after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;

      if (after.R) {
        after = after.R;

        while (after.L) after = after.L;

        after.L = node;
      } else {
        after.R = node;
      }

      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }

    node.L = node.R = null;
    node.U = parent;
    node.C = true;
    after = node;

    while (parent && parent.C) {
      grandpa = parent.U;

      if (parent === grandpa.L) {
        uncle = grandpa.R;

        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }

          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;

        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }

          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }

      parent = after.U;
    }

    this._.C = false;
  },
  remove: function (node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;
    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;
    if (!left) next = right;else if (!right) next = left;else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;

      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;

    if (node && node.C) {
      node.C = false;
      return;
    }

    do {
      if (node === this._) break;

      if (node === parent.L) {
        sibling = parent.R;

        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }

        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }

          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;

        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }

        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }

          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }

      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;

  return node;
}

var _default = RedBlackTree;
exports.default = _default;

},{}],404:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],405:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.x = x;
exports.y = y;

function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}

},{}],406:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _point = require("./point");

var _Diagram = _interopRequireWildcard(require("./Diagram"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var x = _point.x,
      y = _point.y,
      extent = null;

  function voronoi(data) {
    return new _Diagram.default(data.map(function (d, i) {
      var s = [Math.round(x(d, i, data) / _Diagram.epsilon) * _Diagram.epsilon, Math.round(y(d, i, data) / _Diagram.epsilon) * _Diagram.epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function (data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function (data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function (data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), voronoi) : x;
  };

  voronoi.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), voronoi) : y;
  };

  voronoi.extent = function (_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function (_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}

},{"./Diagram":401,"./constant":404,"./point":405}],407:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "zoom", {
  enumerable: true,
  get: function () {
    return _zoom.default;
  }
});
Object.defineProperty(exports, "zoomIdentity", {
  enumerable: true,
  get: function () {
    return _transform.identity;
  }
});
Object.defineProperty(exports, "zoomTransform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});

var _zoom = _interopRequireDefault(require("./src/zoom"));

var _transform = _interopRequireWildcard(require("./src/transform"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/transform":411,"./src/zoom":412}],408:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],409:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ZoomEvent;

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

},{}],410:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"d3-selection":295,"dup":41}],411:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transform = Transform;
exports.default = transform;
exports.identity = void 0;

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function (k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function (x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function (point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function (x) {
    return x * this.k + this.x;
  },
  applyY: function (y) {
    return y * this.k + this.y;
  },
  invert: function (location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function (x) {
    return (x - this.x) / this.k;
  },
  invertY: function (y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function (x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function (y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function () {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
exports.identity = identity;
transform.prototype = Transform.prototype;

function transform(node) {
  return node.__zoom || identity;
}

},{}],412:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Dispatch = require("d3-dispatch");

var _d3Drag = require("d3-drag");

var _d3Interpolate = require("d3-interpolate");

var _d3Selection = require("d3-selection");

var _d3Transition = require("d3-transition");

var _constant = _interopRequireDefault(require("./constant"));

var _event = _interopRequireDefault(require("./event"));

var _transform = require("./transform");

var _noevent = _interopRequireWildcard(require("./noevent"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !_d3Selection.event.button;
}

function defaultExtent() {
  var e = this,
      w,
      h;

  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }

  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || _transform.identity;
}

function defaultWheelDelta() {
  return -_d3Selection.event.deltaY * (_d3Selection.event.deltaMode ? 120 : 1) / 500;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}

function _default() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = _d3Interpolate.interpolateZoom,
      gestures = [],
      listeners = (0, _d3Dispatch.dispatch)("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function (collection, transform) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);

    if (collection !== selection) {
      schedule(collection, transform);
    } else {
      selection.interrupt().each(function () {
        gesture(this, arguments).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };

  zoom.scaleBy = function (selection, k) {
    zoom.scaleTo(selection, function () {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function (selection, k) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function (selection, x, y) {
    zoom.transform(selection, function () {
      return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function (selection, x, y) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(_transform.identity.translate(p[0], p[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
    });
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k,
        y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, center) {
    transition.on("start.zoom", function () {
      gesture(this, arguments).start();
    }).on("interrupt.zoom end.zoom", function () {
      gesture(this, arguments).end();
    }).tween("zoom", function () {
      var that = this,
          args = arguments,
          g = gesture(that, args),
          e = extent.apply(that, args),
          p = center || centroid(e),
          w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
          a = that.__zoom,
          b = typeof transform === "function" ? transform.apply(that, args) : transform,
          i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function (t) {
        if (t === 1) t = b; // Avoid rounding error on end.
        else {
          var l = i(t),
              k = w / l[2];
          t = new _transform.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }

    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function () {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }

      return this;
    },
    zoom: function (key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function () {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }

      return this;
    },
    emit: function (type) {
      (0, _d3Selection.customEvent)(new _event.default(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0, _d3Selection.mouse)(this); // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.

    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }

      clearTimeout(g.wheel);
    } // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return; // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0, _d3Transition.interrupt)(this);
      g.start();
    }

    (0, _noevent.default)();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = (0, _d3Selection.select)(_d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0, _d3Selection.mouse)(this),
        x0 = _d3Selection.event.clientX,
        y0 = _d3Selection.event.clientY;
    (0, _d3Drag.dragDisable)(_d3Selection.event.view);
    (0, _noevent.nopropagation)();
    g.mouse = [p, this.__zoom.invert(p)];
    (0, _d3Transition.interrupt)(this);
    g.start();

    function mousemoved() {
      (0, _noevent.default)();

      if (!g.moved) {
        var dx = _d3Selection.event.clientX - x0,
            dy = _d3Selection.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }

      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0, _d3Selection.mouse)(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0, _d3Drag.dragEnable)(_d3Selection.event.view, g.moved);
      (0, _noevent.default)();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0, _d3Selection.mouse)(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (_d3Selection.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
    (0, _noevent.default)();
    if (duration > 0) (0, _d3Selection.select)(this).transition().duration(duration).call(schedule, t1, p0);else (0, _d3Selection.select)(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = _d3Selection.event.changedTouches,
        started,
        n = touches.length,
        i,
        t,
        p;
    (0, _noevent.nopropagation)();

    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0, _d3Selection.touch)(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;else if (!g.touch1) g.touch1 = p;
    } // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.


    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);

      if (!g.touch1) {
        g.end();
        p = (0, _d3Selection.select)(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function () {
        touchstarting = null;
      }, touchDelay);
      (0, _d3Transition.interrupt)(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = _d3Selection.event.changedTouches,
        n = touches.length,
        i,
        t,
        p,
        l;
    (0, _noevent.default)();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0, _d3Selection.touch)(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }

    t = g.that.__zoom;

    if (g.touch1) {
      var p0 = g.touch0[0],
          l0 = g.touch0[1],
          p1 = g.touch1[0],
          l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = _d3Selection.event.changedTouches,
        n = touches.length,
        i,
        t;
    (0, _noevent.nopropagation)();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, touchDelay);

    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }

    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else g.end();
  }

  zoom.wheelDelta = function (_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0, _constant.default)(+_), zoom) : wheelDelta;
  };

  zoom.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), zoom) : filter;
  };

  zoom.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0, _constant.default)(!!_), zoom) : touchable;
  };

  zoom.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0, _constant.default)([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function (_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function (_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function (_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function (_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function (_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
}

},{"./constant":408,"./event":409,"./noevent":410,"./transform":411,"d3-dispatch":61,"d3-drag":63,"d3-interpolate":201,"d3-selection":295,"d3-transition":371}],413:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = exports.unpkg = exports.scripts = exports.repository = exports.name = exports.module = exports.main = exports.license = exports.keywords = exports.jsdelivr = exports.homepage = exports.devDependencies = exports.description = exports.dependencies = exports.author = void 0;
var name = "d3";
exports.name = name;
var version = "4.13.0";
exports.version = version;
var description = "Data-Driven Documents";
exports.description = description;
var keywords = ["dom", "visualization", "svg", "animation", "canvas"];
exports.keywords = keywords;
var homepage = "https://d3js.org";
exports.homepage = homepage;
var license = "BSD-3-Clause";
exports.license = license;
var author = {
  "name": "Mike Bostock",
  "url": "https://bost.ocks.org/mike"
};
exports.author = author;
var main = "build/d3.node.js";
exports.main = main;
var unpkg = "build/d3.min.js";
exports.unpkg = unpkg;
var jsdelivr = "build/d3.min.js";
exports.jsdelivr = jsdelivr;
var _module = "index";
exports.module = _module;
var repository = {
  "type": "git",
  "url": "https://github.com/d3/d3.git"
};
exports.repository = repository;
var scripts = {
  "pretest": "rimraf build && mkdir build && json2module package.json > build/package.js && node rollup.node",
  "test": "tape 'test/**/*-test.js'",
  "prepublishOnly": "npm run test && rollup -c --banner \"$(preamble)\" && uglifyjs -b beautify=false,preamble=\"'$(preamble)'\" build/d3.js -c negate_iife=false -m -o build/d3.min.js",
  "postpublish": "git push && git push --tags && cd ../d3.github.com && git pull && cp ../d3/build/d3.js d3.v4.js && cp ../d3/build/d3.min.js d3.v4.min.js && git add d3.v4.js d3.v4.min.js && git commit -m \"d3 ${npm_package_version}\" && git push && cd - && cd ../d3-bower && git pull && cp ../d3/LICENSE ../d3/README.md ../d3/build/d3.js ../d3/build/d3.min.js . && git add -- LICENSE README.md d3.js d3.min.js && git commit -m \"${npm_package_version}\" && git tag -am \"${npm_package_version}\" v${npm_package_version} && git push && git push --tags && cd - && zip -j build/d3.zip -- LICENSE README.md API.md CHANGES.md build/d3.js build/d3.min.js"
};
exports.scripts = scripts;
var devDependencies = {
  "json2module": "0.0",
  "package-preamble": "0.1",
  "rimraf": "2",
  "rollup": "0.53",
  "rollup-plugin-ascii": "0.0",
  "rollup-plugin-node-resolve": "3",
  "tape": "4",
  "uglify-js": "3.2"
};
exports.devDependencies = devDependencies;
var dependencies = {
  "d3-array": "1.2.1",
  "d3-axis": "1.0.8",
  "d3-brush": "1.0.4",
  "d3-chord": "1.0.4",
  "d3-collection": "1.0.4",
  "d3-color": "1.0.3",
  "d3-dispatch": "1.0.3",
  "d3-drag": "1.2.1",
  "d3-dsv": "1.0.8",
  "d3-ease": "1.0.3",
  "d3-force": "1.1.0",
  "d3-format": "1.2.2",
  "d3-geo": "1.9.1",
  "d3-hierarchy": "1.1.5",
  "d3-interpolate": "1.1.6",
  "d3-path": "1.0.5",
  "d3-polygon": "1.0.3",
  "d3-quadtree": "1.0.3",
  "d3-queue": "3.0.7",
  "d3-random": "1.1.0",
  "d3-request": "1.0.6",
  "d3-scale": "1.0.7",
  "d3-selection": "1.3.0",
  "d3-shape": "1.2.0",
  "d3-time": "1.0.8",
  "d3-time-format": "2.1.1",
  "d3-timer": "1.0.7",
  "d3-transition": "1.1.1",
  "d3-voronoi": "1.1.2",
  "d3-zoom": "1.7.1"
};
exports.dependencies = dependencies;

},{}],414:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true
};
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _package.version;
  }
});

var _package = require("./build/package");

var _d3Array = require("d3-array");

Object.keys(_d3Array).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Array[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Array[key];
    }
  });
});

var _d3Axis = require("d3-axis");

Object.keys(_d3Axis).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Axis[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Axis[key];
    }
  });
});

var _d3Brush = require("d3-brush");

Object.keys(_d3Brush).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Brush[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Brush[key];
    }
  });
});

var _d3Chord = require("d3-chord");

Object.keys(_d3Chord).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Chord[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Chord[key];
    }
  });
});

var _d3Collection = require("d3-collection");

Object.keys(_d3Collection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Collection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Collection[key];
    }
  });
});

var _d3Color = require("d3-color");

Object.keys(_d3Color).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Color[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Color[key];
    }
  });
});

var _d3Dispatch = require("d3-dispatch");

Object.keys(_d3Dispatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Dispatch[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Dispatch[key];
    }
  });
});

var _d3Drag = require("d3-drag");

Object.keys(_d3Drag).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Drag[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Drag[key];
    }
  });
});

var _d3Dsv = require("d3-dsv");

Object.keys(_d3Dsv).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Dsv[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Dsv[key];
    }
  });
});

var _d3Ease = require("d3-ease");

Object.keys(_d3Ease).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Ease[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Ease[key];
    }
  });
});

var _d3Force = require("d3-force");

Object.keys(_d3Force).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Force[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Force[key];
    }
  });
});

var _d3Format = require("d3-format");

Object.keys(_d3Format).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Format[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Format[key];
    }
  });
});

var _d3Geo = require("d3-geo");

Object.keys(_d3Geo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Geo[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Geo[key];
    }
  });
});

var _d3Hierarchy = require("d3-hierarchy");

Object.keys(_d3Hierarchy).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Hierarchy[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Hierarchy[key];
    }
  });
});

var _d3Interpolate = require("d3-interpolate");

Object.keys(_d3Interpolate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Interpolate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Interpolate[key];
    }
  });
});

var _d3Path = require("d3-path");

Object.keys(_d3Path).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Path[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Path[key];
    }
  });
});

var _d3Polygon = require("d3-polygon");

Object.keys(_d3Polygon).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Polygon[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Polygon[key];
    }
  });
});

var _d3Quadtree = require("d3-quadtree");

Object.keys(_d3Quadtree).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Quadtree[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Quadtree[key];
    }
  });
});

var _d3Queue = require("d3-queue");

Object.keys(_d3Queue).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Queue[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Queue[key];
    }
  });
});

var _d3Random = require("d3-random");

Object.keys(_d3Random).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Random[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Random[key];
    }
  });
});

var _d3Request = require("d3-request");

Object.keys(_d3Request).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Request[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Request[key];
    }
  });
});

var _d3Scale = require("d3-scale");

Object.keys(_d3Scale).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Scale[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Scale[key];
    }
  });
});

var _d3Selection = require("d3-selection");

Object.keys(_d3Selection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Selection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Selection[key];
    }
  });
});

var _d3Shape = require("d3-shape");

Object.keys(_d3Shape).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Shape[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Shape[key];
    }
  });
});

var _d3Time = require("d3-time");

Object.keys(_d3Time).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Time[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Time[key];
    }
  });
});

var _d3TimeFormat = require("d3-time-format");

Object.keys(_d3TimeFormat).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3TimeFormat[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3TimeFormat[key];
    }
  });
});

var _d3Timer = require("d3-timer");

Object.keys(_d3Timer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Timer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Timer[key];
    }
  });
});

var _d3Transition = require("d3-transition");

Object.keys(_d3Transition).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Transition[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Transition[key];
    }
  });
});

var _d3Voronoi = require("d3-voronoi");

Object.keys(_d3Voronoi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Voronoi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Voronoi[key];
    }
  });
});

var _d3Zoom = require("d3-zoom");

Object.keys(_d3Zoom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Zoom[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Zoom[key];
    }
  });
});

},{"./build/package":413,"d3-array":1,"d3-axis":33,"d3-brush":37,"d3-chord":42,"d3-collection":48,"d3-color":55,"d3-dispatch":61,"d3-drag":63,"d3-dsv":69,"d3-ease":415,"d3-force":85,"d3-format":96,"d3-geo":112,"d3-hierarchy":170,"d3-interpolate":201,"d3-path":223,"d3-polygon":225,"d3-quadtree":232,"d3-queue":247,"d3-random":250,"d3-request":258,"d3-scale":268,"d3-selection":295,"d3-shape":426,"d3-time":350,"d3-time-format":345,"d3-timer":367,"d3-transition":371,"d3-voronoi":397,"d3-zoom":407}],415:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "easeBack", {
  enumerable: true,
  get: function () {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeBackIn", {
  enumerable: true,
  get: function () {
    return _back.backIn;
  }
});
Object.defineProperty(exports, "easeBackInOut", {
  enumerable: true,
  get: function () {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeBackOut", {
  enumerable: true,
  get: function () {
    return _back.backOut;
  }
});
Object.defineProperty(exports, "easeBounce", {
  enumerable: true,
  get: function () {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeBounceIn", {
  enumerable: true,
  get: function () {
    return _bounce.bounceIn;
  }
});
Object.defineProperty(exports, "easeBounceInOut", {
  enumerable: true,
  get: function () {
    return _bounce.bounceInOut;
  }
});
Object.defineProperty(exports, "easeBounceOut", {
  enumerable: true,
  get: function () {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeCircle", {
  enumerable: true,
  get: function () {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeCircleIn", {
  enumerable: true,
  get: function () {
    return _circle.circleIn;
  }
});
Object.defineProperty(exports, "easeCircleInOut", {
  enumerable: true,
  get: function () {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeCircleOut", {
  enumerable: true,
  get: function () {
    return _circle.circleOut;
  }
});
Object.defineProperty(exports, "easeCubic", {
  enumerable: true,
  get: function () {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easeCubicIn", {
  enumerable: true,
  get: function () {
    return _cubic.cubicIn;
  }
});
Object.defineProperty(exports, "easeCubicInOut", {
  enumerable: true,
  get: function () {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easeCubicOut", {
  enumerable: true,
  get: function () {
    return _cubic.cubicOut;
  }
});
Object.defineProperty(exports, "easeElastic", {
  enumerable: true,
  get: function () {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeElasticIn", {
  enumerable: true,
  get: function () {
    return _elastic.elasticIn;
  }
});
Object.defineProperty(exports, "easeElasticInOut", {
  enumerable: true,
  get: function () {
    return _elastic.elasticInOut;
  }
});
Object.defineProperty(exports, "easeElasticOut", {
  enumerable: true,
  get: function () {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeExp", {
  enumerable: true,
  get: function () {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeExpIn", {
  enumerable: true,
  get: function () {
    return _exp.expIn;
  }
});
Object.defineProperty(exports, "easeExpInOut", {
  enumerable: true,
  get: function () {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeExpOut", {
  enumerable: true,
  get: function () {
    return _exp.expOut;
  }
});
Object.defineProperty(exports, "easeLinear", {
  enumerable: true,
  get: function () {
    return _linear.linear;
  }
});
Object.defineProperty(exports, "easePoly", {
  enumerable: true,
  get: function () {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easePolyIn", {
  enumerable: true,
  get: function () {
    return _poly.polyIn;
  }
});
Object.defineProperty(exports, "easePolyInOut", {
  enumerable: true,
  get: function () {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easePolyOut", {
  enumerable: true,
  get: function () {
    return _poly.polyOut;
  }
});
Object.defineProperty(exports, "easeQuad", {
  enumerable: true,
  get: function () {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeQuadIn", {
  enumerable: true,
  get: function () {
    return _quad.quadIn;
  }
});
Object.defineProperty(exports, "easeQuadInOut", {
  enumerable: true,
  get: function () {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeQuadOut", {
  enumerable: true,
  get: function () {
    return _quad.quadOut;
  }
});
Object.defineProperty(exports, "easeSin", {
  enumerable: true,
  get: function () {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeSinIn", {
  enumerable: true,
  get: function () {
    return _sin.sinIn;
  }
});
Object.defineProperty(exports, "easeSinInOut", {
  enumerable: true,
  get: function () {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeSinOut", {
  enumerable: true,
  get: function () {
    return _sin.sinOut;
  }
});

var _linear = require("./src/linear");

var _quad = require("./src/quad");

var _cubic = require("./src/cubic");

var _poly = require("./src/poly");

var _sin = require("./src/sin");

var _exp = require("./src/exp");

var _circle = require("./src/circle");

var _bounce = require("./src/bounce");

var _back = require("./src/back");

var _elastic = require("./src/elastic");

},{"./src/back":416,"./src/bounce":417,"./src/circle":418,"./src/cubic":419,"./src/elastic":420,"./src/exp":421,"./src/linear":422,"./src/poly":423,"./src/quad":424,"./src/sin":425}],416:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backOut = exports.backInOut = exports.backIn = void 0;
var overshoot = 1.70158;

var backIn = function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;
  return backIn;
}(overshoot);

exports.backIn = backIn;

var backOut = function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;
  return backOut;
}(overshoot);

exports.backOut = backOut;

var backInOut = function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;
  return backInOut;
}(overshoot);

exports.backInOut = backInOut;

},{}],417:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"dup":74}],418:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75}],419:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],420:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.elasticOut = exports.elasticInOut = exports.elasticIn = void 0;
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticIn.period = function (p) {
    return custom(a, p);
  };

  return elasticIn;
}(amplitude, period);

exports.elasticIn = elasticIn;

var elasticOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticOut.period = function (p) {
    return custom(a, p);
  };

  return elasticOut;
}(amplitude, period);

exports.elasticOut = elasticOut;

var elasticInOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticInOut.period = function (p) {
    return custom(a, p);
  };

  return elasticInOut;
}(amplitude, period);

exports.elasticInOut = elasticInOut;

},{}],421:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expIn = expIn;
exports.expInOut = expInOut;
exports.expOut = expOut;

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

},{}],422:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"dup":80}],423:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82}],424:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"dup":83}],425:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sinIn = sinIn;
exports.sinInOut = sinInOut;
exports.sinOut = sinOut;
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

},{}],426:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "arc", {
  enumerable: true,
  get: function () {
    return _arc.default;
  }
});
Object.defineProperty(exports, "area", {
  enumerable: true,
  get: function () {
    return _area.default;
  }
});
Object.defineProperty(exports, "areaRadial", {
  enumerable: true,
  get: function () {
    return _areaRadial.default;
  }
});
Object.defineProperty(exports, "curveBasis", {
  enumerable: true,
  get: function () {
    return _basis.default;
  }
});
Object.defineProperty(exports, "curveBasisClosed", {
  enumerable: true,
  get: function () {
    return _basisClosed.default;
  }
});
Object.defineProperty(exports, "curveBasisOpen", {
  enumerable: true,
  get: function () {
    return _basisOpen.default;
  }
});
Object.defineProperty(exports, "curveBundle", {
  enumerable: true,
  get: function () {
    return _bundle.default;
  }
});
Object.defineProperty(exports, "curveCardinal", {
  enumerable: true,
  get: function () {
    return _cardinal.default;
  }
});
Object.defineProperty(exports, "curveCardinalClosed", {
  enumerable: true,
  get: function () {
    return _cardinalClosed.default;
  }
});
Object.defineProperty(exports, "curveCardinalOpen", {
  enumerable: true,
  get: function () {
    return _cardinalOpen.default;
  }
});
Object.defineProperty(exports, "curveCatmullRom", {
  enumerable: true,
  get: function () {
    return _catmullRom.default;
  }
});
Object.defineProperty(exports, "curveCatmullRomClosed", {
  enumerable: true,
  get: function () {
    return _catmullRomClosed.default;
  }
});
Object.defineProperty(exports, "curveCatmullRomOpen", {
  enumerable: true,
  get: function () {
    return _catmullRomOpen.default;
  }
});
Object.defineProperty(exports, "curveLinear", {
  enumerable: true,
  get: function () {
    return _linear.default;
  }
});
Object.defineProperty(exports, "curveLinearClosed", {
  enumerable: true,
  get: function () {
    return _linearClosed.default;
  }
});
Object.defineProperty(exports, "curveMonotoneX", {
  enumerable: true,
  get: function () {
    return _monotone.monotoneX;
  }
});
Object.defineProperty(exports, "curveMonotoneY", {
  enumerable: true,
  get: function () {
    return _monotone.monotoneY;
  }
});
Object.defineProperty(exports, "curveNatural", {
  enumerable: true,
  get: function () {
    return _natural.default;
  }
});
Object.defineProperty(exports, "curveStep", {
  enumerable: true,
  get: function () {
    return _step.default;
  }
});
Object.defineProperty(exports, "curveStepAfter", {
  enumerable: true,
  get: function () {
    return _step.stepAfter;
  }
});
Object.defineProperty(exports, "curveStepBefore", {
  enumerable: true,
  get: function () {
    return _step.stepBefore;
  }
});
Object.defineProperty(exports, "line", {
  enumerable: true,
  get: function () {
    return _line.default;
  }
});
Object.defineProperty(exports, "lineRadial", {
  enumerable: true,
  get: function () {
    return _lineRadial.default;
  }
});
Object.defineProperty(exports, "linkHorizontal", {
  enumerable: true,
  get: function () {
    return _index.linkHorizontal;
  }
});
Object.defineProperty(exports, "linkRadial", {
  enumerable: true,
  get: function () {
    return _index.linkRadial;
  }
});
Object.defineProperty(exports, "linkVertical", {
  enumerable: true,
  get: function () {
    return _index.linkVertical;
  }
});
Object.defineProperty(exports, "pie", {
  enumerable: true,
  get: function () {
    return _pie.default;
  }
});
Object.defineProperty(exports, "pointRadial", {
  enumerable: true,
  get: function () {
    return _pointRadial.default;
  }
});
Object.defineProperty(exports, "radialArea", {
  enumerable: true,
  get: function () {
    return _areaRadial.default;
  }
});
Object.defineProperty(exports, "radialLine", {
  enumerable: true,
  get: function () {
    return _lineRadial.default;
  }
});
Object.defineProperty(exports, "stack", {
  enumerable: true,
  get: function () {
    return _stack.default;
  }
});
Object.defineProperty(exports, "stackOffsetDiverging", {
  enumerable: true,
  get: function () {
    return _diverging.default;
  }
});
Object.defineProperty(exports, "stackOffsetExpand", {
  enumerable: true,
  get: function () {
    return _expand.default;
  }
});
Object.defineProperty(exports, "stackOffsetNone", {
  enumerable: true,
  get: function () {
    return _none.default;
  }
});
Object.defineProperty(exports, "stackOffsetSilhouette", {
  enumerable: true,
  get: function () {
    return _silhouette.default;
  }
});
Object.defineProperty(exports, "stackOffsetWiggle", {
  enumerable: true,
  get: function () {
    return _wiggle.default;
  }
});
Object.defineProperty(exports, "stackOrderAscending", {
  enumerable: true,
  get: function () {
    return _ascending.default;
  }
});
Object.defineProperty(exports, "stackOrderDescending", {
  enumerable: true,
  get: function () {
    return _descending.default;
  }
});
Object.defineProperty(exports, "stackOrderInsideOut", {
  enumerable: true,
  get: function () {
    return _insideOut.default;
  }
});
Object.defineProperty(exports, "stackOrderNone", {
  enumerable: true,
  get: function () {
    return _none2.default;
  }
});
Object.defineProperty(exports, "stackOrderReverse", {
  enumerable: true,
  get: function () {
    return _reverse.default;
  }
});
Object.defineProperty(exports, "symbol", {
  enumerable: true,
  get: function () {
    return _symbol.default;
  }
});
Object.defineProperty(exports, "symbolCircle", {
  enumerable: true,
  get: function () {
    return _circle.default;
  }
});
Object.defineProperty(exports, "symbolCross", {
  enumerable: true,
  get: function () {
    return _cross.default;
  }
});
Object.defineProperty(exports, "symbolDiamond", {
  enumerable: true,
  get: function () {
    return _diamond.default;
  }
});
Object.defineProperty(exports, "symbolSquare", {
  enumerable: true,
  get: function () {
    return _square.default;
  }
});
Object.defineProperty(exports, "symbolStar", {
  enumerable: true,
  get: function () {
    return _star.default;
  }
});
Object.defineProperty(exports, "symbolTriangle", {
  enumerable: true,
  get: function () {
    return _triangle.default;
  }
});
Object.defineProperty(exports, "symbolWye", {
  enumerable: true,
  get: function () {
    return _wye.default;
  }
});
Object.defineProperty(exports, "symbols", {
  enumerable: true,
  get: function () {
    return _symbol.symbols;
  }
});

var _arc = _interopRequireDefault(require("./src/arc"));

var _area = _interopRequireDefault(require("./src/area"));

var _line = _interopRequireDefault(require("./src/line"));

var _pie = _interopRequireDefault(require("./src/pie"));

var _areaRadial = _interopRequireDefault(require("./src/areaRadial"));

var _lineRadial = _interopRequireDefault(require("./src/lineRadial"));

var _pointRadial = _interopRequireDefault(require("./src/pointRadial"));

var _index = require("./src/link/index");

var _symbol = _interopRequireWildcard(require("./src/symbol"));

var _circle = _interopRequireDefault(require("./src/symbol/circle"));

var _cross = _interopRequireDefault(require("./src/symbol/cross"));

var _diamond = _interopRequireDefault(require("./src/symbol/diamond"));

var _square = _interopRequireDefault(require("./src/symbol/square"));

var _star = _interopRequireDefault(require("./src/symbol/star"));

var _triangle = _interopRequireDefault(require("./src/symbol/triangle"));

var _wye = _interopRequireDefault(require("./src/symbol/wye"));

var _basisClosed = _interopRequireDefault(require("./src/curve/basisClosed"));

var _basisOpen = _interopRequireDefault(require("./src/curve/basisOpen"));

var _basis = _interopRequireDefault(require("./src/curve/basis"));

var _bundle = _interopRequireDefault(require("./src/curve/bundle"));

var _cardinalClosed = _interopRequireDefault(require("./src/curve/cardinalClosed"));

var _cardinalOpen = _interopRequireDefault(require("./src/curve/cardinalOpen"));

var _cardinal = _interopRequireDefault(require("./src/curve/cardinal"));

var _catmullRomClosed = _interopRequireDefault(require("./src/curve/catmullRomClosed"));

var _catmullRomOpen = _interopRequireDefault(require("./src/curve/catmullRomOpen"));

var _catmullRom = _interopRequireDefault(require("./src/curve/catmullRom"));

var _linearClosed = _interopRequireDefault(require("./src/curve/linearClosed"));

var _linear = _interopRequireDefault(require("./src/curve/linear"));

var _monotone = require("./src/curve/monotone");

var _natural = _interopRequireDefault(require("./src/curve/natural"));

var _step = _interopRequireWildcard(require("./src/curve/step"));

var _stack = _interopRequireDefault(require("./src/stack"));

var _expand = _interopRequireDefault(require("./src/offset/expand"));

var _diverging = _interopRequireDefault(require("./src/offset/diverging"));

var _none = _interopRequireDefault(require("./src/offset/none"));

var _silhouette = _interopRequireDefault(require("./src/offset/silhouette"));

var _wiggle = _interopRequireDefault(require("./src/offset/wiggle"));

var _ascending = _interopRequireDefault(require("./src/order/ascending"));

var _descending = _interopRequireDefault(require("./src/order/descending"));

var _insideOut = _interopRequireDefault(require("./src/order/insideOut"));

var _none2 = _interopRequireDefault(require("./src/order/none"));

var _reverse = _interopRequireDefault(require("./src/order/reverse"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./src/arc":427,"./src/area":428,"./src/areaRadial":429,"./src/curve/basis":432,"./src/curve/basisClosed":433,"./src/curve/basisOpen":434,"./src/curve/bundle":435,"./src/curve/cardinal":436,"./src/curve/cardinalClosed":437,"./src/curve/cardinalOpen":438,"./src/curve/catmullRom":439,"./src/curve/catmullRomClosed":440,"./src/curve/catmullRomOpen":441,"./src/curve/linear":442,"./src/curve/linearClosed":443,"./src/curve/monotone":444,"./src/curve/natural":445,"./src/curve/step":447,"./src/line":450,"./src/lineRadial":451,"./src/link/index":452,"./src/offset/diverging":455,"./src/offset/expand":456,"./src/offset/none":457,"./src/offset/silhouette":458,"./src/offset/wiggle":459,"./src/order/ascending":460,"./src/order/descending":461,"./src/order/insideOut":462,"./src/order/none":463,"./src/order/reverse":464,"./src/pie":465,"./src/pointRadial":467,"./src/stack":468,"./src/symbol":469,"./src/symbol/circle":470,"./src/symbol/cross":471,"./src/symbol/diamond":472,"./src/symbol/square":473,"./src/symbol/star":474,"./src/symbol/triangle":475,"./src/symbol/wye":476}],427:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = require("d3-path");

var _constant = _interopRequireDefault(require("./constant"));

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0,
      y10 = y1 - y0,
      x32 = x3 - x2,
      y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
} // Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html


function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0, _math.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0, _math.sqrt)((0, _math.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00; // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?

  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function _default() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0, _constant.default)(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math.halfPi,
        a1 = endAngle.apply(this, arguments) - _math.halfPi,
        da = (0, _math.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0, _d3Path.path)(); // Ensure that the outer radius is always larger than the inner radius.

    if (r1 < r0) r = r1, r1 = r0, r0 = r; // Is it a point?

    if (!(r1 > _math.epsilon)) context.moveTo(0, 0); // Or is it a circle or annulus?
    else if (da > _math.tau - _math.epsilon) {
      context.moveTo(r1 * (0, _math.cos)(a0), r1 * (0, _math.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);

      if (r0 > _math.epsilon) {
        context.moveTo(r0 * (0, _math.cos)(a1), r0 * (0, _math.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = ap > _math.epsilon && (padRadius ? +padRadius.apply(this, arguments) : (0, _math.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0, _math.min)((0, _math.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1; // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.

      if (rp > _math.epsilon) {
        var p0 = (0, _math.asin)(rp / r0 * (0, _math.sin)(ap)),
            p1 = (0, _math.asin)(rp / r1 * (0, _math.sin)(ap));
        if ((da0 -= p0 * 2) > _math.epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math.epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0, _math.cos)(a01),
          y01 = r1 * (0, _math.sin)(a01),
          x10 = r0 * (0, _math.cos)(a10),
          y10 = r0 * (0, _math.sin)(a10); // Apply rounded corners?

      if (rc > _math.epsilon) {
        var x11 = r1 * (0, _math.cos)(a11),
            y11 = r1 * (0, _math.sin)(a11),
            x00 = r0 * (0, _math.cos)(a00),
            y00 = r0 * (0, _math.sin)(a00); // Restrict the corner radius according to the sector angle.

        if (da < _math.pi) {
          var oc = da0 > _math.epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / (0, _math.sin)((0, _math.acos)((ax * bx + ay * by) / ((0, _math.sqrt)(ax * ax + ay * ay) * (0, _math.sqrt)(bx * bx + by * by))) / 2),
              lc = (0, _math.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = (0, _math.min)(rc, (r0 - lc) / (kc - 1));
          rc1 = (0, _math.min)(rc, (r1 - lc) / (kc + 1));
        }
      } // Is the sector collapsed to a line?


      if (!(da1 > _math.epsilon)) context.moveTo(x01, y01); // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01); // Have the corners merged?

        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t1.y01, t1.x01), !cw); // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0, _math.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, _math.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0, _math.atan2)(t1.y11, t1.x11), (0, _math.atan2)(t1.y01, t1.x01), !cw);
        }
      } // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw); // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?

      if (!(r0 > _math.epsilon) || !(da0 > _math.epsilon)) context.lineTo(x10, y10); // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01); // Have the corners merged?

        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t1.y01, t1.x01), !cw); // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0, _math.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, _math.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0, _math.atan2)(t1.y11, t1.x11), (0, _math.atan2)(t1.y01, t1.x01), !cw);
        }
      } // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function () {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math.pi / 2;
    return [(0, _math.cos)(a) * r, (0, _math.sin)(a) * r];
  };

  arc.innerRadius = function (_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : innerRadius;
  };

  arc.outerRadius = function (_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function (_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : cornerRadius;
  };

  arc.padRadius = function (_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : padRadius;
  };

  arc.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : startAngle;
  };

  arc.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : endAngle;
  };

  arc.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : padAngle;
  };

  arc.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };

  return arc;
}

},{"./constant":431,"./math":453,"d3-path":223}],428:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = require("d3-path");

var _constant = _interopRequireDefault(require("./constant"));

var _linear = _interopRequireDefault(require("./curve/linear"));

var _line = _interopRequireDefault(require("./line"));

var _point = require("./point");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var x0 = _point.x,
      x1 = null,
      y0 = (0, _constant.default)(0),
      y1 = _point.y,
      defined = (0, _constant.default)(true),
      context = null,
      curve = _linear.default,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);
    if (context == null) output = curve(buffer = (0, _d3Path.path)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();

          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }

          output.lineEnd();
          output.areaEnd();
        }
      }

      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0, _line.default)().defined(defined).curve(curve).context(context);
  }

  area.x = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), x1 = null, area) : x0;
  };

  area.x0 = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : x0;
  };

  area.x1 = function (_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : x1;
  };

  area.y = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), y1 = null, area) : y0;
  };

  area.y0 = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : y0;
  };

  area.y1 = function (_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : y1;
  };

  area.lineX0 = area.lineY0 = function () {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function () {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function () {
    return arealine().x(x1).y(y0);
  };

  area.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0, _constant.default)(!!_), area) : defined;
  };

  area.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

},{"./constant":431,"./curve/linear":442,"./line":450,"./point":466,"d3-path":223}],429:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _radial = _interopRequireWildcard(require("./curve/radial"));

var _area = _interopRequireDefault(require("./area"));

var _lineRadial = require("./lineRadial");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _default() {
  var a = (0, _area.default)().curve(_radial.curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;
  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function () {
    return (0, _lineRadial.lineRadial)(x0());
  }, delete a.lineX0;
  a.lineEndAngle = function () {
    return (0, _lineRadial.lineRadial)(x1());
  }, delete a.lineX1;
  a.lineInnerRadius = function () {
    return (0, _lineRadial.lineRadial)(y0());
  }, delete a.lineY0;
  a.lineOuterRadius = function () {
    return (0, _lineRadial.lineRadial)(y1());
  }, delete a.lineY1;

  a.curve = function (_) {
    return arguments.length ? c((0, _radial.default)(_)) : c()._curve;
  };

  return a;
}

},{"./area":428,"./curve/radial":446,"./lineRadial":451}],430:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],431:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return function constant() {
    return x;
  };
}

},{}],432:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Basis = Basis;
exports.default = _default;
exports.point = point;

function point(that, x, y) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      // proceed

      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;

        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);

      // proceed

      default:
        point(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new Basis(context);
}

},{}],433:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _noop = _interopRequireDefault(require("../noop"));

var _basis = require("./basis");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x2, this._y2);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);

          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
    }
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x, this._y2 = y;
        break;

      case 1:
        this._point = 2;
        this._x3 = x, this._y3 = y;
        break;

      case 2:
        this._point = 3;
        this._x4 = x, this._y4 = y;

        this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);

        break;

      default:
        (0, _basis.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new BasisClosed(context);
}

},{"../noop":454,"./basis":432}],434:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _basis = require("./basis");

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x) / 6,
            y0 = (this._y0 + 4 * this._y1 + y) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _basis.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new BasisOpen(context);
}

},{"./basis":432}],435:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _basis = require("./basis");

function Bundle(context, beta) {
  this._basis = new _basis.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function () {
    this._x = [];
    this._y = [];

    this._basis.lineStart();
  },
  lineEnd: function () {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;

        this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
      }
    }

    this._x = this._y = null;

    this._basis.lineEnd();
  },
  point: function (x, y) {
    this._x.push(+x);

    this._y.push(+y);
  }
};

var _default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new _basis.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function (beta) {
    return custom(+beta);
  };

  return bundle;
}(0.85);

exports.default = _default;

},{"./basis":432}],436:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cardinal = Cardinal;
exports.default = void 0;
exports.point = point;

function point(that, x, y) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);

        break;

      case 3:
        point(this, this._x1, this._y1);
        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        this._x1 = x, this._y1 = y;
        break;

      case 2:
        this._point = 3;
      // proceed

      default:
        point(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;

},{}],437:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardinalClosed = CardinalClosed;
exports.default = void 0;

var _noop = _interopRequireDefault(require("../noop"));

var _cardinal = require("./cardinal");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.lineTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x, this._y3 = y;
        break;

      case 1:
        this._point = 2;

        this._context.moveTo(this._x4 = x, this._y4 = y);

        break;

      case 2:
        this._point = 3;
        this._x5 = x, this._y5 = y;
        break;

      default:
        (0, _cardinal.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;

},{"../noop":454,"./cardinal":436}],438:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardinalOpen = CardinalOpen;
exports.default = void 0;

var _cardinal = require("./cardinal");

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _cardinal.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;

},{"./cardinal":436}],439:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.point = point;

var _math = require("../math");

var _cardinal = require("./cardinal");

function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);

        break;

      case 3:
        this.point(this._x2, this._y2);
        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
      // proceed

      default:
        point(this, x, y);
        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal.Cardinal(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;

},{"../math":453,"./cardinal":436}],440:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cardinalClosed = require("./cardinalClosed");

var _noop = _interopRequireDefault(require("../noop"));

var _catmullRom = require("./catmullRom");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.lineTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function (x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x, this._y3 = y;
        break;

      case 1:
        this._point = 2;

        this._context.moveTo(this._x4 = x, this._y4 = y);

        break;

      case 2:
        this._point = 3;
        this._x5 = x, this._y5 = y;
        break;

      default:
        (0, _catmullRom.point)(this, x, y);
        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;

},{"../noop":454,"./cardinalClosed":437,"./catmullRom":439}],441:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cardinalOpen = require("./cardinalOpen");

var _catmullRom = require("./catmullRom");

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function () {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _catmullRom.point)(this, x, y);
        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;

},{"./cardinalOpen":438,"./catmullRom":439}],442:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        this._context.lineTo(x, y);

        break;
    }
  }
};

function _default(context) {
  return new Linear(context);
}

},{}],443:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._point) this._context.closePath();
  },
  point: function (x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
  }
};

function _default(context) {
  return new LinearClosed(context);
}

},{"../noop":454}],444:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.monotoneX = monotoneX;
exports.monotoneY = monotoneY;

function sign(x) {
  return x < 0 ? -1 : 1;
} // Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.


function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
} // Calculate a one-sided slope.


function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
} // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".


function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;

  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;

      case 3:
        point(this, this._t0, slope2(this, this._t0));
        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    var t1 = NaN;
    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        point(this, slope2(this, t1 = slope3(this, x, y)), t1);
        break;

      default:
        point(this, this._t0, t1 = slope3(this, x, y));
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function (x, y) {
    this._context.moveTo(y, x);
  },
  closePath: function () {
    this._context.closePath();
  },
  lineTo: function (x, y) {
    this._context.lineTo(y, x);
  },
  bezierCurveTo: function (x1, y1, x2, y2, x, y) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
  }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

},{}],445:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x = [];
    this._y = [];
  },
  lineEnd: function () {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);

      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);

        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function (x, y) {
    this._x.push(+x);

    this._y.push(+y);
  }
}; // See https://www.particleincell.com/2012/bezier-splines/ for derivation.

function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];

  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];

  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];

  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];

  a[n - 1] = r[n - 1] / b[n - 1];

  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];

  b[n - 1] = (x[n] + a[n - 1]) / 2;

  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];

  return [a, b];
}

function _default(context) {
  return new Natural(context);
}

},{}],446:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.curveRadialLinear = void 0;
exports.default = curveRadial;

var _linear = _interopRequireDefault(require("./linear"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var curveRadialLinear = curveRadial(_linear.default);
exports.curveRadialLinear = curveRadialLinear;

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function () {
    this._curve.areaStart();
  },
  areaEnd: function () {
    this._curve.areaEnd();
  },
  lineStart: function () {
    this._curve.lineStart();
  },
  lineEnd: function () {
    this._curve.lineEnd();
  },
  point: function (a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;
  return radial;
}

},{"./linear":442}],447:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.stepAfter = stepAfter;
exports.stepBefore = stepBefore;

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);

            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;

            this._context.lineTo(x1, this._y);

            this._context.lineTo(x1, y);
          }

          break;
        }
    }

    this._x = x, this._y = y;
  }
};

function _default(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

},{}],448:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],449:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(d) {
  return d;
}

},{}],450:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = require("d3-path");

var _constant = _interopRequireDefault(require("./constant"));

var _linear = _interopRequireDefault(require("./curve/linear"));

var _point = require("./point");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var x = _point.x,
      y = _point.y,
      defined = (0, _constant.default)(true),
      context = null,
      curve = _linear.default,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;
    if (context == null) output = curve(buffer = (0, _d3Path.path)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();else output.lineEnd();
      }

      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), line) : x;
  };

  line.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), line) : y;
  };

  line.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0, _constant.default)(!!_), line) : defined;
  };

  line.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

},{"./constant":431,"./curve/linear":442,"./point":466,"d3-path":223}],451:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.lineRadial = lineRadial;

var _radial = _interopRequireWildcard(require("./curve/radial"));

var _line = _interopRequireDefault(require("./line"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function lineRadial(l) {
  var c = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function (_) {
    return arguments.length ? c((0, _radial.default)(_)) : c()._curve;
  };

  return l;
}

function _default() {
  return lineRadial((0, _line.default)().curve(_radial.curveRadialLinear));
}

},{"./curve/radial":446,"./line":450}],452:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linkHorizontal = linkHorizontal;
exports.linkRadial = linkRadial;
exports.linkVertical = linkVertical;

var _d3Path = require("d3-path");

var _array = require("../array");

var _constant = _interopRequireDefault(require("../constant"));

var _point = require("../point");

var _pointRadial = _interopRequireDefault(require("../pointRadial"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x = _point.x,
      y = _point.y,
      context = null;

  function link() {
    var buffer,
        argv = _array.slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv);

    if (!context) context = buffer = (0, _d3Path.path)();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function (_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function (_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), link) : x;
  };

  link.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), link) : y;
  };

  link.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial(context, x0, y0, x1, y1) {
  var p0 = (0, _pointRadial.default)(x0, y0),
      p1 = (0, _pointRadial.default)(x0, y0 = (y0 + y1) / 2),
      p2 = (0, _pointRadial.default)(x1, y0),
      p3 = (0, _pointRadial.default)(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

},{"../array":430,"../constant":431,"../point":466,"../pointRadial":467,"d3-path":223}],453:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abs = void 0;
exports.acos = acos;
exports.asin = asin;
exports.tau = exports.sqrt = exports.sin = exports.pi = exports.min = exports.max = exports.halfPi = exports.epsilon = exports.cos = exports.atan2 = void 0;
var abs = Math.abs;
exports.abs = abs;
var atan2 = Math.atan2;
exports.atan2 = atan2;
var cos = Math.cos;
exports.cos = cos;
var max = Math.max;
exports.max = max;
var min = Math.min;
exports.min = min;
var sin = Math.sin;
exports.sin = sin;
var sqrt = Math.sqrt;
exports.sqrt = sqrt;
var epsilon = 1e-12;
exports.epsilon = epsilon;
var pi = Math.PI;
exports.pi = pi;
var halfPi = pi / 2;
exports.halfPi = halfPi;
var tau = 2 * pi;
exports.tau = tau;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

},{}],454:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {}

},{}],455:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series, order) {
  if (!((n = series.length) > 1)) return;

  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}

},{}],456:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series, order) {
  if (!((n = series.length) > 0)) return;

  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;

    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }

  (0, _none.default)(series, order);
}

},{"./none":457}],457:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series, order) {
  if (!((n = series.length) > 1)) return;

  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];

    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

},{}],458:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series, order) {
  if (!((n = series.length) > 0)) return;

  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;

    s0[j][1] += s0[j][0] = -y / 2;
  }

  (0, _none.default)(series, order);
}

},{"./none":457}],459:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;

  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;

      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }

      s1 += sij0, s2 += s3 * sij0;
    }

    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }

  s0[j - 1][1] += s0[j - 1][0] = y;
  (0, _none.default)(series, order);
}

},{"./none":457}],460:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.sum = sum;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series) {
  var sums = series.map(sum);
  return (0, _none.default)(series).sort(function (a, b) {
    return sums[a] - sums[b];
  });
}

function sum(series) {
  var s = 0,
      i = -1,
      n = series.length,
      v;

  while (++i < n) if (v = +series[i][1]) s += v;

  return s;
}

},{"./none":463}],461:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(require("./ascending"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series) {
  return (0, _ascending.default)(series).reverse();
}

},{"./ascending":460}],462:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

var _ascending = require("./ascending");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending.sum),
      order = (0, _none.default)(series).sort(function (a, b) {
    return sums[b] - sums[a];
  }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];

    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

},{"./ascending":460,"./none":463}],463:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series) {
  var n = series.length,
      o = new Array(n);

  while (--n >= 0) o[n] = n;

  return o;
}

},{}],464:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series) {
  return (0, _none.default)(series).reverse();
}

},{"./none":463}],465:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _descending = _interopRequireDefault(require("./descending"));

var _identity = _interopRequireDefault(require("./identity"));

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var value = _identity.default,
      sortValues = _descending.default,
      sort = null,
      startAngle = (0, _constant.default)(0),
      endAngle = (0, _constant.default)(_math.tau),
      padAngle = (0, _constant.default)(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math.tau, Math.max(-_math.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    } // Optionally sort the arcs by previously-computed values or by data.


    if (sortValues != null) index.sort(function (i, j) {
      return sortValues(arcs[i], arcs[j]);
    });else if (sort != null) index.sort(function (i, j) {
      return sort(data[i], data[j]);
    }); // Compute the arcs! They are stored in the original data's order.

    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : value;
  };

  pie.sortValues = function (_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function (_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : startAngle;
  };

  pie.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : endAngle;
  };

  pie.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : padAngle;
  };

  return pie;
}

},{"./constant":431,"./descending":448,"./identity":449,"./math":453}],466:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.x = x;
exports.y = y;

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

},{}],467:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

},{}],468:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("./array");

var _constant = _interopRequireDefault(require("./constant"));

var _none = _interopRequireDefault(require("./offset/none"));

var _none2 = _interopRequireDefault(require("./order/none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stackValue(d, key) {
  return d[key];
}

function _default() {
  var keys = (0, _constant.default)([]),
      order = _none2.default,
      offset = _none.default,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }

      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function (_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : (0, _constant.default)(_array.slice.call(_)), stack) : keys;
  };

  stack.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(+_), stack) : value;
  };

  stack.order = function (_) {
    return arguments.length ? (order = _ == null ? _none2.default : typeof _ === "function" ? _ : (0, _constant.default)(_array.slice.call(_)), stack) : order;
  };

  stack.offset = function (_) {
    return arguments.length ? (offset = _ == null ? _none.default : _, stack) : offset;
  };

  return stack;
}

},{"./array":430,"./constant":431,"./offset/none":457,"./order/none":463}],469:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.symbols = void 0;

var _d3Path = require("d3-path");

var _circle = _interopRequireDefault(require("./symbol/circle"));

var _cross = _interopRequireDefault(require("./symbol/cross"));

var _diamond = _interopRequireDefault(require("./symbol/diamond"));

var _star = _interopRequireDefault(require("./symbol/star"));

var _square = _interopRequireDefault(require("./symbol/square"));

var _triangle = _interopRequireDefault(require("./symbol/triangle"));

var _wye = _interopRequireDefault(require("./symbol/wye"));

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var symbols = [_circle.default, _cross.default, _diamond.default, _square.default, _star.default, _triangle.default, _wye.default];
exports.symbols = symbols;

function _default() {
  var type = (0, _constant.default)(_circle.default),
      size = (0, _constant.default)(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0, _d3Path.path)();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function (_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0, _constant.default)(_), symbol) : type;
  };

  symbol.size = function (_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0, _constant.default)(+_), symbol) : size;
  };

  symbol.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

},{"./constant":431,"./symbol/circle":470,"./symbol/cross":471,"./symbol/diamond":472,"./symbol/square":473,"./symbol/star":474,"./symbol/triangle":475,"./symbol/wye":476,"d3-path":223}],470:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("../math");

var _default = {
  draw: function (context, size) {
    var r = Math.sqrt(size / _math.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math.tau);
  }
};
exports.default = _default;

},{"../math":453}],471:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  draw: function (context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};
exports.default = _default;

},{}],472:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;
var _default = {
  draw: function (context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};
exports.default = _default;

},{}],473:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  draw: function (context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};
exports.default = _default;

},{}],474:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("../math");

var ka = 0.89081309152928522810,
    kr = Math.sin(_math.pi / 10) / Math.sin(7 * _math.pi / 10),
    kx = Math.sin(_math.tau / 10) * kr,
    ky = -Math.cos(_math.tau / 10) * kr;
var _default = {
  draw: function (context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);

    for (var i = 1; i < 5; ++i) {
      var a = _math.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }

    context.closePath();
  }
};
exports.default = _default;

},{"../math":453}],475:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var sqrt3 = Math.sqrt(3);
var _default = {
  draw: function (context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};
exports.default = _default;

},{}],476:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;
var _default = {
  draw: function (context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};
exports.default = _default;

},{}],477:[function(require,module,exports){
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};

},{"isobject":478}],478:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

},{}],479:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _hashClear = _interopRequireDefault(require("./_hashClear.js"));

var _hashDelete = _interopRequireDefault(require("./_hashDelete.js"));

var _hashGet = _interopRequireDefault(require("./_hashGet.js"));

var _hashHas = _interopRequireDefault(require("./_hashHas.js"));

var _hashSet = _interopRequireDefault(require("./_hashSet.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = _hashClear.default;
Hash.prototype['delete'] = _hashDelete.default;
Hash.prototype.get = _hashGet.default;
Hash.prototype.has = _hashHas.default;
Hash.prototype.set = _hashSet.default;
var _default = Hash;
exports.default = _default;

},{"./_hashClear.js":494,"./_hashDelete.js":495,"./_hashGet.js":496,"./_hashHas.js":497,"./_hashSet.js":498}],480:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _listCacheClear = _interopRequireDefault(require("./_listCacheClear.js"));

var _listCacheDelete = _interopRequireDefault(require("./_listCacheDelete.js"));

var _listCacheGet = _interopRequireDefault(require("./_listCacheGet.js"));

var _listCacheHas = _interopRequireDefault(require("./_listCacheHas.js"));

var _listCacheSet = _interopRequireDefault(require("./_listCacheSet.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = _listCacheClear.default;
ListCache.prototype['delete'] = _listCacheDelete.default;
ListCache.prototype.get = _listCacheGet.default;
ListCache.prototype.has = _listCacheHas.default;
ListCache.prototype.set = _listCacheSet.default;
var _default = ListCache;
exports.default = _default;

},{"./_listCacheClear.js":501,"./_listCacheDelete.js":502,"./_listCacheGet.js":503,"./_listCacheHas.js":504,"./_listCacheSet.js":505}],481:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getNative = _interopRequireDefault(require("./_getNative.js"));

var _root = _interopRequireDefault(require("./_root.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Built-in method references that are verified to be native. */
var Map = (0, _getNative.default)(_root.default, 'Map');
var _default = Map;
exports.default = _default;

},{"./_getNative.js":490,"./_root.js":514}],482:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mapCacheClear = _interopRequireDefault(require("./_mapCacheClear.js"));

var _mapCacheDelete = _interopRequireDefault(require("./_mapCacheDelete.js"));

var _mapCacheGet = _interopRequireDefault(require("./_mapCacheGet.js"));

var _mapCacheHas = _interopRequireDefault(require("./_mapCacheHas.js"));

var _mapCacheSet = _interopRequireDefault(require("./_mapCacheSet.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = _mapCacheClear.default;
MapCache.prototype['delete'] = _mapCacheDelete.default;
MapCache.prototype.get = _mapCacheGet.default;
MapCache.prototype.has = _mapCacheHas.default;
MapCache.prototype.set = _mapCacheSet.default;
var _default = MapCache;
exports.default = _default;

},{"./_mapCacheClear.js":506,"./_mapCacheDelete.js":507,"./_mapCacheGet.js":508,"./_mapCacheHas.js":509,"./_mapCacheSet.js":510}],483:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _root = _interopRequireDefault(require("./_root.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var Symbol = _root.default.Symbol;
var _default = Symbol;
exports.default = _default;

},{"./_root.js":514}],484:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _eq = _interopRequireDefault(require("./eq.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if ((0, _eq.default)(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

var _default = assocIndexOf;
exports.default = _default;

},{"./eq.js":516}],485:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Symbol = _interopRequireDefault(require("./_Symbol.js"));

var _getRawTag = _interopRequireDefault(require("./_getRawTag.js"));

var _objectToString = _interopRequireDefault(require("./_objectToString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol.default ? _Symbol.default.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? (0, _getRawTag.default)(value) : (0, _objectToString.default)(value);
}

var _default = baseGetTag;
exports.default = _default;

},{"./_Symbol.js":483,"./_getRawTag.js":492,"./_objectToString.js":512}],486:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isFunction = _interopRequireDefault(require("./isFunction.js"));

var _isMasked = _interopRequireDefault(require("./_isMasked.js"));

var _isObject = _interopRequireDefault(require("./isObject.js"));

var _toSource = _interopRequireDefault(require("./_toSource.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!(0, _isObject.default)(value) || (0, _isMasked.default)(value)) {
    return false;
  }

  var pattern = (0, _isFunction.default)(value) ? reIsNative : reIsHostCtor;
  return pattern.test((0, _toSource.default)(value));
}

var _default = baseIsNative;
exports.default = _default;

},{"./_isMasked.js":500,"./_toSource.js":515,"./isFunction.js":518,"./isObject.js":519}],487:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _root = _interopRequireDefault(require("./_root.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to detect overreaching core-js shims. */
var coreJsData = _root.default['__core-js_shared__'];
var _default = coreJsData;
exports.default = _default;

},{"./_root.js":514}],488:[function(require,module,exports){
(function (global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var _default = freeGlobal;
exports.default = _default;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],489:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isKeyable = _interopRequireDefault(require("./_isKeyable.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return (0, _isKeyable.default)(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

var _default = getMapData;
exports.default = _default;

},{"./_isKeyable.js":499}],490:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseIsNative = _interopRequireDefault(require("./_baseIsNative.js"));

var _getValue = _interopRequireDefault(require("./_getValue.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = (0, _getValue.default)(object, key);
  return (0, _baseIsNative.default)(value) ? value : undefined;
}

var _default = getNative;
exports.default = _default;

},{"./_baseIsNative.js":486,"./_getValue.js":493}],491:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _overArg = _interopRequireDefault(require("./_overArg.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var getPrototype = (0, _overArg.default)(Object.getPrototypeOf, Object);
var _default = getPrototype;
exports.default = _default;

},{"./_overArg.js":513}],492:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Symbol = _interopRequireDefault(require("./_Symbol.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol.default ? _Symbol.default.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

var _default = getRawTag;
exports.default = _default;

},{"./_Symbol.js":483}],493:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _default = getValue;
exports.default = _default;

},{}],494:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _nativeCreate = _interopRequireDefault(require("./_nativeCreate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate.default ? (0, _nativeCreate.default)(null) : {};
  this.size = 0;
}

var _default = hashClear;
exports.default = _default;

},{"./_nativeCreate.js":511}],495:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _default = hashDelete;
exports.default = _default;

},{}],496:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _nativeCreate = _interopRequireDefault(require("./_nativeCreate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (_nativeCreate.default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

var _default = hashGet;
exports.default = _default;

},{"./_nativeCreate.js":511}],497:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _nativeCreate = _interopRequireDefault(require("./_nativeCreate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate.default ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

var _default = hashHas;
exports.default = _default;

},{"./_nativeCreate.js":511}],498:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _nativeCreate = _interopRequireDefault(require("./_nativeCreate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate.default && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

var _default = hashSet;
exports.default = _default;

},{"./_nativeCreate.js":511}],499:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

var _default = isKeyable;
exports.default = _default;

},{}],500:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _coreJsData = _interopRequireDefault(require("./_coreJsData.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(_coreJsData.default && _coreJsData.default.keys && _coreJsData.default.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

var _default = isMasked;
exports.default = _default;

},{"./_coreJsData.js":487}],501:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _default = listCacheClear;
exports.default = _default;

},{}],502:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assocIndexOf = _interopRequireDefault(require("./_assocIndexOf.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = (0, _assocIndexOf.default)(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

var _default = listCacheDelete;
exports.default = _default;

},{"./_assocIndexOf.js":484}],503:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assocIndexOf = _interopRequireDefault(require("./_assocIndexOf.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = (0, _assocIndexOf.default)(data, key);
  return index < 0 ? undefined : data[index][1];
}

var _default = listCacheGet;
exports.default = _default;

},{"./_assocIndexOf.js":484}],504:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assocIndexOf = _interopRequireDefault(require("./_assocIndexOf.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return (0, _assocIndexOf.default)(this.__data__, key) > -1;
}

var _default = listCacheHas;
exports.default = _default;

},{"./_assocIndexOf.js":484}],505:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assocIndexOf = _interopRequireDefault(require("./_assocIndexOf.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = (0, _assocIndexOf.default)(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

var _default = listCacheSet;
exports.default = _default;

},{"./_assocIndexOf.js":484}],506:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Hash = _interopRequireDefault(require("./_Hash.js"));

var _ListCache = _interopRequireDefault(require("./_ListCache.js"));

var _Map = _interopRequireDefault(require("./_Map.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash.default(),
    'map': new (_Map.default || _ListCache.default)(),
    'string': new _Hash.default()
  };
}

var _default = mapCacheClear;
exports.default = _default;

},{"./_Hash.js":479,"./_ListCache.js":480,"./_Map.js":481}],507:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getMapData = _interopRequireDefault(require("./_getMapData.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = (0, _getMapData.default)(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _default = mapCacheDelete;
exports.default = _default;

},{"./_getMapData.js":489}],508:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getMapData = _interopRequireDefault(require("./_getMapData.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return (0, _getMapData.default)(this, key).get(key);
}

var _default = mapCacheGet;
exports.default = _default;

},{"./_getMapData.js":489}],509:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getMapData = _interopRequireDefault(require("./_getMapData.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return (0, _getMapData.default)(this, key).has(key);
}

var _default = mapCacheHas;
exports.default = _default;

},{"./_getMapData.js":489}],510:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getMapData = _interopRequireDefault(require("./_getMapData.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = (0, _getMapData.default)(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _default = mapCacheSet;
exports.default = _default;

},{"./_getMapData.js":489}],511:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getNative = _interopRequireDefault(require("./_getNative.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Built-in method references that are verified to be native. */
var nativeCreate = (0, _getNative.default)(Object, 'create');
var _default = nativeCreate;
exports.default = _default;

},{"./_getNative.js":490}],512:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

var _default = objectToString;
exports.default = _default;

},{}],513:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

var _default = overArg;
exports.default = _default;

},{}],514:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _freeGlobal = _interopRequireDefault(require("./_freeGlobal.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = _freeGlobal.default || freeSelf || Function('return this')();
var _default = root;
exports.default = _default;

},{"./_freeGlobal.js":488}],515:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

var _default = toSource;
exports.default = _default;

},{}],516:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

var _default = eq;
exports.default = _default;

},{}],517:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isObjectLike = _interopRequireDefault(require("./isObjectLike.js"));

var _isPlainObject = _interopRequireDefault(require("./isPlainObject.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Checks if `value` is likely a DOM element.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
 * @example
 *
 * _.isElement(document.body);
 * // => true
 *
 * _.isElement('<body>');
 * // => false
 */
function isElement(value) {
  return (0, _isObjectLike.default)(value) && value.nodeType === 1 && !(0, _isPlainObject.default)(value);
}

var _default = isElement;
exports.default = _default;

},{"./isObjectLike.js":520,"./isPlainObject.js":521}],518:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(require("./_baseGetTag.js"));

var _isObject = _interopRequireDefault(require("./isObject.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!(0, _isObject.default)(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = (0, _baseGetTag.default)(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var _default = isFunction;
exports.default = _default;

},{"./_baseGetTag.js":485,"./isObject.js":519}],519:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var _default = isObject;
exports.default = _default;

},{}],520:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var _default = isObjectLike;
exports.default = _default;

},{}],521:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(require("./_baseGetTag.js"));

var _getPrototype = _interopRequireDefault(require("./_getPrototype.js"));

var _isObjectLike = _interopRequireDefault(require("./isObjectLike.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!(0, _isObjectLike.default)(value) || (0, _baseGetTag.default)(value) != objectTag) {
    return false;
  }

  var proto = (0, _getPrototype.default)(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

var _default = isPlainObject;
exports.default = _default;

},{"./_baseGetTag.js":485,"./_getPrototype.js":491,"./isObjectLike.js":520}],522:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapCache = _interopRequireDefault(require("./_MapCache.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || _MapCache.default)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = _MapCache.default;
var _default = memoize;
exports.default = _default;

},{"./_MapCache.js":482}],523:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],524:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Easing = exports.EaseName = void 0;
var d3Ease = require("d3-ease");
var coerceD3_1 = require("../utils/coerceD3");
var makeEnum_1 = require("../utils/makeEnum");
var EASE_NAME_MAPPING = {
    linear: d3Ease.easeLinear,
    quad: d3Ease.easeQuad,
    quadIn: d3Ease.easeQuadIn,
    quadOut: d3Ease.easeQuadOut,
    quadInOut: d3Ease.easeQuadInOut,
    cubic: d3Ease.easeCubic,
    cubicIn: d3Ease.easeCubicIn,
    cubicOut: d3Ease.easeCubicOut,
    cubicInOut: d3Ease.easeCubicInOut,
    poly: d3Ease.easePoly,
    polyIn: d3Ease.easePolyIn,
    polyOut: d3Ease.easePolyOut,
    polyInOut: d3Ease.easePolyInOut,
    sin: d3Ease.easeSin,
    sinIn: d3Ease.easeSinIn,
    sinOut: d3Ease.easeSinOut,
    sinInOut: d3Ease.easeSinInOut,
    exp: d3Ease.easeExp,
    expIn: d3Ease.easeExpIn,
    expOut: d3Ease.easeExpOut,
    expInOut: d3Ease.easeExpInOut,
    circle: d3Ease.easeCircle,
    circleIn: d3Ease.easeCircleIn,
    circleOut: d3Ease.easeCircleOut,
    circleInOut: d3Ease.easeCircleInOut,
    bounce: d3Ease.easeBounce,
    bounceIn: d3Ease.easeBounceIn,
    bounceOut: d3Ease.easeBounceOut,
    bounceInOut: d3Ease.easeBounceInOut,
    back: d3Ease.easeBack,
    backIn: d3Ease.easeBackIn,
    backOut: d3Ease.easeBackOut,
    backInOut: d3Ease.easeBackInOut,
    elastic: d3Ease.easeElastic,
    elasticIn: d3Ease.easeElasticIn,
    elasticOut: d3Ease.easeElasticOut,
    elasticInOut: d3Ease.easeElasticInOut,
};
exports.EaseName = (0, makeEnum_1.makeEnum)([
    "linear",
    "quad",
    "quadIn",
    "quadOut",
    "quadInOut",
    "cubic",
    "cubicIn",
    "cubicOut",
    "cubicInOut",
    "poly",
    "polyIn",
    "polyOut",
    "polyInOut",
    "sin",
    "sinIn",
    "sinOut",
    "sinInOut",
    "exp",
    "expIn",
    "expOut",
    "expInOut",
    "circle",
    "circleIn",
    "circleOut",
    "circleInOut",
    "bounce",
    "bounceIn",
    "bounceOut",
    "bounceInOut",
    "back",
    "backIn",
    "backOut",
    "backInOut",
    "elastic",
    "elasticIn",
    "elasticOut",
    "elasticInOut",
]);
/**
 * An Animator with easing and configurable durations and delays.
 */
var Easing = /** @class */ (function () {
    /**
     * Constructs the default animator
     *
     * @constructor
     */
    function Easing() {
        this._startDelay = Easing._DEFAULT_START_DELAY_MILLISECONDS;
        this._stepDuration = Easing._DEFAULT_STEP_DURATION_MILLISECONDS;
        this._stepDelay = Easing._DEFAULT_ITERATIVE_DELAY_MILLISECONDS;
        this._maxTotalDuration = Easing._DEFAULT_MAX_TOTAL_DURATION_MILLISECONDS;
        this._easingMode = Easing._DEFAULT_EASING_MODE;
    }
    Easing.prototype.totalTime = function (numberOfSteps) {
        var adjustedIterativeDelay = this._getAdjustedIterativeDelay(numberOfSteps);
        return this.startDelay() + adjustedIterativeDelay * (Math.max(numberOfSteps - 1, 0)) + this.stepDuration();
    };
    Easing.prototype.animate = function (selection, attrToAppliedProjector) {
        var _this = this;
        selection = (0, coerceD3_1.coerceExternalD3)(selection);
        var numberOfSteps = selection.size();
        var adjustedIterativeDelay = this._getAdjustedIterativeDelay(numberOfSteps);
        return selection.transition()
            .ease(this._getEaseFactory())
            .duration(this.stepDuration())
            .delay(function (d, i) { return _this.startDelay() + adjustedIterativeDelay * i; })
            .attrs(attrToAppliedProjector);
    };
    Easing.prototype.startDelay = function (startDelay) {
        if (startDelay == null) {
            return this._startDelay;
        }
        else {
            this._startDelay = startDelay;
            return this;
        }
    };
    Easing.prototype.stepDuration = function (stepDuration) {
        if (stepDuration == null) {
            return Math.min(this._stepDuration, this._maxTotalDuration);
        }
        else {
            this._stepDuration = stepDuration;
            return this;
        }
    };
    Easing.prototype.stepDelay = function (stepDelay) {
        if (stepDelay == null) {
            return this._stepDelay;
        }
        else {
            this._stepDelay = stepDelay;
            return this;
        }
    };
    Easing.prototype.maxTotalDuration = function (maxTotalDuration) {
        if (maxTotalDuration == null) {
            return this._maxTotalDuration;
        }
        else {
            this._maxTotalDuration = maxTotalDuration;
            return this;
        }
    };
    Easing.prototype.easingMode = function (easingMode) {
        if (easingMode == null) {
            return this._easingMode;
        }
        else {
            this._easingMode = easingMode;
            return this;
        }
    };
    Easing.prototype._getEaseFactory = function () {
        var ease = this.easingMode();
        if (typeof ease === "string") {
            var maybeEaseFunction = EASE_NAME_MAPPING[ease];
            if (maybeEaseFunction == null) {
                // oops; name is wrong - default to linear instead
                return EASE_NAME_MAPPING["linear"];
            }
            else {
                return maybeEaseFunction;
            }
        }
        else {
            return ease;
        }
    };
    /**
     * Adjust the iterative delay, such that it takes into account the maxTotalDuration constraint
     */
    Easing.prototype._getAdjustedIterativeDelay = function (numberOfSteps) {
        var stepStartTimeInterval = this.maxTotalDuration() - this.stepDuration();
        stepStartTimeInterval = Math.max(stepStartTimeInterval, 0);
        var maxPossibleIterativeDelay = stepStartTimeInterval / Math.max(numberOfSteps - 1, 1);
        return Math.min(this.stepDelay(), maxPossibleIterativeDelay);
    };
    /**
     * The default starting delay of the animation in milliseconds
     */
    Easing._DEFAULT_START_DELAY_MILLISECONDS = 0;
    /**
     * The default duration of one animation step in milliseconds
     */
    Easing._DEFAULT_STEP_DURATION_MILLISECONDS = 300;
    /**
     * The default maximum start delay between each step of an animation
     */
    Easing._DEFAULT_ITERATIVE_DELAY_MILLISECONDS = 15;
    /**
     * The default maximum total animation duration
     */
    Easing._DEFAULT_MAX_TOTAL_DURATION_MILLISECONDS = Infinity;
    /**
     * The default easing of the animation
     */
    Easing._DEFAULT_EASING_MODE = "expOut";
    return Easing;
}());
exports.Easing = Easing;

},{"../utils/coerceD3":620,"../utils/makeEnum":625,"d3-ease":79}],525:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
(0, tslib_1.__exportStar)(require("./easingAnimator"), exports);
(0, tslib_1.__exportStar)(require("./nullAnimator"), exports);

},{"./easingAnimator":524,"./nullAnimator":526,"tslib":635}],526:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Null = void 0;
var coerceD3_1 = require("../utils/coerceD3");
/**
 * An animator implementation with no animation. The attributes are
 * immediately set on the selection.
 */
var Null = /** @class */ (function () {
    function Null() {
    }
    Null.prototype.totalTime = function (selection) {
        return 0;
    };
    Null.prototype.animate = function (selection, attrToAppliedProjector) {
        selection = (0, coerceD3_1.coerceExternalD3)(selection);
        return selection.attrs(attrToAppliedProjector);
    };
    return Null;
}());
exports.Null = Null;

},{"../utils/coerceD3":620}],527:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Axis = exports.AxisOrientation = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Typesettable = require("typesettable");
var component_1 = require("../components/component");
var label_1 = require("../components/label");
var Formatters = require("../core/formatters");
var Utils = require("../utils");
var makeEnum_1 = require("../utils/makeEnum");
exports.AxisOrientation = (0, makeEnum_1.makeEnum)(["bottom", "left", "right", "top"]);
var Axis = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Axis, _super);
    /**
     * Constructs an Axis.
     * An Axis is a visual representation of a Scale.
     *
     * @constructor
     * @param {Scale} scale
     * @param {AxisOrientation} orientation Orientation of this Axis.
     */
    function Axis(scale, orientation) {
        var _this = _super.call(this) || this;
        /**
         * `protected` instead of `private` to accommodate time axes which draw their own label containers
         * and need access to this value.
         */
        _this._tickLabelFontSize = label_1.Label._DEFAULT_FONT_SIZE_PX;
        _this._endTickLength = 5;
        _this._innerTickLength = 5;
        _this._tickLabelPadding = 10;
        _this._margin = 15;
        _this._showEndTickLabels = false;
        _this._annotationsEnabled = false;
        _this._annotationTierCount = 1;
        if (scale == null || orientation == null) {
            throw new Error("Axis requires a scale and orientation");
        }
        _this._scale = scale;
        _this.orientation(orientation);
        _this._setDefaultAlignment();
        _this.addClass("axis");
        if (_this.isHorizontal()) {
            _this.addClass("x-axis");
        }
        else {
            _this.addClass("y-axis");
        }
        _this.formatter(Formatters.identity());
        _this._rescaleCallback = function (newScale) { return _this._rescale(); };
        _this._scale.onUpdate(_this._rescaleCallback);
        _this._annotatedTicks = [];
        _this._annotationFormatter = Formatters.identity();
        return _this;
    }
    Axis.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this._scale.offUpdate(this._rescaleCallback);
    };
    /**
     * Gets the tick label data on a element. Element in argument must be a descendent of a tick label element.
     *
     * @param {Element} element
     */
    Axis.prototype.tickLabelDataOnElement = function (element) {
        if (element == null) {
            return undefined;
        }
        var tickLabel;
        // go up DOM tree to find tick label element in ancestor elements
        while ((element != null) && (element.classList) && (tickLabel === undefined)) {
            if (element.classList.contains(Axis.TICK_LABEL_CLASS)) {
                tickLabel = element;
            }
            else {
                element = element.parentNode;
            }
        }
        return element === undefined ? undefined : d3.select(element).datum();
    };
    Axis.prototype.tickLabelFontSize = function (fontSize) {
        if (fontSize == null) {
            return this._tickLabelFontSize;
        }
        else {
            this._tickLabelFontSize = fontSize;
            if (this._tickLabelContainer != null) {
                this._configureTickLabelContainer();
            }
            return this.render();
        }
    };
    Axis.prototype._computeWidth = function () {
        // to be overridden by subclass logic
        return this._maxLabelTickLength();
    };
    Axis.prototype._computeHeight = function () {
        // to be overridden by subclass logic
        return this._maxLabelTickLength();
    };
    Axis.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        var requestedWidth = 0;
        var requestedHeight = 0;
        if (this.isHorizontal()) {
            requestedHeight = this._computeHeight() + this._margin;
            if (this.annotationsEnabled()) {
                var tierHeight = this._annotationMeasurer.measure().height + 2 * Axis._ANNOTATION_LABEL_PADDING;
                requestedHeight += tierHeight * this.annotationTierCount();
            }
        }
        else { // vertical
            requestedWidth = this._computeWidth() + this._margin;
            if (this.annotationsEnabled()) {
                var tierHeight = this._annotationMeasurer.measure().height + 2 * Axis._ANNOTATION_LABEL_PADDING;
                requestedWidth += tierHeight * this.annotationTierCount();
            }
        }
        return {
            minWidth: requestedWidth,
            minHeight: requestedHeight,
        };
    };
    Axis.prototype.fixedHeight = function () {
        return this.isHorizontal();
    };
    Axis.prototype.fixedWidth = function () {
        return !this.isHorizontal();
    };
    Axis.prototype._rescale = function () {
        // default implementation; subclasses may call redraw() here
        this.render();
    };
    Axis.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        if (this.isHorizontal()) {
            this._scale.range([0, this.width()]);
        }
        else {
            this._scale.range([this.height(), 0]);
        }
        return this;
    };
    Axis.prototype._sizeFromOffer = function (availableWidth, availableHeight) {
        var requestedSpace = this.requestedSpace(availableWidth, availableHeight);
        if (this.isHorizontal()) {
            return {
                width: availableWidth,
                // always keep the height to be what we request; Axes tell the outside what height they are.
                // this allows blueprint-chart to put the Axis in document flow by removing absolute positioning
                height: requestedSpace.minHeight,
            };
        }
        else {
            return {
                height: availableHeight,
                width: requestedSpace.minWidth,
            };
        }
    };
    Axis.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._tickMarkContainer = this.content().append("g")
            .classed(Axis.TICK_MARK_CLASS + "-container", true);
        this._configureTickLabelContainer();
        this._baseline = this.content().append("line").classed("baseline", true);
        this._annotationContainer = this.content().append("g")
            .classed("annotation-container", true);
        this._annotationContainer.append("g").classed("annotation-line-container", true);
        this._annotationContainer.append("g").classed("annotation-circle-container", true);
        this._annotationContainer.append("g").classed("annotation-rect-container", true);
        var annotationLabelContainer = this._annotationContainer.append("g").classed("annotation-label-container", true);
        var typesetterContext = new Typesettable.SvgContext(annotationLabelContainer.node());
        this._annotationMeasurer = new Typesettable.CacheMeasurer(typesetterContext);
        this._annotationWriter = new Typesettable.Writer(this._annotationMeasurer, typesetterContext);
    };
    Axis.prototype._configureTickLabelContainer = function () {
        if (this._tickLabelContainer == null) {
            this._tickLabelContainer = this.content().append("g");
        }
        // clearing to remove outdated font-size classes
        this._tickLabelContainer.attr("class", null)
            .classed(Axis.TICK_LABEL_CLASS + "-container", true)
            .classed("label-" + this._tickLabelFontSize, true);
    };
    /*
     * Function for generating tick values in data-space (as opposed to pixel values).
     * To be implemented by subclasses.
     */
    Axis.prototype._getTickValues = function () {
        return [];
    };
    /**
     * Render tick marks, baseline, and annotations. Should be super called by subclasses and then overridden to draw
     * other relevant aspects of this Axis.
     */
    Axis.prototype.renderImmediately = function () {
        var tickMarkValues = this._getTickValues();
        var tickMarksUpdate = this._tickMarkContainer.selectAll("." + Axis.TICK_MARK_CLASS).data(tickMarkValues);
        var tickMarks = tickMarksUpdate
            .enter()
            .append("line")
            .classed(Axis.TICK_MARK_CLASS, true)
            .merge(tickMarksUpdate);
        tickMarks.attrs(this._generateTickMarkAttrHash());
        d3.select(tickMarks.nodes()[0]).classed(Axis.END_TICK_MARK_CLASS, true)
            .attrs(this._generateTickMarkAttrHash(true));
        d3.select(tickMarks.nodes()[tickMarkValues.length - 1]).classed(Axis.END_TICK_MARK_CLASS, true)
            .attrs(this._generateTickMarkAttrHash(true));
        tickMarksUpdate.exit().remove();
        this._baseline.attrs(this._generateBaselineAttrHash());
        if (this.annotationsEnabled()) {
            this._drawAnnotations();
        }
        else {
            this._removeAnnotations();
        }
        return this;
    };
    Axis.prototype.annotatedTicks = function (annotatedTicks) {
        if (annotatedTicks == null) {
            return this._annotatedTicks;
        }
        this._annotatedTicks = annotatedTicks;
        this.render();
        return this;
    };
    Axis.prototype.annotationFormatter = function (annotationFormatter) {
        if (annotationFormatter == null) {
            return this._annotationFormatter;
        }
        this._annotationFormatter = annotationFormatter;
        this.render();
        return this;
    };
    Axis.prototype.annotationsEnabled = function (annotationsEnabled) {
        if (annotationsEnabled == null) {
            return this._annotationsEnabled;
        }
        this._annotationsEnabled = annotationsEnabled;
        this.redraw();
        return this;
    };
    Axis.prototype.annotationTierCount = function (annotationTierCount) {
        if (annotationTierCount == null) {
            return this._annotationTierCount;
        }
        if (annotationTierCount < 0) {
            throw new Error("annotationTierCount cannot be negative");
        }
        this._annotationTierCount = annotationTierCount;
        this.redraw();
        return this;
    };
    Axis.prototype._drawAnnotations = function () {
        var _this = this;
        var labelPadding = Axis._ANNOTATION_LABEL_PADDING;
        var measurements = new Utils.Map();
        var annotatedTicks = this._annotatedTicksToRender();
        annotatedTicks.forEach(function (annotatedTick) {
            var measurement = _this._annotationMeasurer.measure(_this.annotationFormatter()(annotatedTick));
            var paddedMeasurement = {
                width: measurement.width + 2 * labelPadding,
                height: measurement.height + 2 * labelPadding,
            };
            measurements.set(annotatedTick, paddedMeasurement);
        });
        var tierHeight = this._annotationMeasurer.measure().height + 2 * labelPadding;
        var annotationToTier = this._annotationToTier(measurements);
        var hiddenAnnotations = new Utils.Set();
        var axisHeight = this.isHorizontal() ? this.height() : this.width();
        var axisHeightWithoutMarginAndAnnotations = this._coreSize();
        var numTiers = Math.min(this.annotationTierCount(), Math.floor((axisHeight - axisHeightWithoutMarginAndAnnotations) / tierHeight));
        annotationToTier.forEach(function (tier, annotation) {
            if (tier === -1 || tier >= numTiers) {
                hiddenAnnotations.add(annotation);
            }
        });
        var bindElements = function (selection, elementName, className) {
            var elementsUpdate = selection.selectAll("." + className).data(annotatedTicks);
            var elements = elementsUpdate
                .enter()
                .append(elementName)
                .classed(className, true)
                .merge(elementsUpdate);
            elementsUpdate.exit().remove();
            return elements;
        };
        var offsetF = function (d) {
            switch (_this.orientation()) {
                case "bottom":
                case "right":
                    return annotationToTier.get(d) * tierHeight + axisHeightWithoutMarginAndAnnotations;
                case "top":
                case "left":
                    return axisHeight - axisHeightWithoutMarginAndAnnotations - annotationToTier.get(d) * tierHeight;
            }
        };
        var positionF = function (d) { return _this._scale.scale(d); };
        var visibilityF = function (d) { return hiddenAnnotations.has(d) ? "hidden" : "visible"; };
        var secondaryPosition;
        switch (this.orientation()) {
            case "bottom":
            case "right":
                secondaryPosition = 0;
                break;
            case "top":
                secondaryPosition = this.height();
                break;
            case "left":
                secondaryPosition = this.width();
                break;
        }
        var isHorizontal = this.isHorizontal();
        bindElements(this._annotationContainer.select(".annotation-line-container"), "line", Axis.ANNOTATION_LINE_CLASS)
            .attrs({
            x1: isHorizontal ? positionF : secondaryPosition,
            x2: isHorizontal ? positionF : offsetF,
            y1: isHorizontal ? secondaryPosition : positionF,
            y2: isHorizontal ? offsetF : positionF,
            visibility: visibilityF,
        });
        bindElements(this._annotationContainer.select(".annotation-circle-container"), "circle", Axis.ANNOTATION_CIRCLE_CLASS)
            .attrs({
            cx: isHorizontal ? positionF : secondaryPosition,
            cy: isHorizontal ? secondaryPosition : positionF,
            r: 3,
        });
        var rectangleOffsetF = function (d) {
            switch (_this.orientation()) {
                case "bottom":
                case "right":
                    return offsetF(d);
                case "top":
                case "left":
                    return offsetF(d) - measurements.get(d).height;
            }
        };
        bindElements(this._annotationContainer.select(".annotation-rect-container"), "rect", Axis.ANNOTATION_RECT_CLASS)
            .attrs({
            x: isHorizontal ? positionF : rectangleOffsetF,
            y: isHorizontal ? rectangleOffsetF : positionF,
            width: isHorizontal ? function (d) { return measurements.get(d).width; } : function (d) { return measurements.get(d).height; },
            height: isHorizontal ? function (d) { return measurements.get(d).height; } : function (d) { return measurements.get(d).width; },
            visibility: visibilityF,
        });
        var annotationWriter = this._annotationWriter;
        var annotationFormatter = this.annotationFormatter();
        var annotationLabels = bindElements(this._annotationContainer.select(".annotation-label-container"), "g", Axis.ANNOTATION_LABEL_CLASS);
        annotationLabels.selectAll(".text-container").remove();
        annotationLabels.attrs({
            transform: function (d) {
                var xTranslate = isHorizontal ? positionF(d) : rectangleOffsetF(d);
                var yTranslate = isHorizontal ? rectangleOffsetF(d) : positionF(d);
                return "translate(" + xTranslate + "," + yTranslate + ")";
            },
            visibility: visibilityF,
        })
            .each(function (annotationLabel) {
            annotationWriter.write(annotationFormatter(annotationLabel), isHorizontal ? measurements.get(annotationLabel).width : measurements.get(annotationLabel).height, isHorizontal ? measurements.get(annotationLabel).height : measurements.get(annotationLabel).width, {
                xAlign: "center",
                yAlign: "center",
                textRotation: isHorizontal ? 0 : 90,
            }, d3.select(this).node());
        });
    };
    Axis.prototype._annotatedTicksToRender = function () {
        var _this = this;
        var scaleRange = this._scale.range();
        return Utils.Array.uniq(this.annotatedTicks().filter(function (tick) {
            if (tick == null) {
                return false;
            }
            return Utils.Math.inRange(_this._scale.scale(tick), scaleRange[0], scaleRange[1]);
        }));
    };
    /**
     * Retrieves the size of the core pieces.
     *
     * The core pieces include the labels, the end tick marks, the inner tick marks, and the tick label padding.
     */
    Axis.prototype._coreSize = function () {
        var relevantDimension = this.isHorizontal() ? this.height() : this.width();
        var axisHeightWithoutMargin = this.isHorizontal() ? this._computeHeight() : this._computeWidth();
        return Math.min(axisHeightWithoutMargin, relevantDimension);
    };
    Axis.prototype._annotationTierHeight = function () {
        return this._annotationMeasurer.measure().height + 2 * Axis._ANNOTATION_LABEL_PADDING;
    };
    Axis.prototype._annotationToTier = function (measurements) {
        var _this = this;
        var annotationTiers = [[]];
        var annotationToTier = new Utils.Map();
        var dimension = this.isHorizontal() ? this.width() : this.height();
        this._annotatedTicksToRender().forEach(function (annotatedTick) {
            var position = _this._scale.scale(annotatedTick);
            var length = measurements.get(annotatedTick).width;
            if (position < 0 || position + length > dimension) {
                annotationToTier.set(annotatedTick, -1);
                return;
            }
            var tierHasCollision = function (testTier) { return annotationTiers[testTier].some(function (testTick) {
                var testPosition = _this._scale.scale(testTick);
                var testLength = measurements.get(testTick).width;
                return position + length >= testPosition && position <= testPosition + testLength;
            }); };
            var tier = 0;
            while (tierHasCollision(tier)) {
                tier++;
                if (annotationTiers.length === tier) {
                    annotationTiers.push([]);
                }
            }
            annotationTiers[tier].push(annotatedTick);
            annotationToTier.set(annotatedTick, tier);
        });
        return annotationToTier;
    };
    Axis.prototype._removeAnnotations = function () {
        this._annotationContainer.selectAll(".annotation-line").remove();
        this._annotationContainer.selectAll(".annotation-circle").remove();
        this._annotationContainer.selectAll(".annotation-rect").remove();
        this._annotationContainer.selectAll(".annotation-label").remove();
    };
    Axis.prototype._generateBaselineAttrHash = function () {
        var baselineAttrHash = {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
        };
        switch (this._orientation) {
            case "bottom":
                baselineAttrHash["x2"] = this.width();
                break;
            case "top":
                baselineAttrHash["x2"] = this.width();
                baselineAttrHash["y1"] = this.height();
                baselineAttrHash["y2"] = this.height();
                break;
            case "left":
                baselineAttrHash["x1"] = this.width();
                baselineAttrHash["x2"] = this.width();
                baselineAttrHash["y2"] = this.height();
                break;
            case "right":
                baselineAttrHash["y2"] = this.height();
                break;
        }
        return baselineAttrHash;
    };
    Axis.prototype._generateTickMarkAttrHash = function (isEndTickMark) {
        var _this = this;
        if (isEndTickMark === void 0) { isEndTickMark = false; }
        var tickMarkAttrHash = {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
        };
        var scalingFunction = function (d) { return _this._scale.scale(d); };
        if (this.isHorizontal()) {
            tickMarkAttrHash["x1"] = scalingFunction;
            tickMarkAttrHash["x2"] = scalingFunction;
        }
        else {
            tickMarkAttrHash["y1"] = scalingFunction;
            tickMarkAttrHash["y2"] = scalingFunction;
        }
        var tickLength = isEndTickMark ? this._endTickLength : this._innerTickLength;
        switch (this._orientation) {
            case "bottom":
                tickMarkAttrHash["y2"] = tickLength;
                break;
            case "top":
                tickMarkAttrHash["y1"] = this.height();
                tickMarkAttrHash["y2"] = this.height() - tickLength;
                break;
            case "left":
                tickMarkAttrHash["x1"] = this.width();
                tickMarkAttrHash["x2"] = this.width() - tickLength;
                break;
            case "right":
                tickMarkAttrHash["x2"] = tickLength;
                break;
        }
        return tickMarkAttrHash;
    };
    Axis.prototype._setDefaultAlignment = function () {
        switch (this._orientation) {
            case "bottom":
                this.yAlignment("top");
                break;
            case "top":
                this.yAlignment("bottom");
                break;
            case "left":
                this.xAlignment("right");
                break;
            case "right":
                this.xAlignment("left");
                break;
        }
    };
    /**
     * Get whether this axis is horizontal (orientation is "top" or "bottom") or vertical.
     * @returns {boolean} - true for horizontal, false for vertical.
     */
    Axis.prototype.isHorizontal = function () {
        return this._orientation === "top" || this._orientation === "bottom";
    };
    /**
     * Get the scale that this axis is associated with.
     * @returns {Scale<D, number>}
     */
    Axis.prototype.getScale = function () {
        return this._scale;
    };
    Axis.prototype.formatter = function (formatter) {
        if (formatter == null) {
            return this._formatter;
        }
        this._formatter = formatter;
        this.redraw();
        return this;
    };
    Axis.prototype.innerTickLength = function (length) {
        if (length == null) {
            return this._innerTickLength;
        }
        else {
            if (length < 0) {
                throw new Error("inner tick length must be positive");
            }
            this._innerTickLength = length;
            this.redraw();
            return this;
        }
    };
    Axis.prototype.endTickLength = function (length) {
        if (length == null) {
            return this._endTickLength;
        }
        else {
            if (length < 0) {
                throw new Error("end tick length must be positive");
            }
            this._endTickLength = length;
            this.redraw();
            return this;
        }
    };
    /**
     * Gets the maximum pixel length over all ticks on this axis.
     * @returns {number}
     */
    Axis.prototype._maxLabelTickLength = function () {
        if (this.showEndTickLabels()) {
            return Math.max(this.innerTickLength(), this.endTickLength());
        }
        else {
            return this.innerTickLength();
        }
    };
    Axis.prototype.tickLabelPadding = function (padding) {
        if (padding == null) {
            return this._tickLabelPadding;
        }
        else {
            if (padding < 0) {
                throw new Error("tick label padding must be positive");
            }
            this._tickLabelPadding = padding;
            this.redraw();
            return this;
        }
    };
    Axis.prototype.margin = function (size) {
        if (size == null) {
            return this._margin;
        }
        else {
            if (size < 0) {
                throw new Error("margin size must be positive");
            }
            this._margin = size;
            this.redraw();
            return this;
        }
    };
    Axis.prototype.orientation = function (orientation) {
        if (orientation == null) {
            return this._orientation;
        }
        else {
            // ensure backwards compatibility for older versions that supply orientation in different cases
            var newOrientationLC = orientation.toLowerCase();
            if (newOrientationLC !== "top" &&
                newOrientationLC !== "bottom" &&
                newOrientationLC !== "left" &&
                newOrientationLC !== "right") {
                throw new Error("unsupported orientation");
            }
            this._orientation = newOrientationLC;
            this.redraw();
            return this;
        }
    };
    Axis.prototype.showEndTickLabels = function (show) {
        if (show == null) {
            return this._showEndTickLabels;
        }
        this._showEndTickLabels = show;
        this.render();
        return this;
    };
    Axis.prototype._showAllTickMarks = function () {
        this._tickMarkContainer.selectAll("." + Axis.TICK_MARK_CLASS)
            .each(function () {
            d3.select(this).style("visibility", "inherit");
        });
    };
    Axis.prototype._showAllTickLabels = function () {
        this._tickLabelContainer.selectAll("." + Axis.TICK_LABEL_CLASS)
            .each(function () {
            d3.select(this).style("visibility", "inherit");
        });
    };
    /**
     * Responsible for hiding any tick labels that break out of the bounding
     * container.
     */
    Axis.prototype._hideOverflowingTickLabels = function () {
        var boundingBox = this.element().node().getBoundingClientRect();
        var tickLabels = this._tickLabelContainer.selectAll("." + Axis.TICK_LABEL_CLASS);
        if (tickLabels.empty()) {
            return;
        }
        tickLabels.each(function (d, i) {
            if (!Utils.DOM.clientRectInside(this.getBoundingClientRect(), boundingBox)) {
                d3.select(this).style("visibility", "hidden");
            }
        });
    };
    /**
     * Hides the Tick Marks which have no corresponding Tick Labels
     */
    Axis.prototype._hideTickMarksWithoutLabel = function () {
        var visibleTickMarks = this._tickMarkContainer.selectAll("." + Axis.TICK_MARK_CLASS);
        var visibleTickLabels = this._tickLabelContainer
            .selectAll("." + Axis.TICK_LABEL_CLASS)
            .filter(function (d, i) {
            var visibility = d3.select(this).style("visibility");
            return (visibility === "inherit") || (visibility === "visible");
        });
        var labelNumbersShown = visibleTickLabels.data();
        visibleTickMarks.each(function (e, i) {
            if (labelNumbersShown.indexOf(e) === -1) {
                d3.select(this).style("visibility", "hidden");
            }
        });
    };
    Axis.prototype.invalidateCache = function () {
        _super.prototype.invalidateCache.call(this);
        if (this._annotationMeasurer != null) {
            this._annotationMeasurer.reset();
        }
    };
    /**
     * The css class applied to each end tick mark (the line on the end tick).
     */
    Axis.END_TICK_MARK_CLASS = "end-tick-mark";
    /**
     * The css class applied to each tick mark (the line on the tick).
     */
    Axis.TICK_MARK_CLASS = "tick-mark";
    /**
     * The css class applied to each tick label (the text associated with the tick).
     */
    Axis.TICK_LABEL_CLASS = "tick-label";
    /**
     * The css class applied to each annotation line, which extends from the axis to the rect.
     */
    Axis.ANNOTATION_LINE_CLASS = "annotation-line";
    /**
     * The css class applied to each annotation rect, which surrounds the annotation label.
     */
    Axis.ANNOTATION_RECT_CLASS = "annotation-rect";
    /**
     * The css class applied to each annotation circle, which denotes which tick is being annotated.
     */
    Axis.ANNOTATION_CIRCLE_CLASS = "annotation-circle";
    /**
     * The css class applied to each annotation label, which shows the formatted annotation text.
     */
    Axis.ANNOTATION_LABEL_CLASS = "annotation-label";
    Axis._ANNOTATION_LABEL_PADDING = 4;
    return Axis;
}(component_1.Component));
exports.Axis = Axis;

},{"../components/component":532,"../components/label":541,"../core/formatters":551,"../utils":624,"../utils/makeEnum":625,"d3":414,"tslib":635,"typesettable":640}],528:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Category = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Typesettable = require("typesettable");
var component_1 = require("../components/component");
var label_1 = require("../components/label");
var Utils = require("../utils");
var axis_1 = require("./axis");
var Category = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Category, _super);
    /**
     * Constructs a Category Axis.
     *
     * A Category Axis is a visual representation of a Category Scale.
     *
     * @constructor
     * @param {Scales.Category} scale
     * @param {AxisOrientation} [orientation="bottom"] Orientation of this Category Axis.
     */
    function Category(scale, orientation) {
        if (orientation === void 0) { orientation = "bottom"; }
        var _this = _super.call(this, scale, orientation) || this;
        /**
         * The rotation angle of tick label text. Only 0, 90, -90 are supported
         */
        _this._tickLabelAngle = 0;
        /**
         * The shear angle of the tick label text. Only values -80 <= x <= 80 are supported
         */
        _this._tickLabelShearAngle = 0;
        _this.addClass("category-axis");
        return _this;
    }
    Object.defineProperty(Category.prototype, "_wrapper", {
        /**
         * A Wrapper configured according to the other properties on this axis.
         * @returns {Typesettable.Wrapper}
         */
        get: function () {
            var wrapper = new Typesettable.Wrapper();
            if (this._tickLabelMaxLines != null) {
                wrapper.maxLines(this._tickLabelMaxLines);
            }
            return wrapper;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "_writer", {
        /**
         * A Writer attached to this measurer and wrapper.
         * @returns {Typesettable.Writer}
         */
        get: function () {
            return new Typesettable.Writer(this._measurer, this._typesetterContext, this._wrapper);
        },
        enumerable: false,
        configurable: true
    });
    Category.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._typesetterContext = new Typesettable.SvgContext(this._tickLabelContainer.node());
        this._measurer = new Typesettable.CacheMeasurer(this._typesetterContext);
    };
    Category.prototype._rescale = function () {
        return this.redraw();
    };
    /**
     * Compute space requirements for this Category Axis. Category Axes have two primary space requirements:
     *
     * 1) width/height needed by the tick lines (including annotations, padding, and margins).
     * 2) width/height needed by the tick text.
     *
     * We requested space is the sum of the lines and text.
     * @param offeredWidth
     * @param offeredHeight
     * @returns {any}
     */
    Category.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        var widthRequiredByTicks = this.isHorizontal() ? 0 : this._tickSpaceRequired() + this.margin();
        var heightRequiredByTicks = this.isHorizontal() ? this._tickSpaceRequired() + this.margin() : 0;
        if (this._scale.domain().length === 0) {
            return {
                minWidth: 0,
                minHeight: 0,
            };
        }
        if (this.annotationsEnabled()) {
            var tierTotalHeight = this._annotationTierHeight() * this.annotationTierCount();
            if (this.isHorizontal()) {
                heightRequiredByTicks += tierTotalHeight;
            }
            else {
                widthRequiredByTicks += tierTotalHeight;
            }
        }
        var measureResult = this._measureTickLabels(offeredWidth, offeredHeight);
        return {
            minWidth: measureResult.usedWidth + widthRequiredByTicks,
            minHeight: measureResult.usedHeight + heightRequiredByTicks,
        };
    };
    Category.prototype._coreSize = function () {
        var relevantDimension = this.isHorizontal() ? this.height() : this.width();
        var relevantRequestedSpaceDimension = this.isHorizontal() ?
            this.requestedSpace(this.width(), this.height()).minHeight :
            this.requestedSpace(this.width(), this.height()).minWidth;
        var marginAndAnnotationSize = this.margin() + this._annotationTierHeight();
        var axisHeightWithoutMargin = relevantRequestedSpaceDimension - marginAndAnnotationSize;
        return Math.min(axisHeightWithoutMargin, relevantDimension);
    };
    Category.prototype._getTickValues = function () {
        return this.getDownsampleInfo().domain;
    };
    Category.prototype._sizeFromOffer = function (availableWidth, availableHeight) {
        // hack: continue using Component._sizeFromOffer to prevent angled axis ticks
        // from overflowing their container
        return component_1.Component.prototype._sizeFromOffer.call(this, availableWidth, availableHeight);
    };
    /**
     * Take the scale and drop ticks at regular intervals such that the resultant ticks are all a reasonable minimum
     * distance apart. Return the resultant ticks to render, as well as the new stepWidth between them.
     *
     * @param {Scales.Category} scale - The scale being downsampled. Defaults to this Axis' scale.
     * @return {DownsampleInfo} an object holding the resultant domain and new stepWidth.
     */
    Category.prototype.getDownsampleInfo = function (scale, domain) {
        if (scale === void 0) { scale = this._scale; }
        if (domain === void 0) { domain = scale.invertRange(); }
        // account for how shearing tightens the space between vertically oriented ticks
        var shearFactor = this._tickLabelAngle === 0 ? 1 : 1 / Math.cos(this._tickLabelShearAngle / 180 * Math.PI);
        var shearedMinimumWidth = Category._MINIMUM_WIDTH_PER_LABEL_PX * shearFactor + 2 * (this.tickLabelFontSize() - label_1.Label._MIN_FONT_SIZE_PX);
        var downsampleRatio = Math.ceil(shearedMinimumWidth / scale.stepWidth());
        return {
            domain: domain.filter(function (d, i) { return i % downsampleRatio === 0; }),
            stepWidth: downsampleRatio * scale.stepWidth(),
        };
    };
    Category.prototype.tickLabelAngle = function (angle) {
        if (angle == null) {
            return this._tickLabelAngle;
        }
        if (angle !== 0 && angle !== 90 && angle !== -90) {
            throw new Error("Angle " + angle + " not supported; only 0, 90, and -90 are valid values");
        }
        this._tickLabelAngle = angle;
        this.redraw();
        return this;
    };
    Category.prototype.tickLabelShearAngle = function (angle) {
        if (angle == null) {
            return this._tickLabelShearAngle;
        }
        if (angle < -80 || angle > 80) {
            throw new Error("Angle " + angle + " not supported; Must be between [-80, 80]");
        }
        this._tickLabelShearAngle = angle;
        this.redraw();
        return this;
    };
    Category.prototype.tickLabelMaxWidth = function (maxWidth) {
        // allow user to un-set tickLabelMaxWidth by passing in null or undefined explicitly
        if (arguments.length === 0) {
            return this._tickLabelMaxWidth;
        }
        this._tickLabelMaxWidth = maxWidth;
        this.redraw();
        return this;
    };
    Category.prototype.tickLabelMaxLines = function (maxLines) {
        // allow user to un-set tickLabelMaxLines by passing in null or undefined explicitly
        if (arguments.length === 0) {
            return this._tickLabelMaxLines;
        }
        this._tickLabelMaxLines = maxLines;
        this.redraw();
        return this;
    };
    /**
     * Return the space required by the ticks, padding included.
     * @returns {number}
     */
    Category.prototype._tickSpaceRequired = function () {
        return this._maxLabelTickLength() + this.tickLabelPadding();
    };
    /**
     * Write ticks to the DOM.
     * @param {Plottable.Scales.Category} scale The scale this axis is representing.
     * @param {d3.Selection} ticks The tick elements to write.
     */
    Category.prototype._drawTicks = function (stepWidth, ticks) {
        var self = this;
        var xAlign;
        var yAlign;
        switch (this.tickLabelAngle()) {
            case 0:
                xAlign = { left: "right", right: "left", top: "center", bottom: "center" };
                yAlign = { left: "center", right: "center", top: "bottom", bottom: "top" };
                break;
            case 90:
                xAlign = { left: "center", right: "center", top: "right", bottom: "left" };
                yAlign = { left: "top", right: "bottom", top: "center", bottom: "center" };
                break;
            case -90:
                xAlign = { left: "center", right: "center", top: "left", bottom: "right" };
                yAlign = { left: "bottom", right: "top", top: "center", bottom: "center" };
                break;
        }
        ticks.each(function (d) {
            var container = d3.select(this);
            var width = self.isHorizontal() ? stepWidth : self.width() - self._tickSpaceRequired();
            var height = self.isHorizontal() ? self.height() - self._tickSpaceRequired() : stepWidth;
            var writeOptions = {
                xAlign: xAlign[self.orientation()],
                yAlign: yAlign[self.orientation()],
                textRotation: self.tickLabelAngle(),
                textShear: self.tickLabelShearAngle(),
            };
            if (self._tickLabelMaxWidth != null) {
                // for left-oriented axes, we must move the ticks by the amount we've cut off in order to keep the text
                // aligned with the side of the ticks
                if (self.orientation() === "left" && width > self._tickLabelMaxWidth) {
                    var cutOffWidth = width - self._tickLabelMaxWidth;
                    var newTransform = container.attr("transform") + " translate(" + cutOffWidth + ", 0)";
                    container.attr("transform", newTransform);
                }
                width = Math.min(width, self._tickLabelMaxWidth);
            }
            self._writer.write(self.formatter()(d), width, height, writeOptions, container.node());
        });
    };
    Category.prototype.tickLabelFontSize = function (fontSize) {
        if (fontSize == null) {
            return _super.prototype.tickLabelFontSize.call(this);
        }
        // Resets the measurer to measure distances using the latest font size
        this.invalidateCache();
        return _super.prototype.tickLabelFontSize.call(this, fontSize);
    };
    /**
     * Measures the size of the tick labels without making any (permanent) DOM changes.
     *
     * @param {number} axisWidth Width available for this axis.
     * @param {number} axisHeight Height available for this axis.
     * @param {Plottable.Scales.Category} scale The scale this axis is representing.
     * @param {string[]} ticks The strings that will be printed on the ticks.
     */
    Category.prototype._measureTickLabels = function (axisWidth, axisHeight) {
        var _a;
        var _this = this;
        var thisScale = this._scale;
        // set up a test scale to simulate rendering ticks with the given width and height.
        var scale = thisScale.cloneWithoutProviders()
            .range([0, this.isHorizontal() ? axisWidth : axisHeight]);
        var _b = this.getDownsampleInfo(scale), domain = _b.domain, stepWidth = _b.stepWidth;
        // HACKHACK: https://github.com/palantir/svg-typewriter/issues/25
        // the width (x-axis specific) available to a single tick label.
        var width = axisWidth - this._tickSpaceRequired(); // default for left/right
        if (this.isHorizontal()) { // case for top/bottom
            width = stepWidth; // defaults to the band width
            if (this._tickLabelAngle !== 0) { // rotated label
                width = axisHeight - this._tickSpaceRequired(); // use the axis height
            }
            // HACKHACK: Wrapper fails under negative circumstances
            width = Math.max(width, 0);
        }
        // HACKHACK: https://github.com/palantir/svg-typewriter/issues/25
        // the height (y-axis specific) available to a single tick label.
        var height = stepWidth; // default for left/right
        if (this.isHorizontal()) { // case for top/bottom
            height = axisHeight - this._tickSpaceRequired();
            if (this._tickLabelAngle !== 0) { // rotated label
                height = axisWidth - this._tickSpaceRequired();
            }
            // HACKHACK: Wrapper fails under negative circumstances
            height = Math.max(height, 0);
        }
        if (this._tickLabelMaxWidth != null) {
            width = Math.min(width, this._tickLabelMaxWidth);
        }
        var wrappingResults = domain.map(function (s) {
            return _this._wrapper.wrap(_this.formatter()(s), _this._measurer, width, height);
        });
        // HACKHACK: https://github.com/palantir/svg-typewriter/issues/25
        var widthFn = (this.isHorizontal() && this._tickLabelAngle === 0) ? d3.sum : Utils.Math.max;
        var heightFn = (this.isHorizontal() && this._tickLabelAngle === 0) ? Utils.Math.max : d3.sum;
        var usedWidth = widthFn(wrappingResults, function (t) { return _this._measurer.measure(t.wrappedText).width; }, 0);
        var usedHeight = heightFn(wrappingResults, function (t) { return _this._measurer.measure(t.wrappedText).height; }, 0);
        // If the tick labels are rotated, reverse usedWidth and usedHeight
        // HACKHACK: https://github.com/palantir/svg-typewriter/issues/25
        if (this._tickLabelAngle !== 0) {
            _a = [usedHeight, usedWidth], usedWidth = _a[0], usedHeight = _a[1];
        }
        return {
            usedWidth: usedWidth,
            usedHeight: usedHeight,
        };
    };
    Category.prototype.renderImmediately = function () {
        var _this = this;
        _super.prototype.renderImmediately.call(this);
        var catScale = this._scale;
        var _a = this.getDownsampleInfo(catScale), domain = _a.domain, stepWidth = _a.stepWidth;
        // Give each tick a stepWidth of space which will partition the entire axis evenly
        var availableTextSpace = stepWidth;
        if (this.isHorizontal() && this._tickLabelMaxWidth != null) {
            availableTextSpace = Math.min(availableTextSpace, this._tickLabelMaxWidth);
        }
        var getTickLabelTransform = function (d, i) {
            // scale(d) will give the center of the band, so subtract half of the text width to get the left (top-most)
            // coordinate that the tick label should be transformed to.
            var tickLabelEdge = catScale.scale(d) - availableTextSpace / 2;
            var x = _this.isHorizontal() ? tickLabelEdge : 0;
            var y = _this.isHorizontal() ? 0 : tickLabelEdge;
            return "translate(" + x + "," + y + ")";
        };
        var tickLabelsUpdate = this._tickLabelContainer.selectAll("." + axis_1.Axis.TICK_LABEL_CLASS).data(domain);
        var tickLabels = tickLabelsUpdate
            .enter()
            .append("g")
            .classed(axis_1.Axis.TICK_LABEL_CLASS, true)
            .merge(tickLabelsUpdate);
        tickLabelsUpdate.exit().remove();
        tickLabels.attr("transform", getTickLabelTransform);
        // erase all text first, then rewrite
        tickLabels.text("");
        this._drawTicks(stepWidth, tickLabels);
        var xTranslate = this.orientation() === "right" ? this._tickSpaceRequired() : 0;
        var yTranslate = this.orientation() === "bottom" ? this._tickSpaceRequired() : 0;
        this._tickLabelContainer.attr("transform", "translate(" + xTranslate + "," + yTranslate + ")");
        // hide ticks and labels that overflow the axis
        this._showAllTickMarks();
        this._showAllTickLabels();
        this._hideTickMarksWithoutLabel();
        return this;
    };
    Category.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        if (!this.isHorizontal()) {
            this._scale.range([0, this.height()]);
        }
        return this;
    };
    Category.prototype.invalidateCache = function () {
        _super.prototype.invalidateCache.call(this);
        if (this._measurer != null) {
            this._measurer.reset();
        }
    };
    /**
     * How many pixels to give labels at minimum before downsampling takes effect.
     */
    Category._MINIMUM_WIDTH_PER_LABEL_PX = 15;
    return Category;
}(axis_1.Axis));
exports.Category = Category;

},{"../components/component":532,"../components/label":541,"../utils":624,"./axis":527,"d3":414,"tslib":635,"typesettable":640}],529:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
(0, tslib_1.__exportStar)(require("./categoryAxis"), exports);
(0, tslib_1.__exportStar)(require("./numericAxis"), exports);
(0, tslib_1.__exportStar)(require("./timeAxis"), exports);

},{"./categoryAxis":528,"./numericAxis":530,"./timeAxis":531,"tslib":635}],530:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Numeric = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Typesettable = require("typesettable");
var Formatters = require("../core/formatters");
var Utils = require("../utils");
var axis_1 = require("./axis");
var Numeric = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Numeric, _super);
    /**
     * Constructs a Numeric Axis.
     *
     * A Numeric Axis is a visual representation of a QuantitativeScale.
     *
     * @constructor
     * @param {QuantitativeScale} scale
     * @param {AxisOrientation} orientation Orientation of this Numeric Axis.
     */
    function Numeric(scale, orientation) {
        var _this = _super.call(this, scale, orientation) || this;
        _this._tickLabelPositioning = "center";
        _this._usesTextWidthApproximation = false;
        _this.formatter(Formatters.general());
        return _this;
    }
    Numeric.prototype._setup = function () {
        _super.prototype._setup.call(this);
        var context = new Typesettable.SvgContext(this._tickLabelContainer.node(), axis_1.Axis.TICK_LABEL_CLASS);
        this._measurer = new Typesettable.CacheMeasurer(context);
        this._wrapper = new Typesettable.Wrapper().maxLines(1);
    };
    Numeric.prototype._computeWidth = function () {
        var maxTextWidth = this._usesTextWidthApproximation ? this._computeApproximateTextWidth() : this._computeExactTextWidth();
        if (this._tickLabelPositioning === "center") {
            return this._maxLabelTickLength() + this.tickLabelPadding() + maxTextWidth;
        }
        else {
            return Math.max(this._maxLabelTickLength(), this.tickLabelPadding() + maxTextWidth);
        }
    };
    Numeric.prototype._computeExactTextWidth = function () {
        var _this = this;
        var tickValues = this._getTickValues();
        var textLengths = tickValues.map(function (v) {
            var formattedValue = _this.formatter()(v);
            return _this._measurer.measure(formattedValue).width;
        });
        return Utils.Math.max(textLengths, 0);
    };
    Numeric.prototype._computeApproximateTextWidth = function () {
        var _this = this;
        var tickValues = this._getTickValues();
        var mWidth = this._measurer.measure("M").width;
        var textLengths = tickValues.map(function (v) {
            var formattedValue = _this.formatter()(v);
            return formattedValue.length * mWidth;
        });
        return Utils.Math.max(textLengths, 0);
    };
    Numeric.prototype._computeHeight = function () {
        var textHeight = this._measurer.measure().height;
        if (this._tickLabelPositioning === "center") {
            return this._maxLabelTickLength() + this.tickLabelPadding() + textHeight;
        }
        else {
            return Math.max(this._maxLabelTickLength(), this.tickLabelPadding() + textHeight);
        }
    };
    Numeric.prototype._getTickValues = function () {
        var scale = this._scale;
        var domain = scale.domain();
        var min = domain[0] <= domain[1] ? domain[0] : domain[1];
        var max = domain[0] >= domain[1] ? domain[0] : domain[1];
        return scale.ticks().filter(function (i) { return i >= min && i <= max; });
    };
    Numeric.prototype._rescale = function () {
        if (!this._isSetup) {
            return;
        }
        if (!this.isHorizontal()) {
            var reComputedWidth = this._computeWidth();
            if (reComputedWidth > this.width() || reComputedWidth < (this.width() - this.margin())) {
                this.redraw();
                return;
            }
        }
        this.render();
    };
    Numeric.prototype.renderImmediately = function () {
        var _this = this;
        _super.prototype.renderImmediately.call(this);
        var tickLabelAttrHash = {
            x: 0,
            y: 0,
            dx: "0em",
            dy: "0.3em",
        };
        var tickMarkLength = this._maxLabelTickLength();
        var tickLabelPadding = this.tickLabelPadding();
        var tickLabelTextAnchor = "middle";
        var labelGroupTransformX = 0;
        var labelGroupTransformY = 0;
        var labelGroupShiftX = 0;
        var labelGroupShiftY = 0;
        if (this.isHorizontal()) {
            switch (this._tickLabelPositioning) {
                case "left":
                    tickLabelTextAnchor = "end";
                    labelGroupTransformX = -tickLabelPadding;
                    labelGroupShiftY = tickLabelPadding;
                    break;
                case "center":
                    labelGroupShiftY = tickMarkLength + tickLabelPadding;
                    break;
                case "right":
                    tickLabelTextAnchor = "start";
                    labelGroupTransformX = tickLabelPadding;
                    labelGroupShiftY = tickLabelPadding;
                    break;
            }
        }
        else {
            switch (this._tickLabelPositioning) {
                case "top":
                    tickLabelAttrHash["dy"] = "-0.3em";
                    labelGroupShiftX = tickLabelPadding;
                    labelGroupTransformY = -tickLabelPadding;
                    break;
                case "center":
                    labelGroupShiftX = tickMarkLength + tickLabelPadding;
                    break;
                case "bottom":
                    tickLabelAttrHash["dy"] = "1em";
                    labelGroupShiftX = tickLabelPadding;
                    labelGroupTransformY = tickLabelPadding;
                    break;
            }
        }
        var tickMarkAttrHash = this._generateTickMarkAttrHash();
        switch (this.orientation()) {
            case "bottom":
                tickLabelAttrHash["x"] = tickMarkAttrHash["x1"];
                tickLabelAttrHash["dy"] = "0.95em";
                labelGroupTransformY = tickMarkAttrHash["y1"] + labelGroupShiftY;
                break;
            case "top":
                tickLabelAttrHash["x"] = tickMarkAttrHash["x1"];
                tickLabelAttrHash["dy"] = "-.25em";
                labelGroupTransformY = tickMarkAttrHash["y1"] - labelGroupShiftY;
                break;
            case "left":
                tickLabelTextAnchor = "end";
                labelGroupTransformX = tickMarkAttrHash["x1"] - labelGroupShiftX;
                tickLabelAttrHash["y"] = tickMarkAttrHash["y1"];
                break;
            case "right":
                tickLabelTextAnchor = "start";
                labelGroupTransformX = tickMarkAttrHash["x1"] + labelGroupShiftX;
                tickLabelAttrHash["y"] = tickMarkAttrHash["y1"];
                break;
        }
        var tickLabelValues = this._getTickValues();
        var tickLabelsUpdate = this._tickLabelContainer.selectAll("." + axis_1.Axis.TICK_LABEL_CLASS).data(tickLabelValues);
        tickLabelsUpdate.exit().remove();
        var tickLabels = tickLabelsUpdate
            .enter()
            .append("text")
            .classed(axis_1.Axis.TICK_LABEL_CLASS, true)
            .merge(tickLabelsUpdate);
        tickLabels.style("text-anchor", tickLabelTextAnchor)
            .style("visibility", "inherit")
            .attrs(tickLabelAttrHash)
            .text(function (s) { return _this.formatter()(s); });
        var labelGroupTransform = "translate(" + labelGroupTransformX + ", " + labelGroupTransformY + ")";
        this._tickLabelContainer.attr("transform", labelGroupTransform);
        this._showAllTickMarks();
        if (!this.showEndTickLabels()) {
            this._hideEndTickLabels();
        }
        this._hideOverflowingTickLabels();
        this._hideOverlappingTickLabels();
        if (this._tickLabelPositioning !== "center") {
            this._hideTickMarksWithoutLabel();
        }
        return this;
    };
    Numeric.prototype.tickLabelPosition = function (position) {
        if (position == null) {
            return this._tickLabelPositioning;
        }
        else {
            var positionLC = position.toLowerCase();
            if (this.isHorizontal()) {
                if (!(positionLC === "left" || positionLC === "center" || positionLC === "right")) {
                    throw new Error(positionLC + " is not a valid tick label position for a horizontal NumericAxis");
                }
            }
            else {
                if (!(positionLC === "top" || positionLC === "center" || positionLC === "bottom")) {
                    throw new Error(positionLC + " is not a valid tick label position for a vertical NumericAxis");
                }
            }
            this._tickLabelPositioning = positionLC;
            this.redraw();
            return this;
        }
    };
    Numeric.prototype.usesTextWidthApproximation = function (enable) {
        if (enable == null) {
            return this._usesTextWidthApproximation;
        }
        else {
            this._usesTextWidthApproximation = enable;
            return this;
        }
    };
    Numeric.prototype._hideEndTickLabels = function () {
        var boundingBox = this.element().node().getBoundingClientRect();
        var tickLabels = this._tickLabelContainer.selectAll("." + axis_1.Axis.TICK_LABEL_CLASS);
        if (tickLabels.size() === 0) {
            return;
        }
        var firstTickLabel = tickLabels.nodes()[0];
        if (!Utils.DOM.clientRectInside(firstTickLabel.getBoundingClientRect(), boundingBox)) {
            d3.select(firstTickLabel).style("visibility", "hidden");
        }
        var lastTickLabel = tickLabels.nodes()[tickLabels.size() - 1];
        if (!Utils.DOM.clientRectInside(lastTickLabel.getBoundingClientRect(), boundingBox)) {
            d3.select(lastTickLabel).style("visibility", "hidden");
        }
    };
    Numeric.prototype._hideOverlappingTickLabels = function () {
        var visibleTickLabels = this._tickLabelContainer
            .selectAll("." + axis_1.Axis.TICK_LABEL_CLASS)
            .filter(function (d, i) {
            var visibility = d3.select(this).style("visibility");
            return (visibility === "inherit") || (visibility === "visible");
        });
        var visibleTickLabelRects = visibleTickLabels.nodes().map(function (label) { return label.getBoundingClientRect(); });
        var interval = 1;
        while (!this._hasOverlapWithInterval(interval, visibleTickLabelRects) && interval < visibleTickLabelRects.length) {
            interval += 1;
        }
        visibleTickLabels.each(function (d, i) {
            var tickLabel = d3.select(this);
            if (i % interval !== 0) {
                tickLabel.style("visibility", "hidden");
            }
        });
    };
    /**
     * The method is responsible for evenly spacing the labels on the axis.
     * @return test to see if taking every `interval` recrangle from `rects`
     *         will result in labels not overlapping
     *
     * For top, bottom, left, right positioning of the thicks, we want the padding
     * between the labels to be 3x, such that the label will be  `padding` distance
     * from the tick and 2 * `padding` distance (or more) from the next tick:
     * see https://github.com/palantir/plottable/pull/1812
     */
    Numeric.prototype._hasOverlapWithInterval = function (interval, rects) {
        var padding = (this._tickLabelPositioning === "center")
            ? this.tickLabelPadding()
            : this.tickLabelPadding() * 3;
        var rectsWithPadding = rects.map(function (rect) { return Utils.DOM.expandRect(rect, padding); });
        for (var i = 0; i < rectsWithPadding.length - interval; i += interval) {
            var currRect = rectsWithPadding[i];
            var nextRect = rectsWithPadding[i + interval];
            if (Utils.DOM.clientRectsOverlap(currRect, nextRect)) {
                return false;
            }
        }
        return true;
    };
    Numeric.prototype.invalidateCache = function () {
        _super.prototype.invalidateCache.call(this);
        this._measurer.reset();
    };
    return Numeric;
}(axis_1.Axis));
exports.Numeric = Numeric;

},{"../core/formatters":551,"../utils":624,"./axis":527,"d3":414,"tslib":635,"typesettable":640}],531:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Time = exports.TierLabelPosition = exports.TimeAxisOrientation = exports.TimeInterval = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Typesettable = require("typesettable");
var Formatters = require("../core/formatters");
var Scales = require("../scales");
var Utils = require("../utils");
var makeEnum_1 = require("../utils/makeEnum");
var axis_1 = require("./axis");
exports.TimeInterval = (0, makeEnum_1.makeEnum)([
    "second",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "year",
]);
/**
 * Possible orientations for a Time Axis.
 */
exports.TimeAxisOrientation = (0, makeEnum_1.makeEnum)(["top", "bottom"]);
exports.TierLabelPosition = (0, makeEnum_1.makeEnum)(["between", "center"]);
var Time = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Time, _super);
    /**
     * Constructs a Time Axis.
     *
     * A Time Axis is a visual representation of a Time Scale.
     *
     * @constructor
     * @param {Scales.Time} scale
     * @param {AxisOrientation} orientation Orientation of this Time Axis. Time Axes can only have "top" or "bottom"
     * @param {boolean} useUTC Displays date object in UTC if true, local time if false. Defaults to false.
     * orientations.
     */
    function Time(scale, orientation, useUTC) {
        var _this = _super.call(this, scale, orientation) || this;
        _this._maxTimeIntervalPrecision = null;
        _this._tierLabelPositions = [];
        _this._useUTC = useUTC;
        _this.addClass("time-axis");
        _this.tickLabelPadding(5);
        _this.axisConfigurations(Time._DEFAULT_TIME_AXIS_CONFIGURATIONS(_this._useUTC));
        _this.annotationFormatter(Formatters.time("%a %b %d, %Y", _this._useUTC));
        return _this;
    }
    Time.prototype.tickLabelFontSize = function (fontSize) {
        var _this = this;
        if (fontSize == null) {
            return _super.prototype.tickLabelFontSize.call(this);
        }
        if (this._tierLabelContainers != null) {
            this.invalidateCache();
            this._computeHeight();
            this._tierLabelContainers.forEach(function (container) {
                // clearing to remove outdated font-size classes
                container.attr("class", null)
                    .classed(axis_1.Axis.TICK_LABEL_CLASS + "-container", true)
                    .classed("label-" + _this._tickLabelFontSize, true);
            });
        }
        return _super.prototype.tickLabelFontSize.call(this, fontSize);
    };
    Time.prototype.tierLabelPositions = function (newPositions) {
        if (newPositions == null) {
            return this._tierLabelPositions;
        }
        else {
            if (!newPositions.every(function (pos) { return pos.toLowerCase() === "between" || pos.toLowerCase() === "center"; })) {
                throw new Error("Unsupported position for tier labels");
            }
            this._tierLabelPositions = newPositions;
            this.redraw();
            return this;
        }
    };
    Time.prototype.maxTimeIntervalPrecision = function (newPrecision) {
        if (newPrecision == null) {
            return this._maxTimeIntervalPrecision;
        }
        else {
            this._maxTimeIntervalPrecision = newPrecision;
            this.redraw();
            return this;
        }
    };
    /**
     * Returns the current `TimeAxisConfiguration` used to render the axes.
     *
     * Note that this is only valid after the axis had been rendered and the
     * most precise valid configuration is determined from the available space
     * and maximum precision constraints.
     *
     * @returns {TimeAxisConfiguration} The currently used `TimeAxisConfiguration` or `undefined`.
     */
    Time.prototype.currentAxisConfiguration = function () {
        return this._possibleTimeAxisConfigurations[this._mostPreciseConfigIndex];
    };
    Time.prototype.axisConfigurations = function (configurations) {
        if (configurations == null) {
            return this._possibleTimeAxisConfigurations;
        }
        this._possibleTimeAxisConfigurations = configurations;
        this._numTiers = Utils.Math.max(this._possibleTimeAxisConfigurations.map(function (config) { return config.length; }), 0);
        if (this._isAnchored) {
            this._setupDomElements();
        }
        var oldLabelPositions = this.tierLabelPositions();
        var newLabelPositions = [];
        for (var i = 0; i < this._numTiers; i++) {
            newLabelPositions.push(oldLabelPositions[i] || "between");
        }
        this.tierLabelPositions(newLabelPositions);
        this.redraw();
        return this;
    };
    /**
     * Gets the index of the most precise TimeAxisConfiguration that will fit in the current width.
     */
    Time.prototype._getMostPreciseConfigurationIndex = function () {
        var _this = this;
        var mostPreciseIndex = this._possibleTimeAxisConfigurations.length;
        this._possibleTimeAxisConfigurations.forEach(function (interval, index) {
            if (index < mostPreciseIndex && interval.every(function (tier) {
                return _this._checkTimeAxisTierConfiguration(tier);
            })) {
                mostPreciseIndex = index;
            }
        });
        if (mostPreciseIndex === this._possibleTimeAxisConfigurations.length) {
            Utils.Window.warn("zoomed out too far: could not find suitable interval to display labels");
            --mostPreciseIndex;
        }
        return mostPreciseIndex;
    };
    Time.prototype.orientation = function (orientation) {
        if (orientation && (orientation.toLowerCase() === "right" || orientation.toLowerCase() === "left")) {
            throw new Error(orientation + " is not a supported orientation for TimeAxis - only horizontal orientations are supported");
        }
        return _super.prototype.orientation.call(this, orientation); // maintains getter-setter functionality
    };
    Time.prototype._computeHeight = function () {
        var textHeight = this._measurer.measure().height;
        this._tierHeights = [];
        for (var i = 0; i < this._numTiers; i++) {
            this._tierHeights.push(textHeight + this.tickLabelPadding() +
                ((this._tierLabelPositions[i]) === "between" ? 0 : this._maxLabelTickLength()));
        }
        return d3.sum(this._tierHeights);
    };
    Time.prototype._getIntervalLength = function (config) {
        var startDate = this._scale.domain()[0];
        var d3Interval = Scales.Time.timeIntervalToD3Time(config.interval, this._useUTC);
        var endDate = d3Interval.offset(startDate, config.step);
        if (endDate > this._scale.domain()[1]) {
            // this offset is too large, so just return available width
            return this.width();
        }
        // measure how much space one date can get
        var stepLength = Math.abs(this._scale.scale(endDate) - this._scale.scale(startDate));
        return stepLength;
    };
    Time.prototype._maxWidthForInterval = function (config) {
        return this._measurer.measure(config.formatter(Time._LONG_DATE)).width;
    };
    /**
     * Check if tier configuration fits in the current width and satisfied the
     * max TimeInterval precision limit.
     */
    Time.prototype._checkTimeAxisTierConfiguration = function (config) {
        // Use the sorted index to determine if the teir configuration contains a
        // time interval that is too precise for the maxTimeIntervalPrecision
        // setting (if set).
        if (this._maxTimeIntervalPrecision != null) {
            var precisionLimit = Time._SORTED_TIME_INTERVAL_INDEX[this._maxTimeIntervalPrecision];
            var configPrecision = Time._SORTED_TIME_INTERVAL_INDEX[config.interval];
            if (precisionLimit != null && configPrecision != null && configPrecision < precisionLimit) {
                return false;
            }
        }
        var worstWidth = this._maxWidthForInterval(config) + 2 * this.tickLabelPadding();
        return Math.min(this._getIntervalLength(config), this.width()) >= worstWidth;
    };
    Time.prototype._sizeFromOffer = function (availableWidth, availableHeight) {
        // Makes sure that the size it requires is a multiple of tier sizes, such that
        // we have no leftover tiers
        var size = _super.prototype._sizeFromOffer.call(this, availableWidth, availableHeight);
        var tierHeights = this._tierHeights.reduce(function (prevValue, currValue, index, arr) {
            return (prevValue + currValue > size.height) ? prevValue : (prevValue + currValue);
        });
        var nonCoreHeight = this.margin() + (this.annotationsEnabled() ? this.annotationTierCount() * this._annotationTierHeight() : 0);
        size.height = Math.min(size.height, tierHeights + nonCoreHeight);
        return size;
    };
    Time.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._setupDomElements();
    };
    Time.prototype._setupDomElements = function () {
        this.content().selectAll("." + Time.TIME_AXIS_TIER_CLASS).remove();
        this._tierLabelContainers = [];
        this._tierMarkContainers = [];
        this._tierBaselines = [];
        this._tickLabelContainer.remove();
        this._baseline.remove();
        for (var i = 0; i < this._numTiers; ++i) {
            var tierContainer = this.content().append("g").classed(Time.TIME_AXIS_TIER_CLASS, true);
            this._tierLabelContainers.push(tierContainer.append("g")
                .classed(axis_1.Axis.TICK_LABEL_CLASS + "-container", true)
                .classed("label-" + this._tickLabelFontSize, true));
            this._tierMarkContainers.push(tierContainer.append("g").classed(axis_1.Axis.TICK_MARK_CLASS + "-container", true));
            this._tierBaselines.push(tierContainer.append("line").classed("baseline", true));
        }
        var context = new Typesettable.SvgContext(this._tierLabelContainers[0].node());
        this._measurer = new Typesettable.CacheMeasurer(context);
    };
    Time.prototype._getTickIntervalValues = function (config) {
        return this._scale.tickInterval(config.interval, config.step, this._useUTC);
    };
    Time.prototype._getTickValues = function () {
        var _this = this;
        return this._possibleTimeAxisConfigurations[this._mostPreciseConfigIndex].reduce(function (ticks, config) { return ticks.concat(_this._getTickIntervalValues(config)); }, []);
    };
    Time.prototype._cleanTiers = function () {
        for (var index = 0; index < this._tierLabelContainers.length; index++) {
            this._tierLabelContainers[index].selectAll("." + axis_1.Axis.TICK_LABEL_CLASS).remove();
            this._tierMarkContainers[index].selectAll("." + axis_1.Axis.TICK_MARK_CLASS).remove();
            this._tierBaselines[index].style("visibility", "hidden");
        }
    };
    Time.prototype._getTickValuesForConfiguration = function (config) {
        var tickPos = this._scale.tickInterval(config.interval, config.step, this._useUTC);
        var domain = this._scale.domain();
        var tickPosValues = tickPos.map(function (d) { return d.valueOf(); }); // can't indexOf with objects
        if (tickPosValues.indexOf(domain[0].valueOf()) === -1) {
            tickPos.unshift(domain[0]);
        }
        if (tickPosValues.indexOf(domain[1].valueOf()) === -1) {
            tickPos.push(domain[1]);
        }
        return tickPos;
    };
    Time.prototype._renderTierLabels = function (container, config, index) {
        var _this = this;
        var tickPos = this._getTickValuesForConfiguration(config);
        var labelPos = [];
        if (this._tierLabelPositions[index] === "between" && config.step === 1) {
            tickPos.map(function (datum, i) {
                if (i + 1 >= tickPos.length) {
                    return;
                }
                labelPos.push(new Date((tickPos[i + 1].valueOf() - tickPos[i].valueOf()) / 2 + tickPos[i].valueOf()));
            });
        }
        else {
            labelPos = tickPos;
        }
        var tickLabelsUpdate = container.selectAll("." + axis_1.Axis.TICK_LABEL_CLASS).data(labelPos, function (d) { return String(d.valueOf()); });
        tickLabelsUpdate.remove();
        var tickLabelsEnter = tickLabelsUpdate
            .enter()
            .append("g")
            .classed(axis_1.Axis.TICK_LABEL_CLASS, true);
        tickLabelsEnter.append("text");
        var xTranslate = (this._tierLabelPositions[index] === "center" || config.step === 1) ? 0 : this.tickLabelPadding();
        var yTranslate;
        if (this.orientation() === "bottom") {
            yTranslate = d3.sum(this._tierHeights.slice(0, index + 1)) - this.tickLabelPadding();
        }
        else {
            if (this._tierLabelPositions[index] === "center") {
                yTranslate = this.height() - d3.sum(this._tierHeights.slice(0, index)) - this.tickLabelPadding() - this._maxLabelTickLength();
            }
            else {
                yTranslate = this.height() - d3.sum(this._tierHeights.slice(0, index)) - this.tickLabelPadding();
            }
        }
        var tickLabels = tickLabelsUpdate.merge(tickLabelsEnter);
        var textSelection = tickLabels.selectAll("text");
        if (textSelection.size() > 0) {
            textSelection.attr("transform", "translate(" + xTranslate + "," + yTranslate + ")");
        }
        tickLabelsUpdate.exit().remove();
        tickLabels.attr("transform", function (d) { return "translate(" + _this._scale.scale(d) + ",0)"; });
        var anchor = (this._tierLabelPositions[index] === "center" || config.step === 1) ? "middle" : "start";
        tickLabels.selectAll("text").text(config.formatter).style("text-anchor", anchor);
    };
    Time.prototype._renderTickMarks = function (tickValues, index) {
        var tickMarksUpdate = this._tierMarkContainers[index].selectAll("." + axis_1.Axis.TICK_MARK_CLASS).data(tickValues);
        var tickMarks = tickMarksUpdate
            .enter()
            .append("line")
            .classed(axis_1.Axis.TICK_MARK_CLASS, true)
            .merge(tickMarksUpdate);
        var attr = this._generateTickMarkAttrHash();
        var offset = this._tierHeights.slice(0, index).reduce(function (translate, height) { return translate + height; }, 0);
        if (this.orientation() === "bottom") {
            attr["y1"] = offset;
            attr["y2"] = offset + (this._tierLabelPositions[index] === "center" ? this.innerTickLength() : this._tierHeights[index]);
        }
        else {
            attr["y1"] = this.height() - offset;
            attr["y2"] = this.height() - (offset + (this._tierLabelPositions[index] === "center" ?
                this.innerTickLength() : this._tierHeights[index]));
        }
        tickMarks.attrs(attr);
        if (this.orientation() === "bottom") {
            attr["y1"] = offset;
            attr["y2"] = offset + (this._tierLabelPositions[index] === "center" ? this.endTickLength() : this._tierHeights[index]);
        }
        else {
            attr["y1"] = this.height() - offset;
            attr["y2"] = this.height() - (offset + (this._tierLabelPositions[index] === "center" ?
                this.endTickLength() : this._tierHeights[index]));
        }
        d3.select(tickMarks.nodes()[0]).attrs(attr);
        d3.select(tickMarks.nodes()[tickMarks.size() - 1]).attrs(attr);
        // Add end-tick classes to first and last tick for CSS customization purposes
        d3.select(tickMarks.nodes()[0]).classed(axis_1.Axis.END_TICK_MARK_CLASS, true);
        d3.select(tickMarks.nodes()[tickMarks.size() - 1]).classed(axis_1.Axis.END_TICK_MARK_CLASS, true);
        tickMarksUpdate.exit().remove();
    };
    Time.prototype._renderLabellessTickMarks = function (tickValues) {
        var tickMarksUpdate = this._tickMarkContainer.selectAll("." + axis_1.Axis.TICK_MARK_CLASS).data(tickValues);
        var tickMarks = tickMarksUpdate
            .enter()
            .append("line")
            .classed(axis_1.Axis.TICK_MARK_CLASS, true)
            .merge(tickMarksUpdate);
        var attr = this._generateTickMarkAttrHash();
        attr["y2"] = (this.orientation() === "bottom") ? this.tickLabelPadding() : this.height() - this.tickLabelPadding();
        tickMarks.attrs(attr);
        tickMarksUpdate.exit().remove();
    };
    Time.prototype._generateLabellessTicks = function () {
        if (this._mostPreciseConfigIndex < 1) {
            return [];
        }
        return this._getTickIntervalValues(this._possibleTimeAxisConfigurations[this._mostPreciseConfigIndex - 1][0]);
    };
    Time.prototype.renderImmediately = function () {
        var _this = this;
        this._mostPreciseConfigIndex = this._getMostPreciseConfigurationIndex();
        var tierConfigs = this._possibleTimeAxisConfigurations[this._mostPreciseConfigIndex];
        this._cleanTiers();
        tierConfigs.forEach(function (config, i) {
            return _this._renderTierLabels(_this._tierLabelContainers[i], config, i);
        });
        var tierTicks = tierConfigs.map(function (config, i) {
            return _this._getTickValuesForConfiguration(config);
        });
        var baselineOffset = 0;
        for (var i = 0; i < Math.max(tierConfigs.length, 1); ++i) {
            var attr = this._generateBaselineAttrHash();
            attr["y1"] += (this.orientation() === "bottom") ? baselineOffset : -baselineOffset;
            attr["y2"] = attr["y1"];
            this._tierBaselines[i].attrs(attr).style("visibility", "inherit");
            baselineOffset += this._tierHeights[i];
        }
        var labelLessTicks = [];
        var domain = this._scale.domain();
        var totalLength = this._scale.scale(domain[1]) - this._scale.scale(domain[0]);
        if (this._getIntervalLength(tierConfigs[0]) * 1.5 >= totalLength) {
            labelLessTicks = this._generateLabellessTicks();
        }
        this._renderLabellessTickMarks(labelLessTicks);
        this._hideOverflowingTiers();
        for (var i = 0; i < tierConfigs.length; ++i) {
            this._renderTickMarks(tierTicks[i], i);
            this._hideOverlappingAndCutOffLabels(i);
        }
        if (this.annotationsEnabled()) {
            this._drawAnnotations();
        }
        else {
            this._removeAnnotations();
        }
        return this;
    };
    Time.prototype._hideOverflowingTiers = function () {
        var _this = this;
        var availableHeight = this.height();
        var usedHeight = 0;
        this.content()
            .selectAll("." + Time.TIME_AXIS_TIER_CLASS)
            .attr("visibility", function (d, i) {
            usedHeight += _this._tierHeights[i];
            return usedHeight <= availableHeight ? "inherit" : "hidden";
        });
    };
    Time.prototype._hideOverlappingAndCutOffLabels = function (index) {
        var _this = this;
        var boundingBox = this.element().node().getBoundingClientRect();
        var isInsideBBox = function (tickBox) {
            return (Math.floor(boundingBox.left) <= Math.ceil(tickBox.left) &&
                Math.floor(boundingBox.top) <= Math.ceil(tickBox.top) &&
                Math.floor(tickBox.right) <= Math.ceil(boundingBox.left + _this.width()) &&
                Math.floor(tickBox.bottom) <= Math.ceil(boundingBox.top + _this.height()));
        };
        var visibleTickMarks = this._tierMarkContainers[index]
            .selectAll("." + axis_1.Axis.TICK_MARK_CLASS)
            .filter(function (d, i) {
            var visibility = d3.select(this).style("visibility");
            return visibility === "visible" || visibility === "inherit";
        });
        // We use the ClientRects because x1/x2 attributes are not comparable to ClientRects of labels
        var visibleTickMarkRects = visibleTickMarks.nodes().map(function (mark) { return mark.getBoundingClientRect(); });
        var visibleTickLabels = this._tierLabelContainers[index]
            .selectAll("." + axis_1.Axis.TICK_LABEL_CLASS)
            .filter(function (d, i) {
            var visibility = d3.select(this).style("visibility");
            return visibility === "visible" || visibility === "inherit";
        });
        var lastLabelClientRect;
        visibleTickLabels.each(function (d, i) {
            var clientRect = this.getBoundingClientRect();
            var tickLabel = d3.select(this);
            var leadingTickMark = visibleTickMarkRects[i];
            var trailingTickMark = visibleTickMarkRects[i + 1];
            var isOverlappingLastLabel = (lastLabelClientRect != null && Utils.DOM.clientRectsOverlap(clientRect, lastLabelClientRect));
            var isOverlappingLeadingTickMark = (leadingTickMark != null && Utils.DOM.clientRectsOverlap(clientRect, leadingTickMark));
            var isOverlappingTrailingTickMark = (trailingTickMark != null && Utils.DOM.clientRectsOverlap(clientRect, trailingTickMark));
            if (!isInsideBBox(clientRect) || isOverlappingLastLabel || isOverlappingLeadingTickMark || isOverlappingTrailingTickMark) {
                tickLabel.style("visibility", "hidden");
            }
            else {
                lastLabelClientRect = clientRect;
                tickLabel.style("visibility", "inherit");
            }
        });
    };
    Time.prototype.invalidateCache = function () {
        _super.prototype.invalidateCache.call(this);
        if (this._measurer != null) {
            this._measurer.reset();
        }
    };
    /**
     * The CSS class applied to each Time Axis tier
     */
    Time.TIME_AXIS_TIER_CLASS = "time-axis-tier";
    Time._SORTED_TIME_INTERVAL_INDEX = (_a = {},
        _a[exports.TimeInterval.second] = 0,
        _a[exports.TimeInterval.minute] = 1,
        _a[exports.TimeInterval.hour] = 2,
        _a[exports.TimeInterval.day] = 3,
        _a[exports.TimeInterval.week] = 4,
        _a[exports.TimeInterval.month] = 5,
        _a[exports.TimeInterval.year] = 6,
        _a);
    Time._DEFAULT_TIME_AXIS_CONFIGURATIONS = function (useUTC) {
        var formatter = function (specifier) { return Formatters.time(specifier, useUTC); };
        return [
            [
                { interval: exports.TimeInterval.second, step: 1, formatter: formatter("%I:%M:%S %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.second, step: 5, formatter: formatter("%I:%M:%S %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.second, step: 10, formatter: formatter("%I:%M:%S %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.second, step: 15, formatter: formatter("%I:%M:%S %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.second, step: 30, formatter: formatter("%I:%M:%S %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.minute, step: 1, formatter: formatter("%I:%M %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.minute, step: 5, formatter: formatter("%I:%M %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.minute, step: 10, formatter: formatter("%I:%M %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.minute, step: 15, formatter: formatter("%I:%M %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.minute, step: 30, formatter: formatter("%I:%M %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.hour, step: 1, formatter: formatter("%I %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.hour, step: 3, formatter: formatter("%I %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.hour, step: 6, formatter: formatter("%I %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.hour, step: 12, formatter: formatter("%I %p") },
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%B %e, %Y") },
            ],
            [
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%a %e") },
                { interval: exports.TimeInterval.month, step: 1, formatter: formatter("%B %Y") },
            ],
            [
                { interval: exports.TimeInterval.day, step: 1, formatter: formatter("%e") },
                { interval: exports.TimeInterval.month, step: 1, formatter: formatter("%B %Y") },
            ],
            [
                { interval: exports.TimeInterval.month, step: 1, formatter: formatter("%B") },
                { interval: exports.TimeInterval.year, step: 1, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.month, step: 1, formatter: formatter("%b") },
                { interval: exports.TimeInterval.year, step: 1, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.month, step: 3, formatter: formatter("%b") },
                { interval: exports.TimeInterval.year, step: 1, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.month, step: 6, formatter: formatter("%b") },
                { interval: exports.TimeInterval.year, step: 1, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 1, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 1, formatter: formatter("%y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 5, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 25, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 50, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 100, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 200, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 500, formatter: formatter("%Y") },
            ],
            [
                { interval: exports.TimeInterval.year, step: 1000, formatter: formatter("%Y") },
            ],
        ];
    };
    Time._LONG_DATE = new Date(9999, 8, 29, 12, 59, 9999);
    return Time;
}(axis_1.Axis));
exports.Time = Time;

},{"../core/formatters":551,"../scales":607,"../utils":624,"../utils/makeEnum":625,"./axis":527,"d3":414,"tslib":635,"typesettable":640}],532:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Component = exports.YAlignment = exports.XAlignment = void 0;
var d3 = require("d3");
var RenderController = require("../core/renderController");
var Utils = require("../utils");
var isElement_1 = require("lodash-es/isElement");
var coerceD3_1 = require("../utils/coerceD3");
var makeEnum_1 = require("../utils/makeEnum");
exports.XAlignment = (0, makeEnum_1.makeEnum)(["left", "center", "right"]);
exports.YAlignment = (0, makeEnum_1.makeEnum)(["top", "center", "bottom"]);
/**
 * Components are the core logical units that build Plottable visualizations.
 *
 * This class deals with Component lifecycle (anchoring, getting a size, and rendering
 * infrastructure), as well as building the framework of DOM elements for all Components.
 */
var Component = /** @class */ (function () {
    function Component() {
        /**
         * Subclasses should set this to true in their constructor to prevent content from overflowing.
         */
        this._overflowHidden = false;
        /**
         * Origin of this Component relative to its parent.
         */
        this._origin = { x: 0, y: 0 };
        this._xAlignment = "left";
        this._yAlignment = "top";
        this._isSetup = false;
        this._isAnchored = false;
        this._cssClasses = new Utils.Set();
        /**
         * If .destroy() has been called on this Component.
         */
        this._destroyed = false;
        this._onAnchorCallbacks = new Utils.CallbackSet();
        this._onDetachCallbacks = new Utils.CallbackSet();
        this._cssClasses.add("component");
    }
    /**
     * Attaches the Component as a child of a given d3 Selection.
     *
     * @param {d3.Selection} selection.
     * @returns {Component} The calling Component.
     */
    Component.prototype.anchor = function (selection) {
        selection = (0, coerceD3_1.coerceExternalD3)(selection);
        if (this._destroyed) {
            throw new Error("Can't reuse destroy()-ed Components!");
        }
        if (this.isRoot()) {
            this._rootElement = selection;
            // rootElement gets the "plottable" CSS class
            this._rootElement.classed("plottable", true);
        }
        if (this._element != null) {
            // reattach existing element
            selection.node().appendChild(this._element.node());
        }
        else {
            this._element = selection.append("div");
            this._setup();
        }
        this._isAnchored = true;
        this._onAnchorCallbacks.callCallbacks(this);
        return this;
    };
    /**
     * Adds a callback to be called on anchoring the Component to the DOM.
     * If the Component is already anchored, the callback is called immediately.
     *
     * @param {ComponentCallback} callback
     * @return {Component}
     */
    Component.prototype.onAnchor = function (callback) {
        if (this._isAnchored) {
            callback(this);
        }
        this._onAnchorCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called on anchoring the Component to the DOM.
     * The callback is identified by reference equality.
     *
     * @param {ComponentCallback} callback
     * @return {Component}
     */
    Component.prototype.offAnchor = function (callback) {
        this._onAnchorCallbacks.delete(callback);
        return this;
    };
    /**
     * Creates additional elements as necessary for the Component to function.
     * Called during anchor() if the Component's element has not been created yet.
     * Override in subclasses to provide additional functionality.
     */
    Component.prototype._setup = function () {
        var _this = this;
        if (this._isSetup) {
            return;
        }
        this._cssClasses.forEach(function (cssClass) {
            _this._element.classed(cssClass, true);
        });
        this._cssClasses = new Utils.Set();
        this._backgroundContainer = this._element.append("svg").classed("background-container", true);
        this._content = this._element.append("svg").classed("content", true);
        this._foregroundContainer = this._element.append("svg").classed("foreground-container", true);
        if (this._overflowHidden) {
            this._content.classed("component-overflow-hidden", true);
        }
        else {
            this._content.classed("component-overflow-visible", true);
        }
        this._isSetup = true;
    };
    /**
     * Given available space in pixels, returns the minimum width and height this Component will need.
     *
     * @param {number} availableWidth
     * @param {number} availableHeight
     * @returns {SpaceRequest}
     */
    Component.prototype.requestedSpace = function (availableWidth, availableHeight) {
        return {
            minWidth: 0,
            minHeight: 0,
        };
    };
    /**
     * Computes and sets the size, position, and alignment of the Component from the specified values.
     * If no parameters are supplied and the Component is a root node,
     * they are inferred from the size of the Component's element.
     *
     * @param {Point} [origin] Origin of the space offered to the Component.
     * @param {number} [availableWidth] Available width in pixels.
     * @param {number} [availableHeight] Available height in pixels.
     * @returns {Component} The calling Component.
     */
    Component.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        if (origin == null || availableWidth == null || availableHeight == null) {
            if (this._element == null) {
                throw new Error("anchor() must be called before computeLayout()");
            }
            else if (this._rootElement != null) {
                // retrieve height/width from rootElement
                origin = { x: 0, y: 0 };
                var elem = this._rootElement.node();
                availableWidth = Utils.DOM.elementWidth(elem);
                availableHeight = Utils.DOM.elementHeight(elem);
            }
            else {
                throw new Error("null arguments cannot be passed to computeLayout() on a non-root, unanchored node");
            }
        }
        var _a = this._sizeFromOffer(availableWidth, availableHeight), height = _a.height, width = _a.width;
        var xAlignProportion = Component._xAlignToProportion[this._xAlignment];
        var yAlignProportion = Component._yAlignToProportion[this._yAlignment];
        var originX = origin.x + (availableWidth - width) * xAlignProportion;
        var originY = origin.y + (availableHeight - height) * yAlignProportion;
        this.setBounds(width, height, originX, originY);
        return this;
    };
    /**
     * Directly sets component size and, optionally, its origin.
     *
     * Preferably, layout is accomplished by placing components in a table.
     * However, if you need to directly override the component size, you may call
     * this method.
     *
     * Note that this method styles the anchored element, so this is usually only
     * useful after the component has been anchored. If the component has not been
     * anchored to an element, the internal properties will be set but no styles
     * will be applied.
     *
     * @param {number} [width] width in pixels
     * @param {number} [height] height in pixels
     * @param {number} [originX] left offset in pixels
     * @param {number} [originY] top offset in pixels
     */
    Component.prototype.setBounds = function (width, height, originX, originY) {
        if (originX === void 0) { originX = 0; }
        if (originY === void 0) { originY = 0; }
        this._width = width;
        this._height = height;
        this._origin = {
            x: originX,
            y: originY,
        };
        if (this._element != null) {
            this._element.styles({
                left: originX + "px",
                height: height + "px",
                top: originY + "px",
                width: width + "px",
            });
        }
        if (this._resizeHandler != null) {
            this._resizeHandler({ width: width, height: height });
        }
        return this;
    };
    Component.prototype._sizeFromOffer = function (availableWidth, availableHeight) {
        var requestedSpace = this.requestedSpace(availableWidth, availableHeight);
        return {
            width: this.fixedWidth() ? Math.min(availableWidth, requestedSpace.minWidth) : availableWidth,
            height: this.fixedHeight() ? Math.min(availableHeight, requestedSpace.minHeight) : availableHeight,
        };
    };
    /**
     * Queues the Component for rendering.
     *
     * @returns {Component} The calling Component.
     */
    Component.prototype.render = function () {
        if (this._isAnchored && this._isSetup && this.width() >= 0 && this.height() >= 0) {
            RenderController.registerToRender(this);
        }
        return this;
    };
    Component.prototype.renderLowPriority = function () {
        return this.render();
    };
    Component.prototype._scheduleComputeLayout = function () {
        if (this._isAnchored && this._isSetup) {
            RenderController.registerToComputeLayoutAndRender(this);
        }
    };
    /**
     * Sets a callback that gets called when the component resizes. The size change
     * is not guaranteed to be reflected by the DOM at the time the callback is fired.
     *
     * @param {IResizeHandler} [resizeHandler] Callback to be called when component resizes
     */
    Component.prototype.onResize = function (resizeHandler) {
        this._resizeHandler = resizeHandler;
        return this;
    };
    /**
     * Renders the Component without waiting for the next frame. This method is a no-op on
     * Component, Table, and Group; render them immediately with .renderTo() instead.
     */
    Component.prototype.renderImmediately = function () {
        return this;
    };
    /**
     * Causes the Component to re-layout and render.
     *
     * @returns {Component} The calling Component.
     */
    Component.prototype.redraw = function () {
        if (this._isAnchored && this._isSetup) {
            if (this.isRoot()) {
                this._scheduleComputeLayout();
            }
            else {
                this.parent().redraw();
            }
        }
        return this;
    };
    /**
     * Tell this component to invalidate any caching. This function should be
     * called when a CSS change has occurred that could influence the layout
     * of the Component, such as changing the font size.
     *
     * Subclasses should override.
     */
    Component.prototype.invalidateCache = function () {
        // Core component has no caching.
    };
    /**
     * Renders the Component to a given HTML Element.
     *
     * @param {String|d3.Selection} element The element, a selector string for the element, or a d3.Selection for the element.
     * @returns {Component} The calling Component.
     */
    Component.prototype.renderTo = function (element) {
        this.detach();
        if (element != null) {
            var selection = void 0;
            if (typeof (element) === "string") {
                selection = d3.select(element);
            }
            else if ((0, isElement_1.default)(element)) {
                selection = d3.select(element);
            }
            else {
                selection = (0, coerceD3_1.coerceExternalD3)(element);
            }
            if (!selection.node() || selection.node().nodeName == null) {
                throw new Error("Plottable requires a valid Element to renderTo");
            }
            if (selection.node().nodeName === "svg") {
                throw new Error("Plottable 3.x and later can only renderTo an HTML component; pass a div instead!");
            }
            this.anchor(selection);
        }
        if (this._element == null) {
            throw new Error("If a Component has never been rendered before, then renderTo must be given a node to render to, " +
                "or a d3.Selection, or a selector string");
        }
        RenderController.registerToComputeLayoutAndRender(this);
        // flush so that consumers can immediately attach to stuff we create in the DOM
        RenderController.flush();
        return this;
    };
    Component.prototype.xAlignment = function (xAlignment) {
        if (xAlignment == null) {
            return this._xAlignment;
        }
        xAlignment = xAlignment.toLowerCase();
        if (Component._xAlignToProportion[xAlignment] == null) {
            throw new Error("Unsupported alignment: " + xAlignment);
        }
        this._xAlignment = xAlignment;
        this.redraw();
        return this;
    };
    Component.prototype.yAlignment = function (yAlignment) {
        if (yAlignment == null) {
            return this._yAlignment;
        }
        yAlignment = yAlignment.toLowerCase();
        if (Component._yAlignToProportion[yAlignment] == null) {
            throw new Error("Unsupported alignment: " + yAlignment);
        }
        this._yAlignment = yAlignment;
        this.redraw();
        return this;
    };
    /**
     * Checks if the Component has a given CSS class.
     *
     * @param {string} cssClass The CSS class to check for.
     */
    Component.prototype.hasClass = function (cssClass) {
        if (cssClass == null) {
            return false;
        }
        if (this._element == null) {
            return this._cssClasses.has(cssClass);
        }
        else {
            return this._element.classed(cssClass);
        }
    };
    /**
     * Adds a given CSS class to the Component.
     *
     * @param {string} cssClass The CSS class to add.
     * @returns {Component} The calling Component.
     */
    Component.prototype.addClass = function (cssClass) {
        if (cssClass == null) {
            return this;
        }
        if (this._element == null) {
            this._cssClasses.add(cssClass);
        }
        else {
            this._element.classed(cssClass, true);
        }
        return this;
    };
    /**
     * Removes a given CSS class from the Component.
     *
     * @param {string} cssClass The CSS class to remove.
     * @returns {Component} The calling Component.
     */
    Component.prototype.removeClass = function (cssClass) {
        if (cssClass == null) {
            return this;
        }
        if (this._element == null) {
            this._cssClasses.delete(cssClass);
        }
        else {
            this._element.classed(cssClass, false);
        }
        return this;
    };
    /**
     * Checks if the Component has a fixed width or if it grows to fill available space.
     * Returns false by default on the base Component class.
     */
    Component.prototype.fixedWidth = function () {
        return false;
    };
    /**
     * Checks if the Component has a fixed height or if it grows to fill available space.
     * Returns false by default on the base Component class.
     */
    Component.prototype.fixedHeight = function () {
        return false;
    };
    /**
     * Detaches a Component from the DOM. The Component can be reused.
     *
     * This should only be used if you plan on reusing the calling Component. Otherwise, use destroy().
     *
     * @returns The calling Component.
     */
    Component.prototype.detach = function () {
        this.parent(null);
        if (this._isAnchored) {
            this._element.remove();
        }
        this._isAnchored = false;
        this._onDetachCallbacks.callCallbacks(this);
        return this;
    };
    /**
     * Adds a callback to be called when the Component is detach()-ed.
     *
     * @param {ComponentCallback} callback
     * @return {Component} The calling Component.
     */
    Component.prototype.onDetach = function (callback) {
        this._onDetachCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback to be called when the Component is detach()-ed.
     * The callback is identified by reference equality.
     *
     * @param {ComponentCallback} callback
     * @return {Component} The calling Component.
     */
    Component.prototype.offDetach = function (callback) {
        this._onDetachCallbacks.delete(callback);
        return this;
    };
    Component.prototype.parent = function (parent) {
        if (parent === undefined) {
            return this._parent;
        }
        if (parent !== null && !parent.has(this)) {
            throw new Error("Passed invalid parent");
        }
        this._parent = parent;
        return this;
    };
    /**
     * @returns {Bounds} for the component in pixel space, where the topLeft
     * represents the component's minimum x and y values and the bottomRight represents
     * the component's maximum x and y values.
     */
    Component.prototype.bounds = function () {
        var topLeft = this.origin();
        return {
            topLeft: topLeft,
            bottomRight: {
                x: topLeft.x + this.width(),
                y: topLeft.y + this.height(),
            },
        };
    };
    /**
     * Removes a Component from the DOM and disconnects all listeners.
     */
    Component.prototype.destroy = function () {
        this._destroyed = true;
        this.detach();
    };
    /**
     * Gets the width of the Component in pixels.
     */
    Component.prototype.width = function () {
        return this._width;
    };
    /**
     * Gets the height of the Component in pixels.
     */
    Component.prototype.height = function () {
        return this._height;
    };
    /**
     * Gets the origin of the Component relative to its parent.
     *
     * @return {Point}
     */
    Component.prototype.origin = function () {
        return {
            x: this._origin.x,
            y: this._origin.y,
        };
    };
    /**
     * Gets the origin of the Component relative to the root Component.
     *
     * @return {Point}
     */
    Component.prototype.originToRoot = function () {
        var origin = this.origin();
        var ancestor = this.parent();
        while (ancestor != null) {
            var ancestorOrigin = ancestor.origin();
            origin.x += ancestorOrigin.x;
            origin.y += ancestorOrigin.y;
            ancestor = ancestor.parent();
        }
        return origin;
    };
    /**
     * Gets the root component of the hierarchy. If the provided
     * component is the root, that component will be returned.
     */
    Component.prototype.root = function () {
        var component = this;
        while (!component.isRoot()) {
            component = component.parent();
        }
        return component;
    };
    Component.prototype.isRoot = function () {
        return this.parent() == null;
    };
    /**
     * Gets the Selection containing the <g> in front of the visual elements of the Component.
     *
     * Will return undefined if the Component has not been anchored.
     *
     * @return {d3.Selection}
     */
    Component.prototype.foreground = function () {
        return this._foregroundContainer;
    };
    /**
     * Gets the SVG that holds the visual elements of the Component.
     *
     * Will return undefined if the Component has not been anchored.
     *
     * @return {d3.Selection} content selection for the Component
     */
    Component.prototype.content = function () {
        return this._content;
    };
    /**
     * Returns the HTML Element at the root of this component's DOM tree.
     */
    Component.prototype.element = function () {
        return this._element;
    };
    /**
     * Returns the top-level user supplied element that roots the tree that this Component lives in.
     */
    Component.prototype.rootElement = function () {
        return this.root()._rootElement;
    };
    /**
     * Gets the Selection containing the <g> behind the visual elements of the Component.
     *
     * Will return undefined if the Component has not been anchored.
     *
     * @return {d3.Selection} background selection for the Component
     */
    Component.prototype.background = function () {
        return this._backgroundContainer;
    };
    Component._xAlignToProportion = {
        left: 0,
        center: 0.5,
        right: 1,
    };
    Component._yAlignToProportion = {
        top: 0,
        center: 0.5,
        bottom: 1,
    };
    return Component;
}());
exports.Component = Component;

},{"../core/renderController":553,"../utils":624,"../utils/coerceD3":620,"../utils/makeEnum":625,"d3":414,"lodash-es/isElement":517}],533:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentContainer = void 0;
var tslib_1 = require("tslib");
var coerceD3_1 = require("../utils/coerceD3");
var component_1 = require("./component");
/*
 * ComponentContainer class encapsulates Table and ComponentGroup's shared functionality.
 * It will not do anything if instantiated directly.
 */
var ComponentContainer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ComponentContainer, _super);
    function ComponentContainer() {
        var _this = _super.call(this) || this;
        _this._detachCallback = function (component) { return _this.remove(component); };
        return _this;
    }
    ComponentContainer.prototype.anchor = function (selection) {
        var _this = this;
        selection = (0, coerceD3_1.coerceExternalD3)(selection);
        _super.prototype.anchor.call(this, selection);
        this._forEach(function (c) { return c.anchor(_this.element()); });
        return this;
    };
    ComponentContainer.prototype.render = function () {
        this._forEach(function (c) { return c.render(); });
        return this;
    };
    /**
     * Checks whether the specified Component is in the ComponentContainer.
     */
    ComponentContainer.prototype.has = function (component) {
        throw new Error("has() is not implemented on ComponentContainer");
    };
    ComponentContainer.prototype._adoptAndAnchor = function (component) {
        component.parent(this);
        component.onDetach(this._detachCallback);
        if (this._isAnchored) {
            component.anchor(this.element());
        }
    };
    /**
     * Removes the specified Component from the ComponentContainer.
     */
    ComponentContainer.prototype.remove = function (component) {
        if (this.has(component)) {
            component.offDetach(this._detachCallback);
            this._remove(component);
            component.detach();
            this.redraw();
        }
        return this;
    };
    /**
     * Carry out the actual removal of a Component.
     * Implementation dependent on the type of container.
     *
     * @return {boolean} true if the Component was successfully removed, false otherwise.
     */
    ComponentContainer.prototype._remove = function (component) {
        return false;
    };
    /**
     * Invokes a callback on each Component in the ComponentContainer.
     */
    ComponentContainer.prototype._forEach = function (callback) {
        throw new Error("_forEach() is not implemented on ComponentContainer");
    };
    /**
     * Destroys the ComponentContainer and all Components within it.
     */
    ComponentContainer.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this._forEach(function (c) { return c.destroy(); });
    };
    ComponentContainer.prototype.invalidateCache = function () {
        this._forEach(function (c) { return c.invalidateCache(); });
    };
    return ComponentContainer;
}(component_1.Component));
exports.ComponentContainer = ComponentContainer;

},{"../utils/coerceD3":620,"./component":532,"tslib":635}],534:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DragBoxLayer = void 0;
var tslib_1 = require("tslib");
var Interactions = require("../interactions");
var Utils = require("../utils");
var coerceD3_1 = require("../utils/coerceD3");
var _1 = require("./");
var selectionBoxLayer_1 = require("./selectionBoxLayer");
var DragBoxLayer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(DragBoxLayer, _super);
    /**
     * Constructs a DragBoxLayer.
     *
     * A DragBoxLayer is a SelectionBoxLayer with a built-in Drag Interaction.
     * A drag gesture will set the Bounds of the box.
     * If resizing is enabled using resizable(true), the edges of box can be repositioned.
     *
     * @constructor
     */
    function DragBoxLayer() {
        var _this = _super.call(this) || this;
        _this._detectionRadius = 3;
        _this._resizable = false;
        _this._movable = false;
        _this._hasCorners = true;
        _this.addClass("drag-box-layer");
        _this._dragInteraction = new Interactions.Drag();
        _this._setUpCallbacks();
        _this._dragInteraction.attachTo(_this);
        _this._dragStartCallbacks = new Utils.CallbackSet();
        _this._dragCallbacks = new Utils.CallbackSet();
        _this._dragEndCallbacks = new Utils.CallbackSet();
        return _this;
    }
    DragBoxLayer.prototype._setUpCallbacks = function () {
        var _this = this;
        var resizingEdges;
        var topLeft;
        var bottomRight;
        var lastEndPoint;
        var DRAG_MODES = {
            newBox: 0,
            resize: 1,
            move: 2,
        };
        var mode = DRAG_MODES.newBox;
        var onDragStartCallback = function (startPoint) {
            resizingEdges = _this._getResizingEdges(startPoint);
            var bounds = _this.bounds();
            var isInsideBox = bounds.topLeft.x <= startPoint.x && startPoint.x <= bounds.bottomRight.x &&
                bounds.topLeft.y <= startPoint.y && startPoint.y <= bounds.bottomRight.y;
            if (_this.boxVisible() && (resizingEdges.top || resizingEdges.bottom || resizingEdges.left || resizingEdges.right)) {
                mode = DRAG_MODES.resize;
            }
            else if (_this.boxVisible() && _this.movable() && isInsideBox) {
                mode = DRAG_MODES.move;
            }
            else {
                mode = DRAG_MODES.newBox;
                _this._setBounds({
                    topLeft: startPoint,
                    bottomRight: startPoint,
                });
                if (_this._xBoundsMode === _1.PropertyMode.VALUE && _this.xScale() != null) {
                    _this._setXExtent([_this.xScale().invert(startPoint.x), _this.xScale().invert(startPoint.x)]);
                }
                if (_this._yBoundsMode === _1.PropertyMode.VALUE && _this.yScale() != null) {
                    _this._setYExtent([_this.yScale().invert(startPoint.y), _this.yScale().invert(startPoint.y)]);
                }
                _this.render();
            }
            _this.boxVisible(true);
            bounds = _this.bounds();
            // copy points so changes to topLeft and bottomRight don't mutate bounds
            topLeft = { x: bounds.topLeft.x, y: bounds.topLeft.y };
            bottomRight = { x: bounds.bottomRight.x, y: bounds.bottomRight.y };
            lastEndPoint = startPoint;
            _this._dragStartCallbacks.callCallbacks(bounds);
        };
        var onDragCallback = function (startPoint, endPoint) {
            switch (mode) {
                case DRAG_MODES.newBox:
                    bottomRight.x = endPoint.x;
                    bottomRight.y = endPoint.y;
                    break;
                case DRAG_MODES.resize:
                    if (resizingEdges.bottom) {
                        bottomRight.y = endPoint.y;
                    }
                    else if (resizingEdges.top) {
                        topLeft.y = endPoint.y;
                    }
                    if (resizingEdges.right) {
                        bottomRight.x = endPoint.x;
                    }
                    else if (resizingEdges.left) {
                        topLeft.x = endPoint.x;
                    }
                    break;
                case DRAG_MODES.move:
                    var dx = endPoint.x - lastEndPoint.x;
                    var dy = endPoint.y - lastEndPoint.y;
                    topLeft.x += dx;
                    topLeft.y += dy;
                    bottomRight.x += dx;
                    bottomRight.y += dy;
                    lastEndPoint = endPoint;
                    break;
            }
            _this._setBounds({
                topLeft: topLeft,
                bottomRight: bottomRight,
            });
            if (_this._xBoundsMode === _1.PropertyMode.VALUE && _this.xScale() != null) {
                _this._setXExtent([_this.xScale().invert(topLeft.x), _this.xScale().invert(bottomRight.x)]);
            }
            if (_this._yBoundsMode === _1.PropertyMode.VALUE && _this.yScale() != null) {
                _this._setYExtent([_this.yScale().invert(topLeft.y), _this.yScale().invert(bottomRight.y)]);
            }
            _this.render();
            _this._dragCallbacks.callCallbacks(_this.bounds());
        };
        var onDragEndCallback = function (startPoint, endPoint) {
            if (mode === DRAG_MODES.newBox && startPoint.x === endPoint.x && startPoint.y === endPoint.y) {
                _this.boxVisible(false);
            }
            _this._dragEndCallbacks.callCallbacks(_this.bounds());
        };
        this._dragInteraction.onDragStart(onDragStartCallback);
        this._dragInteraction.onDrag(onDragCallback);
        this._dragInteraction.onDragEnd(onDragEndCallback);
        this._disconnectInteraction = function () {
            _this._dragInteraction.offDragStart(onDragStartCallback);
            _this._dragInteraction.offDrag(onDragCallback);
            _this._dragInteraction.offDragEnd(onDragEndCallback);
            _this._dragInteraction.detach();
        };
    };
    DragBoxLayer.prototype._setup = function () {
        var _this = this;
        _super.prototype._setup.call(this);
        var createLine = function () { return _this._box.append("line").styles({
            opacity: 0,
            stroke: "pink",
            "pointer-events": "visibleStroke",
        }); };
        this._detectionEdgeT = createLine().classed("drag-edge-tb", true);
        this._detectionEdgeB = createLine().classed("drag-edge-tb", true);
        this._detectionEdgeL = createLine().classed("drag-edge-lr", true);
        this._detectionEdgeR = createLine().classed("drag-edge-lr", true);
        if (this._hasCorners) {
            var createCorner = function () { return _this._box.append("circle")
                .styles({
                opacity: 0,
                fill: "pink",
                "pointer-events": "visibleFill",
            }); };
            this._detectionCornerTL = createCorner().classed("drag-corner-tl", true);
            this._detectionCornerTR = createCorner().classed("drag-corner-tr", true);
            this._detectionCornerBL = createCorner().classed("drag-corner-bl", true);
            this._detectionCornerBR = createCorner().classed("drag-corner-br", true);
        }
    };
    DragBoxLayer.prototype._getResizingEdges = function (p) {
        var edges = {
            top: false,
            bottom: false,
            left: false,
            right: false,
        };
        if (!this.resizable()) {
            return edges;
        }
        var bounds = this.bounds();
        var t = bounds.topLeft.y;
        var b = bounds.bottomRight.y;
        var l = bounds.topLeft.x;
        var r = bounds.bottomRight.x;
        var rad = this._detectionRadius;
        if (l - rad <= p.x && p.x <= r + rad) {
            edges.top = (t - rad <= p.y && p.y <= t + rad);
            edges.bottom = (b - rad <= p.y && p.y <= b + rad);
        }
        if (t - rad <= p.y && p.y <= b + rad) {
            edges.left = (l - rad <= p.x && p.x <= l + rad);
            edges.right = (r - rad <= p.x && p.x <= r + rad);
        }
        return edges;
    };
    DragBoxLayer.prototype.renderImmediately = function () {
        _super.prototype.renderImmediately.call(this);
        if (this.boxVisible()) {
            var bounds = this.bounds();
            var t = bounds.topLeft.y;
            var b = bounds.bottomRight.y;
            var l = bounds.topLeft.x;
            var r = bounds.bottomRight.x;
            this._detectionEdgeT.attrs({
                x1: l, y1: t, x2: r, y2: t,
                "stroke-width": this._detectionRadius * 2,
            });
            this._detectionEdgeB.attrs({
                x1: l, y1: b, x2: r, y2: b,
                "stroke-width": this._detectionRadius * 2,
            });
            this._detectionEdgeL.attrs({
                x1: l, y1: t, x2: l, y2: b,
                "stroke-width": this._detectionRadius * 2,
            });
            this._detectionEdgeR.attrs({
                x1: r, y1: t, x2: r, y2: b,
                "stroke-width": this._detectionRadius * 2,
            });
            if (this._hasCorners) {
                this._detectionCornerTL.attrs({ cx: l, cy: t, r: this._detectionRadius });
                this._detectionCornerTR.attrs({ cx: r, cy: t, r: this._detectionRadius });
                this._detectionCornerBL.attrs({ cx: l, cy: b, r: this._detectionRadius });
                this._detectionCornerBR.attrs({ cx: r, cy: b, r: this._detectionRadius });
            }
        }
        return this;
    };
    DragBoxLayer.prototype.detectionRadius = function (r) {
        if (r == null) {
            return this._detectionRadius;
        }
        if (r < 0) {
            throw new Error("detection radius cannot be negative.");
        }
        this._detectionRadius = r;
        this.render();
        return this;
    };
    DragBoxLayer.prototype.resizable = function (canResize) {
        if (canResize == null) {
            return this._resizable;
        }
        this._resizable = canResize;
        this._setResizableClasses(canResize);
        return this;
    };
    // Sets resizable classes. Overridden by subclasses that only resize in one dimension.
    DragBoxLayer.prototype._setResizableClasses = function (canResize) {
        if (canResize && this.enabled()) {
            this.addClass("x-resizable");
            this.addClass("y-resizable");
        }
        else {
            this.removeClass("x-resizable");
            this.removeClass("y-resizable");
        }
    };
    DragBoxLayer.prototype.movable = function (movable) {
        if (movable == null) {
            return this._movable;
        }
        this._movable = movable;
        this._setMovableClass();
        return this;
    };
    DragBoxLayer.prototype._setMovableClass = function () {
        if (this.movable() && this.enabled()) {
            this.addClass("movable");
        }
        else {
            this.removeClass("movable");
        }
    };
    /**
     * Sets the callback to be called when dragging starts.
     *
     * @param {DragBoxCallback} callback
     * @returns {DragBoxLayer} The calling DragBoxLayer.
     */
    DragBoxLayer.prototype.onDragStart = function (callback) {
        this._dragStartCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback to be called when dragging starts.
     *
     * @param {DragBoxCallback} callback
     * @returns {DragBoxLayer} The calling DragBoxLayer.
     */
    DragBoxLayer.prototype.offDragStart = function (callback) {
        this._dragStartCallbacks.delete(callback);
        return this;
    };
    /**
     * Sets a callback to be called during dragging.
     *
     * @param {DragBoxCallback} callback
     * @returns {DragBoxLayer} The calling DragBoxLayer.
     */
    DragBoxLayer.prototype.onDrag = function (callback) {
        this._dragCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback to be called during dragging.
     *
     * @param {DragBoxCallback} callback
     * @returns {DragBoxLayer} The calling DragBoxLayer.
     */
    DragBoxLayer.prototype.offDrag = function (callback) {
        this._dragCallbacks.delete(callback);
        return this;
    };
    /**
     * Sets a callback to be called when dragging ends.
     *
     * @param {DragBoxCallback} callback
     * @returns {DragBoxLayer} The calling DragBoxLayer.
     */
    DragBoxLayer.prototype.onDragEnd = function (callback) {
        this._dragEndCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback to be called when dragging ends.
     *
     * @param {DragBoxCallback} callback
     * @returns {DragBoxLayer} The calling DragBoxLayer.
     */
    DragBoxLayer.prototype.offDragEnd = function (callback) {
        this._dragEndCallbacks.delete(callback);
        return this;
    };
    /**
     * Gets the internal Interactions.Drag of the DragBoxLayer.
     */
    DragBoxLayer.prototype.dragInteraction = function () {
        return this._dragInteraction;
    };
    DragBoxLayer.prototype.enabled = function (enabled) {
        if (enabled == null) {
            return this._dragInteraction.enabled();
        }
        this._dragInteraction.enabled(enabled);
        this._setResizableClasses(this.resizable());
        this._setMovableClass();
        return this;
    };
    DragBoxLayer.prototype.destroy = function () {
        var _this = this;
        _super.prototype.destroy.call(this);
        this._dragStartCallbacks.forEach(function (callback) { return _this._dragCallbacks.delete(callback); });
        this._dragCallbacks.forEach(function (callback) { return _this._dragCallbacks.delete(callback); });
        this._dragEndCallbacks.forEach(function (callback) { return _this._dragEndCallbacks.delete(callback); });
        this._disconnectInteraction();
    };
    DragBoxLayer.prototype.detach = function () {
        this._resetState();
        this._dragInteraction.detach();
        _super.prototype.detach.call(this);
        return this;
    };
    DragBoxLayer.prototype.anchor = function (selection) {
        selection = (0, coerceD3_1.coerceExternalD3)(selection);
        this._dragInteraction.attachTo(this);
        _super.prototype.anchor.call(this, selection);
        return this;
    };
    DragBoxLayer.prototype._resetState = function () {
        this.bounds({
            topLeft: { x: 0, y: 0 },
            bottomRight: { x: 0, y: 0 },
        });
    };
    return DragBoxLayer;
}(selectionBoxLayer_1.SelectionBoxLayer));
exports.DragBoxLayer = DragBoxLayer;

},{"../interactions":578,"../utils":624,"../utils/coerceD3":620,"./":539,"./selectionBoxLayer":544,"tslib":635}],535:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DragLineLayer = void 0;
var tslib_1 = require("tslib");
var guideLineLayer_1 = require("../components/guideLineLayer");
var Interactions = require("../interactions");
var Utils = require("../utils");
var DragLineLayer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(DragLineLayer, _super);
    function DragLineLayer(orientation) {
        var _this = _super.call(this, orientation) || this;
        _this._detectionRadius = 3;
        _this._enabled = true;
        _this.addClass("drag-line-layer");
        _this.addClass("enabled");
        _this._dragInteraction = new Interactions.Drag();
        _this._dragInteraction.attachTo(_this);
        var onLine = function (p) {
            return (_this._isVertical() &&
                _this.pixelPosition() - _this.detectionRadius() <= p.x &&
                p.x <= _this.pixelPosition() + _this.detectionRadius()) ||
                (!_this._isVertical() &&
                    _this.pixelPosition() - _this.detectionRadius() <= p.y &&
                    p.y <= _this.pixelPosition() + _this.detectionRadius());
        };
        var dragging = false;
        var interactionDragStartCallback = function (start) {
            if (onLine(start)) {
                dragging = true;
                _this._dragStartCallbacks.callCallbacks(_this);
            }
        };
        _this._dragInteraction.onDragStart(interactionDragStartCallback);
        var interactionDragCallback = function (start, end) {
            if (dragging) {
                _this._setPixelPositionWithoutChangingMode(_this._isVertical() ? end.x : end.y);
                _this._dragCallbacks.callCallbacks(_this);
            }
        };
        _this._dragInteraction.onDrag(interactionDragCallback);
        var interactionDragEndCallback = function (start, end) {
            if (dragging) {
                dragging = false;
                _this._dragEndCallbacks.callCallbacks(_this);
            }
        };
        _this._dragInteraction.onDragEnd(interactionDragEndCallback);
        _this._disconnectInteraction = function () {
            _this._dragInteraction.offDragStart(interactionDragStartCallback);
            _this._dragInteraction.offDrag(interactionDragCallback);
            _this._dragInteraction.offDragEnd(interactionDragEndCallback);
            _this._dragInteraction.detach();
        };
        _this._dragStartCallbacks = new Utils.CallbackSet();
        _this._dragCallbacks = new Utils.CallbackSet();
        _this._dragEndCallbacks = new Utils.CallbackSet();
        return _this;
    }
    DragLineLayer.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._detectionEdge = this.content().append("line").styles({
            opacity: 0,
            stroke: "pink",
            "pointer-events": "visibleStroke",
        }).classed("drag-edge", true);
    };
    DragLineLayer.prototype.renderImmediately = function () {
        _super.prototype.renderImmediately.call(this);
        this._detectionEdge.attrs({
            x1: this._isVertical() ? this.pixelPosition() : 0,
            y1: this._isVertical() ? 0 : this.pixelPosition(),
            x2: this._isVertical() ? this.pixelPosition() : this.width(),
            y2: this._isVertical() ? this.height() : this.pixelPosition(),
            "stroke-width": this._detectionRadius * 2,
        });
        return this;
    };
    DragLineLayer.prototype.detectionRadius = function (detectionRadius) {
        if (detectionRadius == null) {
            return this._detectionRadius;
        }
        if (detectionRadius < 0) {
            throw new Error("detection radius cannot be negative.");
        }
        this._detectionRadius = detectionRadius;
        this.render();
        return this;
    };
    DragLineLayer.prototype.enabled = function (enabled) {
        if (enabled == null) {
            return this._enabled;
        }
        this._enabled = enabled;
        if (enabled) {
            this.addClass("enabled");
        }
        else {
            this.removeClass("enabled");
        }
        this._dragInteraction.enabled(enabled);
        return this;
    };
    /**
     * Sets the callback to be called when dragging starts.
     * The callback will be passed the calling DragLineLayer.
     *
     * @param {DragLineCallback<D>} callback
     * @returns {DragLineLayer<D>} The calling DragLineLayer.
     */
    DragLineLayer.prototype.onDragStart = function (callback) {
        this._dragStartCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when dragging starts.
     *
     * @param {DragLineCallback<D>} callback
     * @returns {DragLineLayer<D>} The calling DragLineLayer.
     */
    DragLineLayer.prototype.offDragStart = function (callback) {
        this._dragStartCallbacks.delete(callback);
        return this;
    };
    /**
     * Sets a callback to be called during dragging.
     * The callback will be passed the calling DragLineLayer.
     *
     * @param {DragLineCallback<D>} callback
     * @returns {DragLineLayer<D>} The calling DragLineLayer.
     */
    DragLineLayer.prototype.onDrag = function (callback) {
        this._dragCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called during dragging.
     *
     * @param {DragLineCallback<D>} callback
     * @returns {DragLineLayer<D>} The calling DragLineLayer.
     */
    DragLineLayer.prototype.offDrag = function (callback) {
        this._dragCallbacks.delete(callback);
        return this;
    };
    /**
     * Sets a callback to be called when dragging ends.
     * The callback will be passed the calling DragLineLayer.
     *
     * @param {DragLineCallback<D>} callback
     * @returns {DragLineLayer<D>} The calling DragLineLayer.
     */
    DragLineLayer.prototype.onDragEnd = function (callback) {
        this._dragEndCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when dragging ends.
     *
     * @param {DragLineCallback<D>} callback
     * @returns {DragLineLayer<D>} The calling DragLineLayer.
     */
    DragLineLayer.prototype.offDragEnd = function (callback) {
        this._dragEndCallbacks.delete(callback);
        return this;
    };
    DragLineLayer.prototype.destroy = function () {
        var _this = this;
        _super.prototype.destroy.call(this);
        this._dragStartCallbacks.forEach(function (callback) { return _this._dragStartCallbacks.delete(callback); });
        this._dragCallbacks.forEach(function (callback) { return _this._dragCallbacks.delete(callback); });
        this._dragEndCallbacks.forEach(function (callback) { return _this._dragEndCallbacks.delete(callback); });
        this._disconnectInteraction();
    };
    return DragLineLayer;
}(guideLineLayer_1.GuideLineLayer));
exports.DragLineLayer = DragLineLayer;

},{"../components/guideLineLayer":538,"../interactions":578,"../utils":624,"tslib":635}],536:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gridlines = void 0;
var tslib_1 = require("tslib");
var component_1 = require("./component");
/**
 * Returns next grid position based on tick value
 *
 * @param scale Scale used by the grid
 * @param between Value denoting whether the grid renders between ticks or on ticks
 * @param orderedTicks All ticks in order. only needed when rendering lines between ticks
 */
function gridPositionFactory(scale, between, orderedTicks) {
    var previousTick = {};
    if (orderedTicks !== undefined) {
        for (var i = 0; i < orderedTicks.length; i++) {
            var previous = orderedTicks[i - 1];
            var current = orderedTicks[i];
            previousTick[current] = previous;
        }
    }
    return function (tickVal) {
        var position = scale.scale(tickVal);
        if (!between) {
            return position;
        }
        var gridPosition;
        var previousPosition = previousTick[tickVal] === undefined
            ? undefined
            : scale.scale(previousTick[tickVal]);
        if (previousPosition !== undefined) {
            gridPosition = previousPosition + (position - previousPosition) / 2;
        }
        return gridPosition;
    };
}
var Gridlines = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Gridlines, _super);
    /**
     * @constructor
     * @param {Scale} xScale The scale to base the x gridlines on. Pass null if no gridlines are desired.
     * @param {Scale} yScale The scale to base the y gridlines on. Pass null if no gridlines are desired.
     */
    function Gridlines(xScale, yScale) {
        var _this = _super.call(this) || this;
        _this.addClass("gridlines");
        _this._xScale = xScale;
        _this._yScale = yScale;
        _this._renderCallback = function (scale) { return _this.render(); };
        if (_this._xScale) {
            _this._xScale.onUpdate(_this._renderCallback);
        }
        if (_this._yScale) {
            _this._yScale.onUpdate(_this._renderCallback);
        }
        return _this;
    }
    Gridlines.prototype.betweenX = function (_betweenX) {
        if (_betweenX === undefined) {
            return this._betweenX;
        }
        if (_betweenX !== this._betweenX) {
            this._betweenX = _betweenX;
            this.render();
        }
        return this;
    };
    Gridlines.prototype.betweenY = function (_betweenY) {
        if (_betweenY === undefined) {
            return this._betweenY;
        }
        if (_betweenY !== this._betweenY) {
            this._betweenY = _betweenY;
            this.render();
        }
        return this;
    };
    Gridlines.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this._xScale) {
            this._xScale.offUpdate(this._renderCallback);
        }
        if (this._yScale) {
            this._yScale.offUpdate(this._renderCallback);
        }
        return this;
    };
    Gridlines.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._xLinesContainer = this.content().append("g").classed("x-gridlines", true);
        this._yLinesContainer = this.content().append("g").classed("y-gridlines", true);
    };
    Gridlines.prototype.renderImmediately = function () {
        _super.prototype.renderImmediately.call(this);
        this._redrawXLines();
        this._redrawYLines();
        return this;
    };
    Gridlines.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        if (this._xScale != null) {
            this._xScale.range([0, this.width()]);
        }
        if (this._yScale != null) {
            this._yScale.range([this.height(), 0]);
        }
        return this;
    };
    Gridlines.prototype._redrawXLines = function () {
        if (this._xScale) {
            var between = this.betweenX();
            var xTicks = this._xScale.ticks().slice(between ? 1 : 0);
            var xLinesUpdate = this._xLinesContainer.selectAll("line").data(xTicks);
            var xLines = xLinesUpdate.enter().append("line").merge(xLinesUpdate);
            xLines.attr("x1", gridPositionFactory(this._xScale, between, this._xScale.ticks()))
                .attr("y1", 0)
                .attr("x2", gridPositionFactory(this._xScale, between, this._xScale.ticks()))
                .attr("y2", this.height())
                .classed("betweenline", between)
                .classed("zeroline", function (t) { return t === 0; });
            xLinesUpdate.exit().remove();
        }
    };
    Gridlines.prototype._redrawYLines = function () {
        if (this._yScale) {
            var between = this.betweenY();
            var yTicks = this._yScale.ticks().slice(between ? 1 : 0);
            var yLinesUpdate = this._yLinesContainer.selectAll("line").data(yTicks);
            var yLines = yLinesUpdate.enter().append("line").merge(yLinesUpdate);
            yLines.attr("x1", 0)
                .attr("y1", gridPositionFactory(this._yScale, between, this._yScale.ticks()))
                .attr("x2", this.width())
                .attr("y2", gridPositionFactory(this._yScale, between, this._yScale.ticks()))
                .classed("betweenline", between)
                .classed("zeroline", function (t) { return t === 0; });
            yLinesUpdate.exit().remove();
        }
    };
    return Gridlines;
}(component_1.Component));
exports.Gridlines = Gridlines;

},{"./component":532,"tslib":635}],537:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Group = void 0;
var tslib_1 = require("tslib");
var Utils = require("../utils");
var componentContainer_1 = require("./componentContainer");
var Group = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Group, _super);
    /**
     * Constructs a Group.
     *
     * A Group contains Components that will be rendered on top of each other.
     * Components added later will be rendered above Components already in the Group.
     *
     * @constructor
     * @param {Component[]} [components=[]] Components to be added to the Group.
     */
    function Group(components) {
        if (components === void 0) { components = []; }
        var _this = _super.call(this) || this;
        _this._components = [];
        _this.addClass("component-group");
        components.forEach(function (c) { return _this.append(c); });
        return _this;
    }
    Group.prototype._forEach = function (callback) {
        this.components().forEach(callback);
    };
    /**
     * Checks whether the specified Component is in the Group.
     */
    Group.prototype.has = function (component) {
        return this._components.indexOf(component) >= 0;
    };
    Group.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        var requests = this._components.map(function (c) { return c.requestedSpace(offeredWidth, offeredHeight); });
        return {
            minWidth: Utils.Math.max(requests, function (request) { return request.minWidth; }, 0),
            minHeight: Utils.Math.max(requests, function (request) { return request.minHeight; }, 0),
        };
    };
    Group.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        var _this = this;
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        this._forEach(function (component) {
            component.computeLayout({ x: 0, y: 0 }, _this.width(), _this.height());
        });
        return this;
    };
    Group.prototype._sizeFromOffer = function (availableWidth, availableHeight) {
        return {
            width: availableWidth,
            height: availableHeight,
        };
    };
    Group.prototype.fixedWidth = function () {
        return this._components.every(function (c) { return c.fixedWidth(); });
    };
    Group.prototype.fixedHeight = function () {
        return this._components.every(function (c) { return c.fixedHeight(); });
    };
    /**
     * @return {Component[]} The Components in this Group.
     */
    Group.prototype.components = function () {
        return this._components.slice();
    };
    /**
     * Adds a Component to this Group.
     * The added Component will be rendered above Components already in the Group.
     */
    Group.prototype.append = function (component) {
        if (component != null && !this.has(component)) {
            component.detach();
            this._components.push(component);
            this._adoptAndAnchor(component);
            this.redraw();
        }
        return this;
    };
    Group.prototype._remove = function (component) {
        var removeIndex = this._components.indexOf(component);
        if (removeIndex >= 0) {
            this._components.splice(removeIndex, 1);
            return true;
        }
        return false;
    };
    return Group;
}(componentContainer_1.ComponentContainer));
exports.Group = Group;

},{"../utils":624,"./componentContainer":533,"tslib":635}],538:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuideLineLayer = void 0;
var tslib_1 = require("tslib");
var Utils = require("../utils");
var component_1 = require("./component");
var PropertyMode;
(function (PropertyMode) {
    PropertyMode[PropertyMode["VALUE"] = 0] = "VALUE";
    PropertyMode[PropertyMode["PIXEL"] = 1] = "PIXEL";
})(PropertyMode || (PropertyMode = {}));
var GuideLineLayer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(GuideLineLayer, _super);
    function GuideLineLayer(orientation) {
        var _this = _super.call(this) || this;
        _this._mode = PropertyMode.VALUE;
        if (orientation !== GuideLineLayer.ORIENTATION_VERTICAL && orientation !== GuideLineLayer.ORIENTATION_HORIZONTAL) {
            throw new Error(orientation + " is not a valid orientation for GuideLineLayer");
        }
        _this._orientation = orientation;
        _this._overflowHidden = true;
        _this.addClass("guide-line-layer");
        if (_this._isVertical()) {
            _this.addClass("vertical");
        }
        else {
            _this.addClass("horizontal");
        }
        _this._scaleUpdateCallback = function () {
            _this._syncPixelPositionAndValue();
            _this.render();
        };
        return _this;
    }
    GuideLineLayer.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._guideLine = this.content().append("line").classed("guide-line", true);
    };
    GuideLineLayer.prototype._sizeFromOffer = function (availableWidth, availableHeight) {
        return {
            width: availableWidth,
            height: availableHeight,
        };
    };
    GuideLineLayer.prototype._isVertical = function () {
        return this._orientation === GuideLineLayer.ORIENTATION_VERTICAL;
    };
    GuideLineLayer.prototype.fixedWidth = function () {
        return true;
    };
    GuideLineLayer.prototype.fixedHeight = function () {
        return true;
    };
    GuideLineLayer.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        if (this.scale() != null) {
            if (this._isVertical()) {
                this.scale().range([0, this.width()]);
            }
            else {
                this.scale().range([this.height(), 0]);
            }
        }
        return this;
    };
    GuideLineLayer.prototype.renderImmediately = function () {
        _super.prototype.renderImmediately.call(this);
        this._syncPixelPositionAndValue();
        this._guideLine.attrs({
            x1: this._isVertical() ? this.pixelPosition() : 0,
            y1: this._isVertical() ? 0 : this.pixelPosition(),
            x2: this._isVertical() ? this.pixelPosition() : this.width(),
            y2: this._isVertical() ? this.height() : this.pixelPosition(),
        });
        return this;
    };
    // sets pixelPosition() or value() based on the other, depending on which was the last one set
    GuideLineLayer.prototype._syncPixelPositionAndValue = function () {
        if (this.scale() == null) {
            return;
        }
        if (this._mode === PropertyMode.VALUE && this.value() != null) {
            this._pixelPosition = this.scale().scale(this.value());
        }
        else if (this._mode === PropertyMode.PIXEL && this.pixelPosition() != null) {
            this._value = this.scale().invert(this.pixelPosition());
        }
    };
    GuideLineLayer.prototype._setPixelPositionWithoutChangingMode = function (pixelPosition) {
        this._pixelPosition = pixelPosition;
        if (this.scale() != null) {
            this._value = this.scale().invert(this.pixelPosition());
        }
        this.render();
    };
    GuideLineLayer.prototype.scale = function (scale) {
        if (scale == null) {
            return this._scale;
        }
        var previousScale = this._scale;
        if (previousScale != null) {
            previousScale.offUpdate(this._scaleUpdateCallback);
        }
        this._scale = scale;
        this._scale.onUpdate(this._scaleUpdateCallback);
        this._syncPixelPositionAndValue();
        this.redraw();
        return this;
    };
    GuideLineLayer.prototype.value = function (value) {
        if (value == null) {
            return this._value;
        }
        this._value = value;
        this._mode = PropertyMode.VALUE;
        this._syncPixelPositionAndValue();
        this.render();
        return this;
    };
    GuideLineLayer.prototype.pixelPosition = function (pixelPosition) {
        if (pixelPosition == null) {
            return this._pixelPosition;
        }
        if (!Utils.Math.isValidNumber(pixelPosition)) {
            throw new Error("pixelPosition must be a finite number");
        }
        this._pixelPosition = pixelPosition;
        this._mode = PropertyMode.PIXEL;
        this._syncPixelPositionAndValue();
        this.render();
        return this;
    };
    GuideLineLayer.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.scale() != null) {
            this.scale().offUpdate(this._scaleUpdateCallback);
        }
    };
    GuideLineLayer.ORIENTATION_VERTICAL = "vertical";
    GuideLineLayer.ORIENTATION_HORIZONTAL = "horizontal";
    return GuideLineLayer;
}(component_1.Component));
exports.GuideLineLayer = GuideLineLayer;

},{"../utils":624,"./component":532,"tslib":635}],539:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
(0, tslib_1.__exportStar)(require("./dragBoxLayer"), exports);
(0, tslib_1.__exportStar)(require("./dragLineLayer"), exports);
(0, tslib_1.__exportStar)(require("./gridlines"), exports);
(0, tslib_1.__exportStar)(require("./group"), exports);
(0, tslib_1.__exportStar)(require("./guideLineLayer"), exports);
(0, tslib_1.__exportStar)(require("./interpolatedColorLegend"), exports);
(0, tslib_1.__exportStar)(require("./label"), exports);
(0, tslib_1.__exportStar)(require("./legend"), exports);
(0, tslib_1.__exportStar)(require("./plotGroup"), exports);
(0, tslib_1.__exportStar)(require("./selectionBoxLayer"), exports);
(0, tslib_1.__exportStar)(require("./table"), exports);
(0, tslib_1.__exportStar)(require("./wrappedLabel"), exports);
(0, tslib_1.__exportStar)(require("./xDragBoxLayer"), exports);
(0, tslib_1.__exportStar)(require("./yDragBoxLayer"), exports);

},{"./dragBoxLayer":534,"./dragLineLayer":535,"./gridlines":536,"./group":537,"./guideLineLayer":538,"./interpolatedColorLegend":540,"./label":541,"./legend":542,"./plotGroup":543,"./selectionBoxLayer":544,"./table":545,"./wrappedLabel":546,"./xDragBoxLayer":547,"./yDragBoxLayer":548,"tslib":635}],540:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterpolatedColorLegend = void 0;
var tslib_1 = require("tslib");
var Typesettable = require("typesettable");
var Configs = require("../core/config");
var Formatters = require("../core/formatters");
var Utils = require("../utils");
var component_1 = require("./component");
var InterpolatedColorLegend = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(InterpolatedColorLegend, _super);
    /**
     * Creates an InterpolatedColorLegend.
     *
     * The InterpolatedColorLegend consists of a sequence of swatches that show the
     * associated InterpolatedColor Scale sampled at various points.
     * Two labels show the maximum and minimum values of the InterpolatedColor Scale.
     *
     * @constructor
     * @param {Scales.InterpolatedColor} interpolatedColorScale
     */
    function InterpolatedColorLegend(interpolatedColorScale) {
        var _this = _super.call(this) || this;
        _this._textPadding = 5;
        if (interpolatedColorScale == null) {
            throw new Error("InterpolatedColorLegend requires a interpolatedColorScale");
        }
        _this._scale = interpolatedColorScale;
        _this._redrawCallback = function (scale) { return _this.redraw(); };
        _this._scale.onUpdate(_this._redrawCallback);
        _this._formatter = Formatters.general();
        _this._orientation = "horizontal";
        _this._expands = false;
        _this.addClass("legend");
        _this.addClass("interpolated-color-legend");
        return _this;
    }
    InterpolatedColorLegend.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this._scale.offUpdate(this._redrawCallback);
    };
    InterpolatedColorLegend.prototype.formatter = function (formatter) {
        if (formatter === undefined) {
            return this._formatter;
        }
        this._formatter = formatter;
        this.redraw();
        return this;
    };
    InterpolatedColorLegend.prototype.expands = function (expands) {
        if (expands == null) {
            return this._expands;
        }
        this._expands = expands;
        this.redraw();
        return this;
    };
    InterpolatedColorLegend._ensureOrientation = function (orientation) {
        orientation = orientation.toLowerCase();
        if (orientation === "horizontal" || orientation === "left" || orientation === "right") {
            return orientation;
        }
        else {
            throw new Error("\"" + orientation + "\" is not a valid orientation for InterpolatedColorLegend");
        }
    };
    InterpolatedColorLegend.prototype.orientation = function (orientation) {
        if (orientation == null) {
            return this._orientation;
        }
        else {
            this._orientation = InterpolatedColorLegend._ensureOrientation(orientation);
            this.redraw();
            return this;
        }
    };
    InterpolatedColorLegend.prototype.fixedWidth = function () {
        return !this.expands() || this._isVertical();
    };
    InterpolatedColorLegend.prototype.fixedHeight = function () {
        return !this.expands() || !this._isVertical();
    };
    InterpolatedColorLegend.prototype._generateTicks = function (numSwatches) {
        if (numSwatches === void 0) { numSwatches = InterpolatedColorLegend._DEFAULT_NUM_SWATCHES; }
        var domain = this._scale.domain();
        if (numSwatches === 1) {
            return [domain[0]];
        }
        var slope = (domain[1] - domain[0]) / (numSwatches - 1);
        var ticks = [];
        for (var i = 0; i < numSwatches; i++) {
            ticks.push(domain[0] + slope * i);
        }
        return ticks;
    };
    InterpolatedColorLegend.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._swatchContainer = this.content().append("g").classed("swatch-container", true);
        this._swatchBoundingBox = this.content().append("rect").classed("swatch-bounding-box", true);
        this._lowerLabel = this.content().append("g").classed(InterpolatedColorLegend.LEGEND_LABEL_CLASS, true);
        this._upperLabel = this.content().append("g").classed(InterpolatedColorLegend.LEGEND_LABEL_CLASS, true);
        var context = new Typesettable.SvgContext(this.content().node());
        this._measurer = new Typesettable.Measurer(context);
        this._wrapper = new Typesettable.Wrapper();
        this._writer = new Typesettable.Writer(this._measurer, context, this._wrapper);
    };
    InterpolatedColorLegend.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        var _this = this;
        var textHeight = this._measurer.measure().height;
        var padding = textHeight;
        var domain = this._scale.domain();
        var labelWidths = domain.map(function (d) { return _this._measurer.measure(_this._formatter(d)).width; });
        var desiredHeight;
        var desiredWidth;
        var numSwatches = InterpolatedColorLegend._DEFAULT_NUM_SWATCHES;
        if (this._isVertical()) {
            var longestWidth = Utils.Math.max(labelWidths, 0);
            desiredWidth = padding + textHeight + this._textPadding + longestWidth + this._textPadding;
            desiredHeight = numSwatches * textHeight;
        }
        else {
            desiredHeight = padding + textHeight + padding;
            desiredWidth = this._textPadding + labelWidths[0] + numSwatches * textHeight
                + labelWidths[1] + this._textPadding;
        }
        return {
            minWidth: desiredWidth,
            minHeight: desiredHeight,
        };
    };
    InterpolatedColorLegend.prototype._isVertical = function () {
        return this._orientation !== "horizontal";
    };
    InterpolatedColorLegend.prototype.renderImmediately = function () {
        var _this = this;
        _super.prototype.renderImmediately.call(this);
        var domain = this._scale.domain();
        var text0 = this._formatter(domain[0]);
        var text0Width = this._measurer.measure(text0).width;
        var text1 = this._formatter(domain[1]);
        var text1Width = this._measurer.measure(text1).width;
        var textHeight = this._measurer.measure().height;
        var textPadding = this._textPadding;
        var upperLabelShift = { x: 0, y: 0 };
        var lowerLabelShift = { x: 0, y: 0 };
        var lowerWriteOptions = {
            xAlign: "center",
            yAlign: "center",
            textRotation: 0,
        };
        var upperWriteOptions = {
            xAlign: "center",
            yAlign: "center",
            textRotation: 0,
        };
        var swatchWidth;
        var swatchHeight;
        var swatchX;
        var swatchY;
        var boundingBoxAttr = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
        };
        var padding;
        var numSwatches;
        if (this._isVertical()) {
            numSwatches = Math.floor(this.height());
            var longestTextWidth_1 = Math.max(text0Width, text1Width);
            padding = (this.width() - longestTextWidth_1 - 2 * this._textPadding) / 2;
            swatchWidth = Math.max(this.width() - padding - 2 * textPadding - longestTextWidth_1, 0);
            swatchHeight = 1;
            swatchY = function (d, i) { return _this.height() - (i + 1); };
            upperWriteOptions.yAlign = "top";
            upperLabelShift.y = 0;
            lowerWriteOptions.yAlign = "bottom";
            lowerLabelShift.y = 0;
            if (this._orientation === "left") {
                swatchX = function (d, i) { return textPadding + longestTextWidth_1 + textPadding; };
                upperWriteOptions.xAlign = "right";
                upperLabelShift.x = -(padding + swatchWidth + textPadding);
                lowerWriteOptions.xAlign = "right";
                lowerLabelShift.x = -(padding + swatchWidth + textPadding);
            }
            else { // right
                swatchX = function (d, i) { return padding; };
                upperWriteOptions.xAlign = "left";
                upperLabelShift.x = padding + swatchWidth + textPadding;
                lowerWriteOptions.xAlign = "left";
                lowerLabelShift.x = padding + swatchWidth + textPadding;
            }
            boundingBoxAttr["width"] = swatchWidth;
            boundingBoxAttr["height"] = numSwatches * swatchHeight;
        }
        else { // horizontal
            padding = Math.max(textPadding, (this.height() - textHeight) / 2);
            numSwatches = Math.max(Math.floor(this.width() - textPadding * 4 - text0Width - text1Width), 0);
            swatchWidth = 1;
            swatchHeight = Math.max((this.height() - 2 * padding), 0);
            swatchX = function (d, i) { return Math.floor(text0Width + 2 * textPadding) + i; };
            swatchY = function (d, i) { return padding; };
            upperWriteOptions.xAlign = "right";
            upperLabelShift.x = -textPadding;
            lowerWriteOptions.xAlign = "left";
            lowerLabelShift.x = textPadding;
            boundingBoxAttr["y"] = padding;
            boundingBoxAttr["width"] = numSwatches * swatchWidth;
            boundingBoxAttr["height"] = swatchHeight;
        }
        boundingBoxAttr["x"] = swatchX(null, 0); // position of the first swatch
        this._upperLabel.text(""); // clear the upper label
        this._writer.write(text1, this.width(), this.height(), upperWriteOptions, this._upperLabel.node());
        var upperTranslateString = "translate(" + upperLabelShift.x + ", " + upperLabelShift.y + ")";
        this._upperLabel.attr("transform", upperTranslateString);
        this._lowerLabel.text(""); // clear the lower label
        this._writer.write(text0, this.width(), this.height(), lowerWriteOptions, this._lowerLabel.node());
        var lowerTranslateString = "translate(" + lowerLabelShift.x + ", " + lowerLabelShift.y + ")";
        this._lowerLabel.attr("transform", lowerTranslateString);
        this._swatchBoundingBox.attrs(boundingBoxAttr);
        var ticks = this._generateTicks(numSwatches);
        var swatchesUpdate = this._swatchContainer.selectAll("rect.swatch").data(ticks);
        var rects = swatchesUpdate.enter().append("rect").classed("swatch", true);
        var swatches = swatchesUpdate.merge(rects);
        swatchesUpdate.exit().remove();
        swatches.attrs({
            fill: function (d, i) { return _this._scale.scale(d); },
            width: swatchWidth,
            height: swatchHeight,
            x: swatchX,
            y: swatchY,
            "shape-rendering": "crispEdges",
        });
        if (Configs.ADD_TITLE_ELEMENTS) {
            rects.append("title").text(function (d) { return _this._formatter(d); });
        }
        return this;
    };
    InterpolatedColorLegend._DEFAULT_NUM_SWATCHES = 11;
    /**
     * The css class applied to the legend labels.
     */
    InterpolatedColorLegend.LEGEND_LABEL_CLASS = "legend-label";
    return InterpolatedColorLegend;
}(component_1.Component));
exports.InterpolatedColorLegend = InterpolatedColorLegend;

},{"../core/config":549,"../core/formatters":551,"../utils":624,"./component":532,"tslib":635,"typesettable":640}],541:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxisLabel = exports.TitleLabel = exports.Label = void 0;
var tslib_1 = require("tslib");
var Typesettable = require("typesettable");
var component_1 = require("./component");
var Label = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Label, _super);
    /**
     * A Label is a Component that displays a single line of text.
     *
     * @constructor
     * @param {string} [displayText=""] The text of the Label.
     * @param {number} [angle=0] The angle of the Label in degrees (-90/0/90). 0 is horizontal.
     */
    function Label(displayText, angle) {
        if (displayText === void 0) { displayText = ""; }
        if (angle === void 0) { angle = 0; }
        var _this = _super.call(this) || this;
        _this.addClass("label");
        _this.text(displayText);
        _this.angle(angle);
        _this.xAlignment("center").yAlignment("center");
        _this._padding = 0;
        return _this;
    }
    Label.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        var desiredWH = this._measurer.measure(this._text);
        var desiredWidth = (this.angle() === 0 ? desiredWH.width : desiredWH.height) + 2 * this.padding();
        var desiredHeight = (this.angle() === 0 ? desiredWH.height : desiredWH.width) + 2 * this.padding();
        return {
            minWidth: desiredWidth,
            minHeight: desiredHeight,
        };
    };
    Label.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._textContainer = this.content().append("g");
        var context = new Typesettable.SvgContext(this._textContainer.node());
        this._measurer = new Typesettable.CacheMeasurer(context);
        this._wrapper = new Typesettable.Wrapper();
        this._writer = new Typesettable.Writer(this._measurer, context, this._wrapper);
        this.text(this._text);
    };
    Label.prototype.text = function (displayText) {
        if (displayText == null) {
            return this._text;
        }
        else {
            if (typeof displayText !== "string") {
                throw new Error("Label.text() only takes strings as input");
            }
            this._text = displayText;
            this.redraw();
            return this;
        }
    };
    Label.prototype.angle = function (angle) {
        if (angle == null) {
            return this._angle;
        }
        else {
            angle %= 360;
            if (angle > 180) {
                angle -= 360;
            }
            else if (angle < -180) {
                angle += 360;
            }
            if (angle === -90 || angle === 0 || angle === 90) {
                this._angle = angle;
            }
            else {
                throw new Error(angle + " is not a valid angle for Label");
            }
            this.redraw();
            return this;
        }
    };
    Label.prototype.padding = function (padAmount) {
        if (padAmount == null) {
            return this._padding;
        }
        else {
            padAmount = +padAmount;
            if (padAmount < 0) {
                throw new Error(padAmount + " is not a valid padding value. Cannot be less than 0.");
            }
            this._padding = padAmount;
            this.redraw();
            return this;
        }
    };
    Label.prototype.fixedWidth = function () {
        return true;
    };
    Label.prototype.fixedHeight = function () {
        return true;
    };
    Label.prototype.renderImmediately = function () {
        _super.prototype.renderImmediately.call(this);
        // HACKHACK Typesettable.remove existing content - #21 on Typesettable.
        this._textContainer.selectAll("g").remove();
        var textMeasurement = this._measurer.measure(this._text);
        var heightPadding = Math.max(Math.min((this.height() - textMeasurement.height) / 2, this.padding()), 0);
        var widthPadding = Math.max(Math.min((this.width() - textMeasurement.width) / 2, this.padding()), 0);
        this._textContainer.attr("transform", "translate(" + widthPadding + "," + heightPadding + ")");
        var writeWidth = this.width() - 2 * widthPadding;
        var writeHeight = this.height() - 2 * heightPadding;
        var writeOptions = {
            xAlign: this.xAlignment(),
            yAlign: this.yAlignment(),
            textRotation: this.angle(),
        };
        this._writer.write(this._text, writeWidth, writeHeight, writeOptions);
        return this;
    };
    Label.prototype.invalidateCache = function () {
        _super.prototype.invalidateCache.call(this);
        this._measurer.reset();
    };
    Label._MIN_FONT_SIZE_PX = 12;
    Label._MAX_FONT_SIZE_PX = 24;
    Label._DEFAULT_FONT_SIZE_PX = 12;
    return Label;
}(component_1.Component));
exports.Label = Label;
var TitleLabel = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(TitleLabel, _super);
    /**
     * @constructor
     * @param {string} [text]
     * @param {number} [angle] One of -90/0/90. 0 is horizontal.
     */
    function TitleLabel(text, angle) {
        var _this = _super.call(this, text, angle) || this;
        _this.addClass(TitleLabel.TITLE_LABEL_CLASS);
        return _this;
    }
    TitleLabel.TITLE_LABEL_CLASS = "title-label";
    return TitleLabel;
}(Label));
exports.TitleLabel = TitleLabel;
var AxisLabel = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(AxisLabel, _super);
    /**
     * @constructor
     * @param {string} [text]
     * @param {number} [angle] One of -90/0/90. 0 is horizontal.
     */
    function AxisLabel(text, angle) {
        var _this = _super.call(this, text, angle) || this;
        _this.addClass(AxisLabel.AXIS_LABEL_CLASS);
        return _this;
    }
    AxisLabel.AXIS_LABEL_CLASS = "axis-label";
    return AxisLabel;
}(Label));
exports.AxisLabel = AxisLabel;

},{"./component":532,"tslib":635,"typesettable":640}],542:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Legend = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Typesettable = require("typesettable");
var Configs = require("../core/config");
var Formatters = require("../core/formatters");
var SymbolFactories = require("../core/symbolFactories");
var Utils = require("../utils");
var component_1 = require("./component");
/**
 * The Legend's row representations. Stores positioning information
 * and column data.
 */
var LegendRow = /** @class */ (function () {
    function LegendRow(
    /**
     * Columns within the row
     * @param {LegendColumn<any>[]} columns
     */
    columns, 
    /**
     * Padding applied below the row. Affects the spacing between rows. Defaults to 0.
     * @param {bottomPadding} number
     */
    bottomPadding, 
    /**
     * Sets the maximum allowable width of this column.
     * @param {number} maxWidth
     */
    maxWidth) {
        if (columns === void 0) { columns = []; }
        if (bottomPadding === void 0) { bottomPadding = 0; }
        if (maxWidth === void 0) { maxWidth = Infinity; }
        this.columns = columns;
        this.bottomPadding = bottomPadding;
        this.maxWidth = maxWidth;
    }
    /**
     * Adds a column to the list of columns within the row. May readjust the size of the
     * column to fit within the row
     *
     * @param {LegendColumn<any>} column
     */
    LegendRow.prototype.addColumn = function (column) {
        var desiredColumnWidth = column.width;
        // choose the smaller of 1) remaining space, 2) desired width
        var widthRemaining = this.getWidthAvailable();
        column.width = Math.min(widthRemaining, desiredColumnWidth);
        this.columns.push(column);
    };
    /**
     * Returns the bounds the column, relative to the row.
     * @param {number} columnIndex The index of the column in question
     * @returns {Bounds} bounds
     */
    LegendRow.prototype.getBounds = function (columnIndex) {
        var column = this.columns[columnIndex];
        var columnXOffset = 0;
        for (var i = 0; i < columnIndex; i++) {
            columnXOffset += this.columns[i].width;
        }
        return {
            topLeft: { x: columnXOffset, y: 0 },
            bottomRight: {
                x: columnXOffset + column.width,
                y: column.height,
            },
        };
    };
    /**
     * Returns the height of the row, including the bottomPadding.
     * @return {number} height
     */
    LegendRow.prototype.getHeight = function () {
        return Utils.Math.max(this.columns.map(function (_a) {
            var height = _a.height;
            return height;
        }), 0) + this.bottomPadding;
    };
    /**
     * Returns the current width of the row constrained by maxWidth, if set.
     * @returns {number} width
     */
    LegendRow.prototype.getWidth = function () {
        return Math.min(this.columns.reduce(function (sum, _a) {
            var width = _a.width;
            return sum + width;
        }, 0), this.maxWidth);
    };
    /**
     * Returns the remaining width available in the row based on the maximum
     * width of this row.
     * @returns {number} widthRemaining
     */
    LegendRow.prototype.getWidthAvailable = function () {
        var widthConsumed = this.getWidth();
        return Math.max(this.maxWidth - widthConsumed, 0);
    };
    return LegendRow;
}());
/**
 * Stores LegendRows. Useful for calculating and maintaining
 * positioning information about the Legend.
 */
var LegendTable = /** @class */ (function () {
    function LegendTable(maxWidth, maxHeight, padding, rows) {
        if (maxWidth === void 0) { maxWidth = Infinity; }
        if (maxHeight === void 0) { maxHeight = Infinity; }
        if (padding === void 0) { padding = 0; }
        if (rows === void 0) { rows = []; }
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this.padding = padding;
        this.rows = rows;
    }
    LegendTable.prototype.addRow = function (row) {
        row.maxWidth = this.maxWidth - this.padding * 2;
        this.rows.push(row);
    };
    /**
     * Returns the bounds of the column relative to the parent and siblings of the
     * column.
     *
     * @param {number} rowIndex The parent row containing the desired column.
     * @param {number} columnIndex The column to calculate bounds.
     * @returns {Bounds}
     */
    LegendTable.prototype.getColumnBounds = function (rowIndex, columnIndex) {
        var rowBounds = this.getRowBounds(rowIndex);
        var columnBounds = this.rows[rowIndex].getBounds(columnIndex);
        columnBounds.topLeft.x += rowBounds.topLeft.x;
        columnBounds.bottomRight.x += rowBounds.topLeft.x;
        columnBounds.topLeft.y += rowBounds.topLeft.y;
        columnBounds.bottomRight.y += rowBounds.topLeft.y;
        return columnBounds;
    };
    /**
     * Returns the bounds relative to the parent and siblings of the row.
     *
     * @param {number} rowIndex The row to calculate bounds
     * @returns {Bounds}
     */
    LegendTable.prototype.getRowBounds = function (rowIndex) {
        var rowXOffset = this.padding;
        var rowYOffset = this.padding;
        for (var i = 0; i < rowIndex; i++) {
            rowYOffset += this.rows[i].getHeight();
        }
        var rowBounds = {
            topLeft: { x: rowXOffset, y: rowYOffset },
            bottomRight: {
                x: rowXOffset + this.rows[rowIndex].getWidth(),
                y: rowYOffset + this.rows[rowIndex].getHeight(),
            },
        };
        return rowBounds;
    };
    /**
     * Returns the height of the Table, constrained by a maximum height, if set.
     * The height includes the padding, if set.
     * @returns {number} height
     */
    LegendTable.prototype.getHeight = function () {
        return Math.min(this.rows.reduce(function (sum, row) { return sum + row.getHeight(); }, 0) + this.padding * 2, this.maxHeight);
    };
    /**
     * Returns the width of the table, constrained by the maximum width, if set.
     * The width includes the padding, if set.
     * @returns {number} width
     */
    LegendTable.prototype.getWidth = function () {
        return Math.min(Utils.Math.max(this.rows.map(function (row) { return row.getWidth(); }), 0) + this.padding * 2, this.maxWidth);
    };
    return LegendTable;
}());
var Legend = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Legend, _super);
    /**
     * The Legend consists of a series of entries, each with a color and label taken from the Color Scale.
     *
     * @constructor
     * @param {Scale.Color} scale
     */
    function Legend(colorScale) {
        var _this = _super.call(this) || this;
        _this._padding = 5;
        _this._rowBottomPadding = 3;
        _this.addClass("legend");
        _this.maxEntriesPerRow(1);
        if (colorScale == null) {
            throw new Error("Legend requires a colorScale");
        }
        _this._colorScale = colorScale;
        _this._redrawCallback = function (scale) { return _this.redraw(); };
        _this._colorScale.onUpdate(_this._redrawCallback);
        _this._formatter = Formatters.identity();
        _this.maxLinesPerEntry(1);
        _this.xAlignment("right").yAlignment("top");
        _this.comparator(function (a, b) {
            var formattedText = _this._colorScale.domain().slice().map(function (d) { return _this._formatter(d); });
            return formattedText.indexOf(a) - formattedText.indexOf(b);
        });
        _this._symbolFactoryAccessor = function () { return SymbolFactories.circle(); };
        _this._symbolOpacityAccessor = function () { return 1; };
        return _this;
    }
    Legend.prototype._setup = function () {
        _super.prototype._setup.call(this);
        var fakeLegendRow = this.content().append("g").classed(Legend.LEGEND_ROW_CLASS, true);
        var fakeLegendEntry = fakeLegendRow.append("g").classed(Legend.LEGEND_ENTRY_CLASS, true);
        fakeLegendEntry.append("text");
        var context = new Typesettable.SvgContext(fakeLegendRow.node(), null, Configs.ADD_TITLE_ELEMENTS);
        this._measurer = new Typesettable.CacheMeasurer(context);
        this._wrapper = new Typesettable.Wrapper().maxLines(this.maxLinesPerEntry());
        this._writer = new Typesettable.Writer(this._measurer, context, this._wrapper);
    };
    Legend.prototype.formatter = function (formatter) {
        if (formatter == null) {
            return this._formatter;
        }
        this._formatter = formatter;
        this.redraw();
        return this;
    };
    Legend.prototype.maxEntriesPerRow = function (maxEntriesPerRow) {
        if (maxEntriesPerRow == null) {
            return this._maxEntriesPerRow;
        }
        else {
            this._maxEntriesPerRow = maxEntriesPerRow;
            this.redraw();
            return this;
        }
    };
    Legend.prototype.maxLinesPerEntry = function (maxLinesPerEntry) {
        if (maxLinesPerEntry == null) {
            return this._maxLinesPerEntry;
        }
        else {
            this._maxLinesPerEntry = maxLinesPerEntry;
            this.redraw();
            return this;
        }
    };
    Legend.prototype.maxWidth = function (maxWidth) {
        if (maxWidth == null) {
            return this._maxWidth;
        }
        else {
            this._maxWidth = maxWidth;
            this.redraw();
            return this;
        }
    };
    Legend.prototype.comparator = function (comparator) {
        if (comparator == null) {
            return this._comparator;
        }
        else {
            this._comparator = comparator;
            this.redraw();
            return this;
        }
    };
    Legend.prototype.colorScale = function (colorScale) {
        if (colorScale != null) {
            this._colorScale.offUpdate(this._redrawCallback);
            this._colorScale = colorScale;
            this._colorScale.onUpdate(this._redrawCallback);
            this.redraw();
            return this;
        }
        else {
            return this._colorScale;
        }
    };
    Legend.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this._colorScale.offUpdate(this._redrawCallback);
    };
    Legend.prototype._buildLegendTable = function (width, height) {
        var _this = this;
        var textHeight = this._measurer.measure().height;
        var table = new LegendTable(width, height, this._padding);
        var entryNames = this._colorScale.domain().slice().sort(function (a, b) { return _this._comparator(_this._formatter(a), _this._formatter(b)); });
        var row = new LegendRow();
        table.addRow(row);
        row.bottomPadding = this._rowBottomPadding;
        entryNames.forEach(function (name, index) {
            if (row.columns.length / 2 === _this.maxEntriesPerRow()) {
                // we add two columns per entry, a symbol column and a name column
                // if the current row is full, according to the number of entries
                // we're allowed to have per row, we need to allocate new space
                row = new LegendRow();
                row.bottomPadding = _this._rowBottomPadding;
                table.addRow(row);
            }
            var availableWidth = row.getWidthAvailable();
            var formattedName = _this._formatter(name);
            // this is the width of the series name without any line wrapping
            // it is the most optimal presentation of the name
            var unwrappedNameWidth = _this._measurer.measure(formattedName).width;
            var willBeSquished = (availableWidth - textHeight - unwrappedNameWidth) < 0;
            if (willBeSquished && row.columns.length > 1) {
                // adding the entry to this row will squish this
                // entry. The row already contains entries so create
                // a new row to add this entry to for optimal display
                row = new LegendRow();
                row.bottomPadding = _this._rowBottomPadding;
                table.addRow(row);
            }
            var symbolColumn = { width: textHeight, height: textHeight, data: { name: name, type: "symbol" } };
            row.addColumn(symbolColumn);
            // the space consumed by the name field is the minimum of the space available in the table
            // and the actual width consumed by the name
            availableWidth = row.getWidthAvailable();
            var usedNameWidth = Math.min(availableWidth, unwrappedNameWidth);
            _this._wrapper.maxLines(_this.maxLinesPerEntry());
            var numberOfRows = _this._wrapper.wrap(formattedName, _this._measurer, usedNameWidth).noLines;
            var nameColumnHeight = numberOfRows * textHeight;
            var nameColumn = { width: usedNameWidth, height: nameColumnHeight, data: { name: name, type: "text" } };
            row.addColumn(nameColumn);
        });
        return table;
    };
    Legend.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        // if max width is set, the table is guaranteed to be at most maxWidth wide.
        // if max width is not set, the table will be as wide as the longest untruncated row
        var table = this._buildLegendTable(Utils.Math.min([this.maxWidth(), offeredWidth], offeredWidth), offeredHeight);
        return {
            minHeight: table.getHeight(),
            minWidth: table.getWidth(),
        };
    };
    /**
     * Gets the Entities (representing Legend entries) at a particular point.
     * Returns an empty array if no Entities are present at that location.
     *
     * @param {Point} p
     * @returns {Entity<Legend>[]}
     */
    Legend.prototype.entitiesAt = function (p) {
        var _this = this;
        if (!this._isSetup) {
            return [];
        }
        var table = this._buildLegendTable(this.width(), this.height());
        return table.rows.reduce(function (entity, row, rowIndex) {
            if (entity.length !== 0) {
                // we've already found the nearest entity; just return it.
                return entity;
            }
            var rowBounds = table.getRowBounds(rowIndex);
            var withinRow = Utils.Math.within(p, rowBounds);
            if (!withinRow) {
                // the nearest entity isn't within this row, continue;
                return entity;
            }
            return row.columns.reduce(function (entity, column, columnIndex) {
                var columnBounds = table.getColumnBounds(rowIndex, columnIndex);
                var withinColumn = Utils.Math.within(p, columnBounds);
                if (withinColumn) {
                    var rowElement = _this.content().selectAll("." + Legend.LEGEND_ROW_CLASS).nodes()[rowIndex];
                    // HACKHACK The 2.x API chooses the symbol element as the "selection" to return, regardless of what
                    // was actually selected
                    var entryElement = d3.select(rowElement)
                        .selectAll("." + Legend.LEGEND_ENTRY_CLASS).nodes()[Math.floor(columnIndex / 2)];
                    var symbolElement = d3.select(entryElement).select("." + Legend.LEGEND_SYMBOL_CLASS);
                    // HACKHACK The 2.x API returns the center {x, y} of the symbol as the position.
                    var rowTranslate = Utils.DOM.getTranslateValues(d3.select(rowElement));
                    var symbolTranslate = Utils.DOM.getTranslateValues(symbolElement);
                    return [{
                            bounds: Utils.DOM.elementBBox(d3.select(rowElement)),
                            datum: column.data.name,
                            position: {
                                x: rowTranslate[0] + symbolTranslate[0],
                                y: rowTranslate[1] + symbolTranslate[1],
                            },
                            selection: d3.select(entryElement),
                            component: _this,
                        }];
                }
                return entity;
            }, entity);
        }, []);
    };
    Legend.prototype.renderImmediately = function () {
        _super.prototype.renderImmediately.call(this);
        var table = this._buildLegendTable(this.width(), this.height());
        // clear content from previous renders
        this.content().selectAll("*").remove();
        var rowsUpdate = this.content().selectAll("g." + Legend.LEGEND_ROW_CLASS).data(table.rows);
        var rows = rowsUpdate
            .enter()
            .append("g")
            .classed(Legend.LEGEND_ROW_CLASS, true)
            .merge(rowsUpdate);
        rowsUpdate.exit().remove();
        rows.attr("transform", function (row, rowIndex) {
            var rowBounds = table.getRowBounds(rowIndex);
            return "translate(" + rowBounds.topLeft.x + ", " + rowBounds.topLeft.y + ")";
        });
        var self = this;
        rows.each(function (row, rowIndex) {
            var symbolEntryPairs = [];
            for (var i = 0; i < row.columns.length; i += 2) {
                symbolEntryPairs.push([row.columns[i], row.columns[i + 1]]);
            }
            var entriesUpdate = d3.select(this).selectAll("g." + Legend.LEGEND_ENTRY_CLASS).data(symbolEntryPairs);
            var entriesEnter = entriesUpdate
                .enter()
                .append("g")
                .classed(Legend.LEGEND_ENTRY_CLASS, true)
                .merge(entriesUpdate);
            entriesEnter.append("path")
                .attr("d", function (symbolEntryPair, columnIndex) {
                var symbol = symbolEntryPair[0];
                return self.symbol()(symbol.data.name, rowIndex)(symbol.height * 0.6)(null);
            })
                .attr("transform", function (symbolEntryPair, i) {
                var symbol = symbolEntryPair[0];
                var columnIndex = table.rows[rowIndex].columns.indexOf(symbol);
                var columnBounds = table.getColumnBounds(rowIndex, columnIndex);
                return "translate(" + (columnBounds.topLeft.x + symbol.width / 2) + ", " + symbol.height / 2 + ")";
            })
                .attr("fill", function (symbolEntryPair) { return self._colorScale.scale(symbolEntryPair[0].data.name); })
                .attr("opacity", function (symbolEntryPair, _columnIndex) {
                return self.symbolOpacity()(symbolEntryPair[0].data.name, rowIndex);
            })
                .classed(Legend.LEGEND_SYMBOL_CLASS, true);
            entriesEnter.append("g").classed("text-container", true)
                .attr("transform", function (symbolEntryPair, i) {
                var entry = symbolEntryPair[1];
                var columnIndex = table.rows[rowIndex].columns.indexOf(entry);
                var columnBounds = table.getColumnBounds(rowIndex, columnIndex);
                return "translate(" + columnBounds.topLeft.x + ", 0)";
            })
                .each(function (symbolEntryPair, i, rowIndex) {
                var textContainer = d3.select(this);
                var column = symbolEntryPair[1];
                var writeOptions = {
                    xAlign: "left",
                    yAlign: "top",
                    textRotation: 0,
                };
                self._writer.write(self._formatter(column.data.name), column.width, self.height(), writeOptions, textContainer.node());
            });
            entriesUpdate.exit().remove();
        });
        return this;
    };
    Legend.prototype.symbol = function (symbol) {
        if (symbol == null) {
            return this._symbolFactoryAccessor;
        }
        else {
            this._symbolFactoryAccessor = symbol;
            this.render();
            return this;
        }
    };
    Legend.prototype.symbolOpacity = function (symbolOpacity) {
        if (symbolOpacity == null) {
            return this._symbolOpacityAccessor;
        }
        else if (typeof symbolOpacity === "number") {
            this._symbolOpacityAccessor = function () { return symbolOpacity; };
        }
        else {
            this._symbolOpacityAccessor = symbolOpacity;
        }
        this.render();
        return this;
    };
    Legend.prototype.fixedWidth = function () {
        return true;
    };
    Legend.prototype.fixedHeight = function () {
        return true;
    };
    Legend.prototype.invalidateCache = function () {
        _super.prototype.invalidateCache.call(this);
        this._measurer.reset();
    };
    /**
     * The css class applied to each legend row
     */
    Legend.LEGEND_ROW_CLASS = "legend-row";
    /**
     * The css class applied to each legend entry
     */
    Legend.LEGEND_ENTRY_CLASS = "legend-entry";
    /**
     * The css class applied to each legend symbol
     */
    Legend.LEGEND_SYMBOL_CLASS = "legend-symbol";
    return Legend;
}(component_1.Component));
exports.Legend = Legend;

},{"../core/config":549,"../core/formatters":551,"../core/symbolFactories":555,"../utils":624,"./component":532,"d3":414,"tslib":635,"typesettable":640}],543:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlotGroup = void 0;
var tslib_1 = require("tslib");
var plot_1 = require("../plots/plot");
var Utils = require("../utils");
var group_1 = require("./group");
var PlotGroup = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(PlotGroup, _super);
    function PlotGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PlotGroup.prototype.entityNearest = function (point) {
        var closestPlotEntity;
        var minDistSquared = Infinity;
        this.components().forEach(function (plotComponent) {
            // we know it's a Plot since .append() throws a runtime error otherwise
            var plot = plotComponent;
            var candidatePlotEntity = plot.entityNearest(point);
            if (candidatePlotEntity == null) {
                return;
            }
            var distSquared = Utils.Math.distanceSquared(candidatePlotEntity.position, point);
            if (distSquared <= minDistSquared) {
                minDistSquared = distSquared;
                closestPlotEntity = candidatePlotEntity;
            }
        });
        return closestPlotEntity;
    };
    /**
     * Adds a Plot to this Plot Group.
     * The added Plot will be rendered above Plots already in the Group.
     */
    PlotGroup.prototype.append = function (plot) {
        if (plot != null && !(plot instanceof plot_1.Plot)) {
            throw new Error("Plot Group only accepts plots");
        }
        _super.prototype.append.call(this, plot);
        return this;
    };
    return PlotGroup;
}(group_1.Group));
exports.PlotGroup = PlotGroup;

},{"../plots/plot":597,"../utils":624,"./group":537,"tslib":635}],544:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectionBoxLayer = exports.PropertyMode = void 0;
var tslib_1 = require("tslib");
var Utils = require("../utils");
var component_1 = require("./component");
var PropertyMode;
(function (PropertyMode) {
    PropertyMode[PropertyMode["VALUE"] = 0] = "VALUE";
    PropertyMode[PropertyMode["PIXEL"] = 1] = "PIXEL";
})(PropertyMode = exports.PropertyMode || (exports.PropertyMode = {}));
var SelectionBoxLayer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(SelectionBoxLayer, _super);
    function SelectionBoxLayer() {
        var _this = _super.call(this) || this;
        _this._boxVisible = false;
        _this._boxBounds = {
            topLeft: { x: 0, y: 0 },
            bottomRight: { x: 0, y: 0 },
        };
        _this._xBoundsMode = PropertyMode.PIXEL;
        _this._yBoundsMode = PropertyMode.PIXEL;
        _this.addClass("selection-box-layer");
        _this._adjustBoundsCallback = function () {
            _this.render();
        };
        _this._overflowHidden = true;
        _this._xExtent = [undefined, undefined];
        _this._yExtent = [undefined, undefined];
        return _this;
    }
    SelectionBoxLayer.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._box = this.content().append("g").classed("selection-box", true).remove();
        this._boxArea = this._box.append("rect").classed("selection-area", true);
    };
    SelectionBoxLayer.prototype._sizeFromOffer = function (availableWidth, availableHeight) {
        return {
            width: availableWidth,
            height: availableHeight,
        };
    };
    SelectionBoxLayer.prototype.bounds = function (newBounds) {
        if (newBounds == null) {
            return this._getBounds();
        }
        this._setBounds(newBounds);
        this._xBoundsMode = PropertyMode.PIXEL;
        this._yBoundsMode = PropertyMode.PIXEL;
        this.render();
        return this;
    };
    SelectionBoxLayer.prototype._setBounds = function (newBounds) {
        var topLeft = {
            x: Math.min(newBounds.topLeft.x, newBounds.bottomRight.x),
            y: Math.min(newBounds.topLeft.y, newBounds.bottomRight.y),
        };
        var bottomRight = {
            x: Math.max(newBounds.topLeft.x, newBounds.bottomRight.x),
            y: Math.max(newBounds.topLeft.y, newBounds.bottomRight.y),
        };
        this._boxBounds = {
            topLeft: topLeft,
            bottomRight: bottomRight,
        };
    };
    SelectionBoxLayer.prototype._getBounds = function () {
        return {
            topLeft: {
                x: this._xBoundsMode === PropertyMode.PIXEL ?
                    this._boxBounds.topLeft.x :
                    (this._xScale == null ?
                        0 :
                        Math.min(this.xScale().scale(this.xExtent()[0]), this.xScale().scale(this.xExtent()[1]))),
                y: this._yBoundsMode === PropertyMode.PIXEL ?
                    this._boxBounds.topLeft.y :
                    (this._yScale == null ?
                        0 :
                        Math.min(this.yScale().scale(this.yExtent()[0]), this.yScale().scale(this.yExtent()[1]))),
            },
            bottomRight: {
                x: this._xBoundsMode === PropertyMode.PIXEL ?
                    this._boxBounds.bottomRight.x :
                    (this._xScale == null ?
                        0 :
                        Math.max(this.xScale().scale(this.xExtent()[0]), this.xScale().scale(this.xExtent()[1]))),
                y: this._yBoundsMode === PropertyMode.PIXEL ?
                    this._boxBounds.bottomRight.y :
                    (this._yScale == null ?
                        0 :
                        Math.max(this.yScale().scale(this.yExtent()[0]), this.yScale().scale(this.yExtent()[1]))),
            },
        };
    };
    SelectionBoxLayer.prototype.renderImmediately = function () {
        _super.prototype.renderImmediately.call(this);
        if (this._boxVisible) {
            var bounds = this.bounds();
            var t = bounds.topLeft.y;
            var b = bounds.bottomRight.y;
            var l = bounds.topLeft.x;
            var r = bounds.bottomRight.x;
            if (!(Utils.Math.isValidNumber(t) &&
                Utils.Math.isValidNumber(b) &&
                Utils.Math.isValidNumber(l) &&
                Utils.Math.isValidNumber(r))) {
                throw new Error("bounds have not been properly set");
            }
            this._boxArea.attrs({
                x: l, y: t, width: r - l, height: b - t,
            });
            this.content().node().appendChild(this._box.node());
        }
        else {
            this._box.remove();
        }
        return this;
    };
    SelectionBoxLayer.prototype.boxVisible = function (show) {
        if (show == null) {
            return this._boxVisible;
        }
        this._boxVisible = show;
        this.render();
        return this;
    };
    SelectionBoxLayer.prototype.fixedWidth = function () {
        return true;
    };
    SelectionBoxLayer.prototype.fixedHeight = function () {
        return true;
    };
    SelectionBoxLayer.prototype.xScale = function (xScale) {
        if (xScale == null) {
            return this._xScale;
        }
        if (this._xScale != null) {
            this._xScale.offUpdate(this._adjustBoundsCallback);
        }
        this._xScale = xScale;
        this._xBoundsMode = PropertyMode.VALUE;
        this._xScale.onUpdate(this._adjustBoundsCallback);
        this.render();
        return this;
    };
    SelectionBoxLayer.prototype.yScale = function (yScale) {
        if (yScale == null) {
            return this._yScale;
        }
        if (this._yScale != null) {
            this._yScale.offUpdate(this._adjustBoundsCallback);
        }
        this._yScale = yScale;
        this._yBoundsMode = PropertyMode.VALUE;
        this._yScale.onUpdate(this._adjustBoundsCallback);
        this.render();
        return this;
    };
    SelectionBoxLayer.prototype.xExtent = function (xExtent) {
        // Explicit typing for Typescript 1.4
        if (xExtent == null) {
            return this._getXExtent();
        }
        this._setXExtent(xExtent);
        this._xBoundsMode = PropertyMode.VALUE;
        this.render();
        return this;
    };
    SelectionBoxLayer.prototype._getXExtent = function () {
        return this._xBoundsMode === PropertyMode.VALUE ?
            this._xExtent :
            (this._xScale == null ?
                [undefined, undefined] :
                [
                    this._xScale.invert(this._boxBounds.topLeft.x),
                    this._xScale.invert(this._boxBounds.bottomRight.x),
                ]);
    };
    SelectionBoxLayer.prototype._setXExtent = function (xExtent) {
        this._xExtent = xExtent;
    };
    SelectionBoxLayer.prototype.yExtent = function (yExtent) {
        // Explicit typing for Typescript 1.4
        if (yExtent == null) {
            return this._getYExtent();
        }
        this._setYExtent(yExtent);
        this._yBoundsMode = PropertyMode.VALUE;
        this.render();
        return this;
    };
    SelectionBoxLayer.prototype._getYExtent = function () {
        return this._yBoundsMode === PropertyMode.VALUE ?
            this._yExtent :
            (this._yScale == null ?
                [undefined, undefined] :
                [
                    this._yScale.invert(this._boxBounds.topLeft.y),
                    this._yScale.invert(this._boxBounds.bottomRight.y),
                ]);
    };
    SelectionBoxLayer.prototype._setYExtent = function (yExtent) {
        this._yExtent = yExtent;
    };
    SelectionBoxLayer.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this._xScale != null) {
            this.xScale().offUpdate(this._adjustBoundsCallback);
        }
        if (this._yScale != null) {
            this.yScale().offUpdate(this._adjustBoundsCallback);
        }
    };
    return SelectionBoxLayer;
}(component_1.Component));
exports.SelectionBoxLayer = SelectionBoxLayer;

},{"../utils":624,"./component":532,"tslib":635}],545:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Utils = require("../utils");
var componentContainer_1 = require("./componentContainer");
var Table = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Table, _super);
    /**
     * A Table combines Components in the form of a grid. A
     * common case is combining a y-axis, x-axis, and the plotted data via
     * ```typescript
     * new Table([[yAxis, plot],
     *            [null,  xAxis]]);
     * ```
     *
     * @constructor
     * @param {(Component|null|undefined)[][]} [rows=[]] A 2-D array of Components to be added to the Table.
     *   null can be used if a cell is empty.
     */
    function Table(rows) {
        if (rows === void 0) { rows = []; }
        var _this = _super.call(this) || this;
        _this._rowPadding = 0;
        _this._columnPadding = 0;
        _this._rows = [];
        _this._rowWeights = [];
        _this._columnWeights = [];
        _this._nRows = 0;
        _this._nCols = 0;
        _this._calculatedLayout = null;
        _this.addClass("table");
        rows.forEach(function (row, rowIndex) {
            row.forEach(function (component, colIndex) {
                if (component != null) {
                    _this.add(component, rowIndex, colIndex);
                }
            });
        });
        return _this;
    }
    Table.prototype._forEach = function (callback) {
        for (var r = 0; r < this._nRows; r++) {
            for (var c = 0; c < this._nCols; c++) {
                if (this._rows[r][c] != null) {
                    callback(this._rows[r][c]);
                }
            }
        }
    };
    /**
     * Checks whether the specified Component is in the Table.
     */
    Table.prototype.has = function (component) {
        for (var r = 0; r < this._nRows; r++) {
            for (var c = 0; c < this._nCols; c++) {
                if (this._rows[r][c] === component) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Returns the Component at the specified row and column index.
     *
     * @param {number} rowIndex
     * @param {number} columnIndex
     * @returns {Component} The Component at the specified position, or null if no Component is there.
     */
    Table.prototype.componentAt = function (rowIndex, columnIndex) {
        if (rowIndex < 0 || rowIndex >= this._nRows || columnIndex < 0 || columnIndex >= this._nCols) {
            return null;
        }
        return this._rows[rowIndex][columnIndex];
    };
    /**
     * Adds a Component in the specified row and column position.
     *
     * For example, instead of calling `new Table([[a, b], [null, c]])`, you
     * could call
     * var table = new Plottable.Components.Table();
     * table.add(a, 0, 0);
     * table.add(b, 0, 1);
     * table.add(c, 1, 1);
     *
     * @param {Component} component The Component to be added.
     * @param {number} row
     * @param {number} col
     * @returns {Table} The calling Table.
     */
    Table.prototype.add = function (component, row, col) {
        if (component == null) {
            throw Error("Cannot add null to a table cell");
        }
        if (!this.has(component)) {
            var currentComponent = this._rows[row] && this._rows[row][col];
            if (currentComponent != null) {
                throw new Error("cell is occupied");
            }
            component.detach();
            this._nRows = Math.max(row + 1, this._nRows);
            this._nCols = Math.max(col + 1, this._nCols);
            this._padTableToSize(this._nRows, this._nCols);
            this._rows[row][col] = component;
            this._adoptAndAnchor(component);
            this.redraw();
        }
        return this;
    };
    Table.prototype._remove = function (component) {
        for (var r = 0; r < this._nRows; r++) {
            for (var c = 0; c < this._nCols; c++) {
                if (this._rows[r][c] === component) {
                    this._rows[r][c] = null;
                    return true;
                }
            }
        }
        return false;
    };
    Table.prototype._iterateLayout = function (availableWidth, availableHeight, isFinalOffer) {
        if (isFinalOffer === void 0) { isFinalOffer = false; }
        /*
         * Given availableWidth and availableHeight, figure out how to allocate it between rows and columns using an iterative algorithm.
         *
         * For both dimensions, keeps track of "guaranteedSpace", which the fixed-size components have requested, and
         * "proportionalSpace", which is being given to proportionally-growing components according to the weights on the table.
         * Here is how it works (example uses width but it is the same for height). First, columns are guaranteed no width, and
         * the free width is allocated to columns based on their colWeights. Then, in determineGuarantees, every component is
         * offered its column's width and may request some amount of it, which increases that column's guaranteed
         * width. If there are some components that were not satisfied with the width they were offered, and there is free
         * width that has not already been guaranteed, then the remaining width is allocated to the unsatisfied columns and the
         * algorithm runs again. If all components are satisfied, then the remaining width is allocated as proportional space
         * according to the colWeights.
         *
         * The guaranteed width for each column is monotonically increasing as the algorithm iterates. Since it is deterministic
         * and monotonically increasing, if the freeWidth does not change during an iteration it implies that no further progress
         * is possible, so the algorithm will not continue iterating on that dimension's account.
         *
         * If the algorithm runs more than 5 times, we stop and just use whatever we arrived at. It's not clear under what
         * circumstances this will happen or if it will happen at all. A message will be printed to the console if this occurs.
         *
         */
        var rows = this._rows;
        var cols = d3.transpose(this._rows);
        var availableWidthAfterPadding = availableWidth - this._columnPadding * (this._nCols - 1);
        var availableHeightAfterPadding = availableHeight - this._rowPadding * (this._nRows - 1);
        var rowWeights = Table._calcComponentWeights(this._rowWeights, rows, function (c) { return (c == null) || c.fixedHeight(); });
        var colWeights = Table._calcComponentWeights(this._columnWeights, cols, function (c) { return (c == null) || c.fixedWidth(); });
        // To give the table a good starting position to iterate from, we give the fixed-width components half-weight
        // so that they will get some initial space allocated to work with
        var heuristicColWeights = colWeights.map(function (c) { return c === 0 ? 0.5 : c; });
        var heuristicRowWeights = rowWeights.map(function (c) { return c === 0 ? 0.5 : c; });
        var colProportionalSpace = Table._calcProportionalSpace(heuristicColWeights, availableWidthAfterPadding);
        var rowProportionalSpace = Table._calcProportionalSpace(heuristicRowWeights, availableHeightAfterPadding);
        var guaranteedWidths = Utils.Array.createFilledArray(0, this._nCols);
        var guaranteedHeights = Utils.Array.createFilledArray(0, this._nRows);
        var freeWidth;
        var freeHeight;
        var nIterations = 0;
        var guarantees;
        var wantsWidth;
        var wantsHeight;
        while (true) {
            var offeredHeights = Utils.Array.add(guaranteedHeights, rowProportionalSpace);
            var offeredWidths = Utils.Array.add(guaranteedWidths, colProportionalSpace);
            guarantees = this._determineGuarantees(offeredWidths, offeredHeights, isFinalOffer);
            guaranteedWidths = guarantees.guaranteedWidths;
            guaranteedHeights = guarantees.guaranteedHeights;
            wantsWidth = guarantees.wantsWidthArr.some(function (x) { return x; });
            wantsHeight = guarantees.wantsHeightArr.some(function (x) { return x; });
            var lastFreeWidth = freeWidth;
            var lastFreeHeight = freeHeight;
            freeWidth = availableWidthAfterPadding - d3.sum(guarantees.guaranteedWidths);
            freeHeight = availableHeightAfterPadding - d3.sum(guarantees.guaranteedHeights);
            var xWeights = void 0;
            if (wantsWidth) { // If something wants width, divide free space between components that want more width
                xWeights = guarantees.wantsWidthArr.map(function (x) { return x ? 0.1 : 0; });
                xWeights = Utils.Array.add(xWeights, colWeights);
            }
            else { // Otherwise, divide free space according to the weights
                xWeights = colWeights;
            }
            var yWeights = void 0;
            if (wantsHeight) {
                yWeights = guarantees.wantsHeightArr.map(function (x) { return x ? 0.1 : 0; });
                yWeights = Utils.Array.add(yWeights, rowWeights);
            }
            else {
                yWeights = rowWeights;
            }
            colProportionalSpace = Table._calcProportionalSpace(xWeights, freeWidth);
            rowProportionalSpace = Table._calcProportionalSpace(yWeights, freeHeight);
            nIterations++;
            var canImproveWidthAllocation = freeWidth > 0 && freeWidth !== lastFreeWidth;
            var canImproveHeightAllocation = freeHeight > 0 && freeHeight !== lastFreeHeight;
            if (!(canImproveWidthAllocation || canImproveHeightAllocation)) {
                break;
            }
            if (nIterations > 5) {
                break;
            }
        }
        // Redo the proportional space one last time, to ensure we use the real weights not the wantsWidth/Height weights
        freeWidth = availableWidthAfterPadding - d3.sum(guarantees.guaranteedWidths);
        freeHeight = availableHeightAfterPadding - d3.sum(guarantees.guaranteedHeights);
        colProportionalSpace = Table._calcProportionalSpace(colWeights, freeWidth);
        rowProportionalSpace = Table._calcProportionalSpace(rowWeights, freeHeight);
        return {
            colProportionalSpace: colProportionalSpace,
            rowProportionalSpace: rowProportionalSpace,
            guaranteedWidths: guarantees.guaranteedWidths,
            guaranteedHeights: guarantees.guaranteedHeights,
            wantsWidth: wantsWidth,
            wantsHeight: wantsHeight,
        };
    };
    Table.prototype._determineGuarantees = function (offeredWidths, offeredHeights, isFinalOffer) {
        if (isFinalOffer === void 0) { isFinalOffer = false; }
        var requestedWidths = Utils.Array.createFilledArray(0, this._nCols);
        var requestedHeights = Utils.Array.createFilledArray(0, this._nRows);
        var columnNeedsWidth = Utils.Array.createFilledArray(false, this._nCols);
        var rowNeedsHeight = Utils.Array.createFilledArray(false, this._nRows);
        this._rows.forEach(function (row, rowIndex) {
            row.forEach(function (component, colIndex) {
                var spaceRequest;
                if (component != null) {
                    spaceRequest = component.requestedSpace(offeredWidths[colIndex], offeredHeights[rowIndex]);
                }
                else {
                    spaceRequest = {
                        minWidth: 0,
                        minHeight: 0,
                    };
                }
                var columnWidth = isFinalOffer ? Math.min(spaceRequest.minWidth, offeredWidths[colIndex]) : spaceRequest.minWidth;
                requestedWidths[colIndex] = Math.max(requestedWidths[colIndex], columnWidth);
                var rowHeight = isFinalOffer ? Math.min(spaceRequest.minHeight, offeredHeights[rowIndex]) : spaceRequest.minHeight;
                requestedHeights[rowIndex] = Math.max(requestedHeights[rowIndex], rowHeight);
                var componentNeedsWidth = spaceRequest.minWidth > offeredWidths[colIndex];
                columnNeedsWidth[colIndex] = columnNeedsWidth[colIndex] || componentNeedsWidth;
                var componentNeedsHeight = spaceRequest.minHeight > offeredHeights[rowIndex];
                rowNeedsHeight[rowIndex] = rowNeedsHeight[rowIndex] || componentNeedsHeight;
            });
        });
        return {
            guaranteedWidths: requestedWidths,
            guaranteedHeights: requestedHeights,
            wantsWidthArr: columnNeedsWidth,
            wantsHeightArr: rowNeedsHeight,
        };
    };
    Table.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        this._calculatedLayout = this._iterateLayout(offeredWidth, offeredHeight);
        return {
            minWidth: d3.sum(this._calculatedLayout.guaranteedWidths),
            minHeight: d3.sum(this._calculatedLayout.guaranteedHeights),
        };
    };
    Table.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        var _this = this;
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        var lastLayoutWidth = d3.sum(this._calculatedLayout.guaranteedWidths);
        var lastLayoutHeight = d3.sum(this._calculatedLayout.guaranteedHeights);
        var layout = this._calculatedLayout;
        if (lastLayoutWidth > this.width() || lastLayoutHeight > this.height()) {
            layout = this._iterateLayout(this.width(), this.height(), true);
        }
        var childYOrigin = 0;
        var rowHeights = Utils.Array.add(layout.rowProportionalSpace, layout.guaranteedHeights);
        var colWidths = Utils.Array.add(layout.colProportionalSpace, layout.guaranteedWidths);
        this._rows.forEach(function (row, rowIndex) {
            var childXOrigin = 0;
            row.forEach(function (component, colIndex) {
                // recursively compute layout
                if (component != null) {
                    component.computeLayout({ x: childXOrigin, y: childYOrigin }, colWidths[colIndex], rowHeights[rowIndex]);
                }
                childXOrigin += colWidths[colIndex] + _this._columnPadding;
            });
            childYOrigin += rowHeights[rowIndex] + _this._rowPadding;
        });
        return this;
    };
    Table.prototype.rowPadding = function (rowPadding) {
        if (rowPadding == null) {
            return this._rowPadding;
        }
        if (!Utils.Math.isValidNumber(rowPadding) || rowPadding < 0) {
            throw Error("rowPadding must be a non-negative finite value");
        }
        this._rowPadding = rowPadding;
        this.redraw();
        return this;
    };
    Table.prototype.columnPadding = function (columnPadding) {
        if (columnPadding == null) {
            return this._columnPadding;
        }
        if (!Utils.Math.isValidNumber(columnPadding) || columnPadding < 0) {
            throw Error("columnPadding must be a non-negative finite value");
        }
        this._columnPadding = columnPadding;
        this.redraw();
        return this;
    };
    Table.prototype.rowWeight = function (index, weight) {
        if (weight == null) {
            return this._rowWeights[index];
        }
        if (!Utils.Math.isValidNumber(weight) || weight < 0) {
            throw Error("rowWeight must be a non-negative finite value");
        }
        this._rowWeights[index] = weight;
        this.redraw();
        return this;
    };
    Table.prototype.columnWeight = function (index, weight) {
        if (weight == null) {
            return this._columnWeights[index];
        }
        if (!Utils.Math.isValidNumber(weight) || weight < 0) {
            throw Error("columnWeight must be a non-negative finite value");
        }
        this._columnWeights[index] = weight;
        this.redraw();
        return this;
    };
    Table.prototype.fixedWidth = function () {
        var cols = d3.transpose(this._rows);
        return Table._fixedSpace(cols, function (c) { return (c == null) || c.fixedWidth(); });
    };
    Table.prototype.fixedHeight = function () {
        return Table._fixedSpace(this._rows, function (c) { return (c == null) || c.fixedHeight(); });
    };
    Table.prototype._padTableToSize = function (nRows, nCols) {
        for (var i = 0; i < nRows; i++) {
            if (this._rows[i] === undefined) {
                this._rows[i] = [];
                this._rowWeights[i] = null;
            }
            for (var j = 0; j < nCols; j++) {
                if (this._rows[i][j] === undefined) {
                    this._rows[i][j] = null;
                }
            }
        }
        for (var j = 0; j < nCols; j++) {
            if (this._columnWeights[j] === undefined) {
                this._columnWeights[j] = null;
            }
        }
    };
    Table._calcComponentWeights = function (setWeights, componentGroups, fixityAccessor) {
        // If the row/col weight was explicitly set, then return it outright
        // If the weight was not explicitly set, then guess it using the heuristic that if all components are fixed-space
        // then weight is 0, otherwise weight is 1
        return setWeights.map(function (w, i) {
            if (w != null) {
                return w;
            }
            var fixities = componentGroups[i].map(fixityAccessor);
            var allFixed = fixities.reduce(function (a, b) { return a && b; }, true);
            return allFixed ? 0 : 1;
        });
    };
    Table._calcProportionalSpace = function (weights, freeSpace) {
        var weightSum = d3.sum(weights);
        if (weightSum === 0) {
            return Utils.Array.createFilledArray(0, weights.length);
        }
        else {
            return weights.map(function (w) { return freeSpace * w / weightSum; });
        }
    };
    Table._fixedSpace = function (componentGroup, fixityAccessor) {
        var all = function (bools) { return bools.reduce(function (a, b) { return a && b; }, true); };
        var groupIsFixed = function (components) { return all(components.map(fixityAccessor)); };
        return all(componentGroup.map(groupIsFixed));
    };
    return Table;
}(componentContainer_1.ComponentContainer));
exports.Table = Table;

},{"../utils":624,"./componentContainer":533,"d3":414,"tslib":635}],546:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WrappedLabel = void 0;
var tslib_1 = require("tslib");
var label_1 = require("./label");
var DEFAULT_MAX_LINES = 2;
var WrappedLabel = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(WrappedLabel, _super);
    function WrappedLabel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._maxLines = DEFAULT_MAX_LINES;
        return _this;
    }
    WrappedLabel.prototype.requestedSpace = function (offeredWidth, offeredHeight) {
        this._wrapper.maxLines(this._maxLines);
        var offeredLineLength = this.angle() === 0 ? offeredWidth : offeredHeight;
        if (offeredLineLength === 0) {
            offeredLineLength = Infinity;
        }
        var wrapped = this._wrapper.wrap(this._text, this._measurer, offeredLineLength);
        var measuredWrap = this._measurer.measure(wrapped.wrappedText);
        var minWidth = (this.angle() === 0 ? measuredWrap.width : measuredWrap.height) + 2 * this.padding();
        var minHeight = (this.angle() === 0 ? measuredWrap.height : measuredWrap.width) + 2 * this.padding();
        return { minWidth: minWidth, minHeight: minHeight };
    };
    WrappedLabel.prototype.maxLines = function (maxLines) {
        // allow user to un-set by passing in null or undefined explicitly
        if (arguments.length === 0) {
            return this._maxLines;
        }
        this._maxLines = maxLines;
        this.redraw();
        return this;
    };
    return WrappedLabel;
}(label_1.Label));
exports.WrappedLabel = WrappedLabel;

},{"./label":541,"tslib":635}],547:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XDragBoxLayer = void 0;
var tslib_1 = require("tslib");
var dragBoxLayer_1 = require("./dragBoxLayer");
var XDragBoxLayer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(XDragBoxLayer, _super);
    /**
     * An XDragBoxLayer is a DragBoxLayer whose size can only be set in the X-direction.
     * The y-values of the bounds() are always set to 0 and the height() of the XDragBoxLayer.
     *
     * @constructor
     */
    function XDragBoxLayer() {
        var _this = _super.call(this) || this;
        _this.addClass("x-drag-box-layer");
        _this._hasCorners = false;
        return _this;
    }
    XDragBoxLayer.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        // set correct bounds when width/height changes
        this._setBounds(this.bounds());
        return this;
    };
    XDragBoxLayer.prototype._setBounds = function (newBounds) {
        _super.prototype._setBounds.call(this, {
            topLeft: { x: newBounds.topLeft.x, y: 0 },
            bottomRight: { x: newBounds.bottomRight.x, y: this.height() },
        });
    };
    XDragBoxLayer.prototype._setResizableClasses = function (canResize) {
        if (canResize && this.enabled()) {
            this.addClass("x-resizable");
        }
        else {
            this.removeClass("x-resizable");
        }
    };
    XDragBoxLayer.prototype.yScale = function (yScale) {
        if (yScale == null) {
            return _super.prototype.yScale.call(this);
        }
        throw new Error("yScales cannot be set on an XDragBoxLayer");
    };
    XDragBoxLayer.prototype.yExtent = function (yExtent) {
        if (yExtent == null) {
            return _super.prototype.yExtent.call(this);
        }
        throw new Error("XDragBoxLayer has no yExtent");
    };
    return XDragBoxLayer;
}(dragBoxLayer_1.DragBoxLayer));
exports.XDragBoxLayer = XDragBoxLayer;

},{"./dragBoxLayer":534,"tslib":635}],548:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.YDragBoxLayer = void 0;
var tslib_1 = require("tslib");
var dragBoxLayer_1 = require("./dragBoxLayer");
var YDragBoxLayer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(YDragBoxLayer, _super);
    /**
     * A YDragBoxLayer is a DragBoxLayer whose size can only be set in the Y-direction.
     * The x-values of the bounds() are always set to 0 and the width() of the YDragBoxLayer.
     *
     * @constructor
     */
    function YDragBoxLayer() {
        var _this = _super.call(this) || this;
        _this.addClass("y-drag-box-layer");
        _this._hasCorners = false;
        return _this;
    }
    YDragBoxLayer.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        // set correct bounds when width/height changes
        this._setBounds(this.bounds());
        return this;
    };
    YDragBoxLayer.prototype._setBounds = function (newBounds) {
        _super.prototype._setBounds.call(this, {
            topLeft: { x: 0, y: newBounds.topLeft.y },
            bottomRight: { x: this.width(), y: newBounds.bottomRight.y },
        });
    };
    YDragBoxLayer.prototype._setResizableClasses = function (canResize) {
        if (canResize && this.enabled()) {
            this.addClass("y-resizable");
        }
        else {
            this.removeClass("y-resizable");
        }
    };
    YDragBoxLayer.prototype.xScale = function (xScale) {
        if (xScale == null) {
            return _super.prototype.xScale.call(this);
        }
        throw new Error("xScales cannot be set on an YDragBoxLayer");
    };
    YDragBoxLayer.prototype.xExtent = function (xExtent) {
        if (xExtent == null) {
            return _super.prototype.xExtent.call(this);
        }
        throw new Error("YDragBoxLayer has no xExtent");
    };
    return YDragBoxLayer;
}(dragBoxLayer_1.DragBoxLayer));
exports.YDragBoxLayer = YDragBoxLayer;

},{"./dragBoxLayer":534,"tslib":635}],549:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ADD_TITLE_ELEMENTS = exports.SHOW_WARNINGS = void 0;
/**
 * Specifies if Plottable should show warnings.
 */
exports.SHOW_WARNINGS = true;
/**
 * Specifies if Plottable should add <title> elements to text.
 */
exports.ADD_TITLE_ELEMENTS = true;

},{}],550:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dataset = void 0;
var Utils = require("../utils");
var UPDATE_MONOTONIC = 0;
var Dataset = /** @class */ (function () {
    /**
     * A Dataset contains an array of data and some metadata.
     * Changes to the data or metadata will cause anything subscribed to the Dataset to update.
     *
     * @constructor
     * @param {any[]} [data=[]] The data for this Dataset.
     * @param {any} [metadata={}] An object containing additional information.
     */
    function Dataset(data, metadata) {
        if (data === void 0) { data = []; }
        if (metadata === void 0) { metadata = {}; }
        this._updateId = UPDATE_MONOTONIC++;
        this._data = data;
        this._metadata = metadata;
        this._callbacks = new Utils.CallbackSet();
    }
    /**
     * Adds a callback to be called when the Dataset updates.
     *
     * @param {DatasetCallback} callback.
     * @returns {Dataset} The calling Dataset.
     */
    Dataset.prototype.onUpdate = function (callback) {
        this._callbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the Dataset updates.
     *
     * @param {DatasetCallback} callback
     * @returns {Dataset} The calling Dataset.
     */
    Dataset.prototype.offUpdate = function (callback) {
        this._callbacks.delete(callback);
        return this;
    };
    Dataset.prototype.data = function (data) {
        if (data == null) {
            return this._data;
        }
        else {
            this._data = data;
            this._dispatchUpdate();
            return this;
        }
    };
    Dataset.prototype.metadata = function (metadata) {
        if (metadata == null) {
            return this._metadata;
        }
        else {
            this._metadata = metadata;
            this._dispatchUpdate();
            return this;
        }
    };
    Dataset.prototype.updateId = function () {
        return this._updateId;
    };
    Dataset.prototype._dispatchUpdate = function () {
        this._updateId = UPDATE_MONOTONIC++;
        this._callbacks.callCallbacks(this);
    };
    return Dataset;
}());
exports.Dataset = Dataset;

},{"../utils":624}],551:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.time = exports.multiTime = exports.shortScale = exports.siSuffix = exports.percentage = exports.identity = exports.general = exports.fixed = exports.currency = void 0;
var d3 = require("d3");
// Do not use utc by default
var DEFAULT_USE_UTC = false;
/**
 * Creates a formatter for currency values.
 *
 * @param {number} [precision] The number of decimal places to show (default 2).
 * @param {string} [symbol] The currency symbol to use (default "$").
 * @param {boolean} [prefix] Whether to prepend or append the currency symbol (default true).
 *
 * @returns {Formatter} A formatter for currency values.
 */
function currency(precision, symbol, prefix) {
    if (precision === void 0) { precision = 2; }
    if (symbol === void 0) { symbol = "$"; }
    if (prefix === void 0) { prefix = true; }
    var fixedFormatter = fixed(precision);
    return function (d) {
        var formattedValue = fixedFormatter(Math.abs(d));
        if (formattedValue !== "") {
            if (prefix) {
                formattedValue = symbol + formattedValue;
            }
            else {
                formattedValue += symbol;
            }
            if (d < 0) {
                formattedValue = "-" + formattedValue;
            }
        }
        return formattedValue;
    };
}
exports.currency = currency;
/**
 * Creates a formatter that displays exactly [precision] decimal places.
 *
 * @param {number} [precision] The number of decimal places to show (default 3).
 *
 * @returns {Formatter} A formatter that displays exactly [precision] decimal places.
 */
function fixed(precision) {
    if (precision === void 0) { precision = 3; }
    verifyPrecision(precision);
    return function (d) { return d.toFixed(precision); };
}
exports.fixed = fixed;
/**
 * Creates a formatter that formats numbers to show no more than
 * [maxNumberOfDecimalPlaces] decimal places. All other values are stringified.
 *
 * @param {number} [maxNumberOfDecimalPlaces] The number of decimal places to show (default 3).
 *
 * @returns {Formatter} A formatter for general values.
 */
function general(maxNumberOfDecimalPlaces) {
    if (maxNumberOfDecimalPlaces === void 0) { maxNumberOfDecimalPlaces = 3; }
    verifyPrecision(maxNumberOfDecimalPlaces);
    return function (d) {
        if (typeof d === "number") {
            var multiplier = Math.pow(10, maxNumberOfDecimalPlaces);
            return String(Math.round(d * multiplier) / multiplier);
        }
        else {
            return String(d);
        }
    };
}
exports.general = general;
/**
 * Creates a formatter that stringifies its input.
 *
 * @returns {Formatter} A formatter that stringifies its input.
 */
function identity() {
    return function (d) { return String(d); };
}
exports.identity = identity;
/**
 * Creates a formatter for percentage values.
 * Multiplies the input by 100 and appends "%".
 *
 * @param {number} [precision] The number of decimal places to show (default 0).
 *
 * @returns {Formatter} A formatter for percentage values.
 */
function percentage(precision) {
    if (precision === void 0) { precision = 0; }
    var fixedFormatter = fixed(precision);
    return function (d) {
        var valToFormat = d * 100;
        // Account for float imprecision
        var valString = d.toString();
        var integerPowerTen = Math.pow(10, valString.length - (valString.indexOf(".") + 1));
        valToFormat = parseInt((valToFormat * integerPowerTen).toString(), 10) / integerPowerTen;
        return fixedFormatter(valToFormat) + "%";
    };
}
exports.percentage = percentage;
/**
 * Creates a formatter for values that displays [numberOfSignificantFigures] significant figures
 * and puts SI notation.
 *
 * @param {number} [numberOfSignificantFigures] The number of significant figures to show (default 3).
 *
 * @returns {Formatter} A formatter for SI values.
 */
function siSuffix(numberOfSignificantFigures) {
    if (numberOfSignificantFigures === void 0) { numberOfSignificantFigures = 3; }
    verifyPrecision(numberOfSignificantFigures);
    return function (d) { return d3.format("." + numberOfSignificantFigures + "s")(d); };
}
exports.siSuffix = siSuffix;
/**
 * Creates a formatter for values that displays abbreviated values
 * and uses standard short scale suffixes
 * - K - thousands - 10 ^ 3
 * - M - millions - 10 ^ 6
 * - B - billions - 10 ^ 9
 * - T - trillions - 10 ^ 12
 * - Q - quadrillions - 10 ^ 15
 *
 * Numbers with a magnitude outside of (10 ^ (-precision), 10 ^ 15) are shown using
 * scientific notation to avoid creating extremely long decimal strings.
 *
 * @param {number} [precision] the number of decimal places to show (default 3)
 * @returns {Formatter} A formatter with short scale formatting
 */
function shortScale(precision) {
    if (precision === void 0) { precision = 3; }
    verifyPrecision(precision);
    var suffixes = "KMBTQ";
    var exponentFormatter = d3.format("." + precision + "e");
    var fixedFormatter = d3.format("." + precision + "f");
    var max = Math.pow(10, (3 * (suffixes.length + 1)));
    var min = Math.pow(10, -precision);
    return function (num) {
        var absNum = Math.abs(num);
        if ((absNum < min || absNum >= max) && absNum !== 0) {
            return exponentFormatter(num);
        }
        var idx = -1;
        while (absNum >= Math.pow(1000, idx + 2) && idx < (suffixes.length - 1)) {
            idx++;
        }
        var output = "";
        if (idx === -1) {
            output = fixedFormatter(num);
        }
        else {
            output = fixedFormatter(num / Math.pow(1000, idx + 1)) + suffixes[idx];
        }
        // catch rounding by the underlying d3 formatter
        if ((num > 0 && output.substr(0, 4) === "1000") || (num < 0 && output.substr(0, 5) === "-1000")) {
            if (idx < suffixes.length - 1) {
                idx++;
                output = fixedFormatter(num / Math.pow(1000, idx + 1)) + suffixes[idx];
            }
            else {
                output = exponentFormatter(num);
            }
        }
        return output;
    };
}
exports.shortScale = shortScale;
/**
 * Creates a multi time formatter that displays dates.
 *
 * @returns {Formatter} A formatter for time/date values.
 */
function multiTime() {
    // Formatter tiers going from shortest time scale to largest - these were taken from d3
    // https://github.com/mbostock/d3/wiki/Time-Formatting#format_multi
    var candidateFormats = [
        {
            specifier: ".%L",
            predicate: function (d) { return d.getMilliseconds() !== 0; },
        },
        {
            specifier: ":%S",
            predicate: function (d) { return d.getSeconds() !== 0; },
        },
        {
            specifier: "%I:%M",
            predicate: function (d) { return d.getMinutes() !== 0; },
        },
        {
            specifier: "%I %p",
            predicate: function (d) { return d.getHours() !== 0; },
        },
        {
            specifier: "%a %d",
            predicate: function (d) { return d.getDay() !== 0 && d.getDate() !== 1; },
        },
        {
            specifier: "%b %d",
            predicate: function (d) { return d.getDate() !== 1; },
        },
        {
            specifier: "%b",
            predicate: function (d) { return d.getMonth() !== 0; },
        },
    ];
    return function (d) {
        var acceptableFormats = candidateFormats.filter(function (candidate) { return candidate.predicate(d); });
        var specifier = acceptableFormats.length > 0
            ? acceptableFormats[0].specifier
            : "%Y";
        return d3.timeFormat(specifier)(d);
    };
}
exports.multiTime = multiTime;
/**
 * Creates a time formatter that displays time/date using given specifier.
 *
 * List of directives can be found on: https://github.com/mbostock/d3/wiki/Time-Formatting#format
 *
 * @param {string} [specifier] The specifier for the formatter.
 * @param {boolean} [useUTC] Displays time in UTC if true, local time if false. Defaults to false.
 *
 * @returns {Formatter} A formatter for time/date values.
 */
function time(specifier, useUTC) {
    if (useUTC === void 0) { useUTC = DEFAULT_USE_UTC; }
    if (useUTC) {
        return d3.utcFormat(specifier);
    }
    return d3.timeFormat(specifier);
}
exports.time = time;
function verifyPrecision(precision) {
    if (precision < 0 || precision > 20) {
        throw new RangeError("Formatter precision must be between 0 and 20");
    }
    if (precision !== Math.floor(precision)) {
        throw new RangeError("Formatter precision must be an integer");
    }
}

},{"d3":414}],552:[function(require,module,exports){
arguments[4][523][0].apply(exports,arguments)
},{"dup":523}],553:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.flush = exports.registerToComputeLayout = exports.registerToComputeLayoutAndRender = exports.registerToRender = exports.renderPolicy = exports.Policy = void 0;
var Utils = require("../utils");
var makeEnum_1 = require("../utils/makeEnum");
var RenderPolicies = require("./renderPolicy");
/**
 * The RenderController is responsible for enqueueing and synchronizing
 * layout and render calls for Components.
 *
 * Layout and render calls occur inside an animation callback
 * (window.requestAnimationFrame if available).
 *
 * RenderController.flush() immediately lays out and renders all Components currently enqueued.
 *
 * To always have immediate rendering (useful for debugging), call
 * ```typescript
 * Plottable.RenderController.setRenderPolicy(
 *   new Plottable.RenderPolicies.Immediate()
 * );
 * ```
 */
var _componentsNeedingRender = new Utils.Set();
var _componentsNeedingComputeLayout = new Utils.Set();
var _animationRequested = false;
var _isCurrentlyFlushing = false;
exports.Policy = (0, makeEnum_1.makeEnum)(["immediate", "animationFrame", "timeout"]);
var _renderPolicy = new RenderPolicies.AnimationFrame();
function renderPolicy(renderPolicy) {
    if (renderPolicy == null) {
        return _renderPolicy;
    }
    switch (renderPolicy) {
        case exports.Policy.immediate:
            _renderPolicy = new RenderPolicies.Immediate();
            break;
        case exports.Policy.animationFrame:
            _renderPolicy = new RenderPolicies.AnimationFrame();
            break;
        case exports.Policy.timeout:
            _renderPolicy = new RenderPolicies.Timeout();
            break;
        default:
            Utils.Window.warn("Unrecognized renderPolicy: " + renderPolicy);
    }
}
exports.renderPolicy = renderPolicy;
/**
 * Enqueues the Component for rendering.
 *
 * @param {Component} component
 */
function registerToRender(component) {
    if (_isCurrentlyFlushing) {
        Utils.Window.warn("Registered to render while other components are flushing: request may be ignored");
    }
    _componentsNeedingRender.add(component);
    requestRender();
}
exports.registerToRender = registerToRender;
/**
 * Enqueues the Component for layout and rendering.
 *
 * @param {Component} component
 */
function registerToComputeLayoutAndRender(component) {
    _componentsNeedingComputeLayout.add(component);
    _componentsNeedingRender.add(component);
    requestRender();
}
exports.registerToComputeLayoutAndRender = registerToComputeLayoutAndRender;
/**
 * Enqueues the Component for layout and rendering.
 *
 * @param {Component} component
 * @deprecated This method has been renamed to `RenderController.registerToComputeLayoutAndRender()`.
 */
function registerToComputeLayout(component) {
    registerToComputeLayoutAndRender(component);
}
exports.registerToComputeLayout = registerToComputeLayout;
function requestRender() {
    // Only run or enqueue flush on first request.
    if (!_animationRequested) {
        _animationRequested = true;
        _renderPolicy.render();
    }
}
/**
 * Renders all Components waiting to be rendered immediately
 * instead of waiting until the next frame. Flush is idempotent (given there are no intermediate registrations).
 *
 * Useful to call when debugging.
 */
function flush() {
    if (_animationRequested) {
        // Layout
        _componentsNeedingComputeLayout.forEach(function (component) { return component.computeLayout(); });
        // Top level render; Containers will put their children in the toRender queue
        _componentsNeedingRender.forEach(function (component) { return component.render(); });
        _isCurrentlyFlushing = true;
        var failed_1 = new Utils.Set();
        _componentsNeedingRender.forEach(function (component) {
            try {
                component.renderImmediately();
            }
            catch (err) {
                // throw error with timeout to avoid interrupting further renders
                window.setTimeout(function () {
                    throw err;
                }, 0);
                failed_1.add(component);
            }
        });
        _componentsNeedingComputeLayout = new Utils.Set();
        _componentsNeedingRender = failed_1;
        _animationRequested = false;
        _isCurrentlyFlushing = false;
    }
}
exports.flush = flush;

},{"../utils":624,"../utils/makeEnum":625,"./renderPolicy":554}],554:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timeout = exports.AnimationFrame = exports.Immediate = void 0;
var Utils = require("../utils");
var RenderController = require("./renderController");
/**
 * Renders Components immediately after they are enqueued.
 * Useful for debugging, horrible for performance.
 */
var Immediate = /** @class */ (function () {
    function Immediate() {
    }
    Immediate.prototype.render = function () {
        RenderController.flush();
    };
    return Immediate;
}());
exports.Immediate = Immediate;
/**
 * The default way to render, which only tries to render every frame
 * (usually, 1/60th of a second).
 */
var AnimationFrame = /** @class */ (function () {
    function AnimationFrame() {
    }
    AnimationFrame.prototype.render = function () {
        Utils.DOM.requestAnimationFramePolyfill(RenderController.flush);
    };
    return AnimationFrame;
}());
exports.AnimationFrame = AnimationFrame;
/**
 * Renders with `setTimeout()`.
 * Generally an inferior way to render compared to `requestAnimationFrame`,
 * but useful for browsers that don't suppoort `requestAnimationFrame`.
 */
var Timeout = /** @class */ (function () {
    function Timeout() {
        this._timeoutMsec = Utils.DOM.SCREEN_REFRESH_RATE_MILLISECONDS;
    }
    Timeout.prototype.render = function () {
        setTimeout(RenderController.flush, this._timeoutMsec);
    };
    return Timeout;
}());
exports.Timeout = Timeout;

},{"../utils":624,"./renderController":553}],555:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.wye = exports.star = exports.triangle = exports.diamond = exports.cross = exports.square = exports.circle = void 0;
var d3 = require("d3");
function circle() {
    return function (symbolSize) {
        return d3.symbol().type(d3.symbolCircle).size(Math.PI * Math.pow(symbolSize / 2, 2));
    };
}
exports.circle = circle;
function square() {
    return function (symbolSize) {
        return d3.symbol().type(d3.symbolSquare).size(Math.pow(symbolSize, 2));
    };
}
exports.square = square;
function cross() {
    return function (symbolSize) {
        return d3.symbol().type(d3.symbolCross).size((5 / 9) * Math.pow(symbolSize, 2));
    };
}
exports.cross = cross;
function diamond() {
    return function (symbolSize) {
        return d3.symbol().type(d3.symbolDiamond).size(Math.tan(Math.PI / 6) * Math.pow(symbolSize, 2) / 2);
    };
}
exports.diamond = diamond;
function triangle() {
    return function (symbolSize) {
        return d3.symbol().type(d3.symbolTriangle).size(Math.sqrt(3) * Math.pow(symbolSize / 2, 2));
    };
}
exports.triangle = triangle;
// copied from https://github.com/d3/d3-shape/blob/e2e57722004acba754ed9edff020282682450c5c/src/symbol/star.js#L3
var ka = 0.89081309152928522810;
function star() {
    return function (symbolSize) {
        return d3.symbol().type(d3.symbolStar).size(ka * Math.pow(symbolSize / 2, 2));
    };
}
exports.star = star;
// copied from https://github.com/d3/d3-shape/blob/c35b2303eb4836aba3171642f01c2653e4228b9c/src/symbol/wye.js#L2
var a = ((1 / Math.sqrt(12)) / 2 + 1) * 3;
function wye() {
    return function (symbolSize) {
        return d3.symbol().type(d3.symbolWye).size(a * Math.pow(symbolSize / 2.4, 2));
    };
}
exports.wye = wye;

},{"d3":414}],556:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.version = void 0;
/*
 * WARNING: The js output of this expression is searched by string (yes, I know) and replaced with a
 * real version number during the dist phase for for npm module publishing. Modifying this line should
 * be accompanied by modifying the "sed-version" task in package.json accordingly.
 */
exports.version = "3.13.0";

},{}],557:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dispatcher = void 0;
var Utils = require("../utils");
var Dispatcher = /** @class */ (function () {
    function Dispatcher() {
        /**
         * Subclasses set these in constructor. Then, these get attached to the event
         * target in _connect
         *
         * eventname is a DOM event name like "mouseup", "touchstart", etc. The
         * callback is simply registered to the event callback with bubbling.
         */
        this._eventToProcessingFunction = {};
        /**
         * All listeners are registered to this `EventTarget` and events are then
         * dispatched to callbacks from `_eventNameToCallbackSet` manually.
         *
         * Subclasses set their own event target instead of `document`.
         */
        this._eventTarget = document;
        this._eventNameToCallbackSet = {};
        this._connected = false;
    }
    Dispatcher.prototype._hasNoCallbacks = function () {
        var eventNames = Object.keys(this._eventNameToCallbackSet);
        for (var i = 0; i < eventNames.length; i++) { // for-loop so return can break out
            if (this._eventNameToCallbackSet[eventNames[i]].size !== 0) {
                return false;
            }
        }
        return true;
    };
    Dispatcher.prototype._connect = function () {
        var _this = this;
        if (this._connected) {
            return;
        }
        Object.keys(this._eventToProcessingFunction).forEach(function (event) {
            var processingFunction = _this._eventToProcessingFunction[event];
            // Add `{ passive: false }` option because Chrome 73 broke this.
            var options = event === "wheel" ? { passive: false } : undefined;
            _this._eventTarget.addEventListener(event, processingFunction, options);
        });
        this._connected = true;
    };
    Dispatcher.prototype._disconnect = function () {
        var _this = this;
        if (this._connected && this._hasNoCallbacks()) {
            Object.keys(this._eventToProcessingFunction).forEach(function (event) {
                var processingFunction = _this._eventToProcessingFunction[event];
                _this._eventTarget.removeEventListener(event, processingFunction);
            });
            this._connected = false;
        }
    };
    Dispatcher.prototype._addCallbackForEvent = function (eventName, callback) {
        if (this._eventNameToCallbackSet[eventName] == null) {
            this._eventNameToCallbackSet[eventName] = new Utils.CallbackSet();
        }
        this._eventNameToCallbackSet[eventName].add(callback);
        this._connect();
    };
    Dispatcher.prototype._removeCallbackForEvent = function (eventName, callback) {
        if (this._eventNameToCallbackSet[eventName] != null) {
            this._eventNameToCallbackSet[eventName].delete(callback);
        }
        this._disconnect();
    };
    Dispatcher.prototype._callCallbacksForEvent = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var callbackSet = this._eventNameToCallbackSet[eventName];
        if (callbackSet != null) {
            callbackSet.callCallbacks.apply(callbackSet, args);
        }
    };
    return Dispatcher;
}());
exports.Dispatcher = Dispatcher;

},{"../utils":624}],558:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
(0, tslib_1.__exportStar)(require("./keyDispatcher"), exports);
(0, tslib_1.__exportStar)(require("./mouseDispatcher"), exports);
(0, tslib_1.__exportStar)(require("./touchDispatcher"), exports);

},{"./keyDispatcher":559,"./mouseDispatcher":560,"./touchDispatcher":561,"tslib":635}],559:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Key = void 0;
var tslib_1 = require("tslib");
var dispatcher_1 = require("./dispatcher");
var Key = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Key, _super);
    /**
     * This constructor should not be invoked directly.
     *
     * @constructor
     */
    function Key() {
        var _this = _super.call(this) || this;
        _this._eventToProcessingFunction[Key._KEYDOWN_EVENT_NAME] = function (e) { return _this._processKeydown(e); };
        _this._eventToProcessingFunction[Key._KEYUP_EVENT_NAME] = function (e) { return _this._processKeyup(e); };
        return _this;
    }
    /**
     * Gets a Key Dispatcher. If one already exists it will be returned;
     * otherwise, a new one will be created.
     *
     * @return {Dispatchers.Key}
     */
    Key.getDispatcher = function () {
        var dispatcher = document[Key._DISPATCHER_KEY];
        if (dispatcher == null) {
            dispatcher = new Key();
            document[Key._DISPATCHER_KEY] = dispatcher;
        }
        return dispatcher;
    };
    Key.prototype._processKeydown = function (event) {
        this._callCallbacksForEvent(Key._KEYDOWN_EVENT_NAME, event.keyCode, event);
    };
    Key.prototype._processKeyup = function (event) {
        this._callCallbacksForEvent(Key._KEYUP_EVENT_NAME, event.keyCode, event);
    };
    /**
     * Registers a callback to be called whenever a key is pressed.
     *
     * @param {KeyCallback} callback
     * @return {Dispatchers.Key} The calling Key Dispatcher.
     */
    Key.prototype.onKeyDown = function (callback) {
        this._addCallbackForEvent(Key._KEYDOWN_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes the callback to be called whenever a key is pressed.
     *
     * @param {KeyCallback} callback
     * @return {Dispatchers.Key} The calling Key Dispatcher.
     */
    Key.prototype.offKeyDown = function (callback) {
        this._removeCallbackForEvent(Key._KEYDOWN_EVENT_NAME, callback);
        return this;
    };
    /** Registers a callback to be called whenever a key is released.
     *
     * @param {KeyCallback} callback
     * @return {Dispatchers.Key} The calling Key Dispatcher.
     */
    Key.prototype.onKeyUp = function (callback) {
        this._addCallbackForEvent(Key._KEYUP_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes the callback to be called whenever a key is released.
     *
     * @param {KeyCallback} callback
     * @return {Dispatchers.Key} The calling Key Dispatcher.
     */
    Key.prototype.offKeyUp = function (callback) {
        this._removeCallbackForEvent(Key._KEYUP_EVENT_NAME, callback);
        return this;
    };
    Key._DISPATCHER_KEY = "__Plottable_Dispatcher_Key";
    Key._KEYDOWN_EVENT_NAME = "keydown";
    Key._KEYUP_EVENT_NAME = "keyup";
    return Key;
}(dispatcher_1.Dispatcher));
exports.Key = Key;

},{"./dispatcher":557,"tslib":635}],560:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mouse = void 0;
var tslib_1 = require("tslib");
var Utils = require("../utils");
var dispatcher_1 = require("./dispatcher");
var Mouse = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Mouse, _super);
    /**
     * This constructor not be invoked directly.
     *
     * @constructor
     */
    function Mouse(component) {
        var _this = _super.call(this) || this;
        _this._lastMousePosition = { x: -1, y: -1 };
        _this._translator = Utils.getTranslator(component);
        var processMoveCallback = function (e) { return _this._measureAndDispatch(component, e, Mouse._MOUSEMOVE_EVENT_NAME, "page"); };
        _this._eventToProcessingFunction[Mouse._MOUSEOVER_EVENT_NAME] = processMoveCallback;
        _this._eventToProcessingFunction[Mouse._MOUSEMOVE_EVENT_NAME] = processMoveCallback;
        _this._eventToProcessingFunction[Mouse._MOUSEOUT_EVENT_NAME] = processMoveCallback;
        _this._eventToProcessingFunction[Mouse._MOUSEDOWN_EVENT_NAME] =
            function (e) { return _this._measureAndDispatch(component, e, Mouse._MOUSEDOWN_EVENT_NAME); };
        _this._eventToProcessingFunction[Mouse._MOUSEUP_EVENT_NAME] =
            function (e) { return _this._measureAndDispatch(component, e, Mouse._MOUSEUP_EVENT_NAME, "page"); };
        _this._eventToProcessingFunction[Mouse._WHEEL_EVENT_NAME] =
            function (e) { return _this._measureAndDispatch(component, e, Mouse._WHEEL_EVENT_NAME); };
        _this._eventToProcessingFunction[Mouse._DBLCLICK_EVENT_NAME] =
            function (e) { return _this._measureAndDispatch(component, e, Mouse._DBLCLICK_EVENT_NAME); };
        return _this;
    }
    /**
     * Get a Mouse Dispatcher for the component tree.
     * If one already exists on that <svg>, it will be returned; otherwise, a new one will be created.
     *
     * @param {SVGElement} elem
     * @return {Dispatchers.Mouse}
     */
    Mouse.getDispatcher = function (component) {
        var element = component.root().rootElement();
        var dispatcher = element[Mouse._DISPATCHER_KEY];
        if (dispatcher == null) {
            dispatcher = new Mouse(component);
            element[Mouse._DISPATCHER_KEY] = dispatcher;
        }
        return dispatcher;
    };
    /**
     * Registers a callback to be called when the mouse position changes.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.onMouseMove = function (callback) {
        this._addCallbackForEvent(Mouse._MOUSEMOVE_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the mouse position changes.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.offMouseMove = function (callback) {
        this._removeCallbackForEvent(Mouse._MOUSEMOVE_EVENT_NAME, callback);
        return this;
    };
    /**
     * Registers a callback to be called when a mousedown occurs.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.onMouseDown = function (callback) {
        this._addCallbackForEvent(Mouse._MOUSEDOWN_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when a mousedown occurs.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.offMouseDown = function (callback) {
        this._removeCallbackForEvent(Mouse._MOUSEDOWN_EVENT_NAME, callback);
        return this;
    };
    /**
     * Registers a callback to be called when a mouseup occurs.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.onMouseUp = function (callback) {
        this._addCallbackForEvent(Mouse._MOUSEUP_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when a mouseup occurs.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.offMouseUp = function (callback) {
        this._removeCallbackForEvent(Mouse._MOUSEUP_EVENT_NAME, callback);
        return this;
    };
    /**
     * Registers a callback to be called when a wheel event occurs.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.onWheel = function (callback) {
        this._addCallbackForEvent(Mouse._WHEEL_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when a wheel event occurs.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.offWheel = function (callback) {
        this._removeCallbackForEvent(Mouse._WHEEL_EVENT_NAME, callback);
        return this;
    };
    /**
     * Registers a callback to be called when a dblClick occurs.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.onDblClick = function (callback) {
        this._addCallbackForEvent(Mouse._DBLCLICK_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when a dblClick occurs.
     *
     * @param {MouseCallback} callback
     * @return {Dispatchers.Mouse} The calling Mouse Dispatcher.
     */
    Mouse.prototype.offDblClick = function (callback) {
        this._removeCallbackForEvent(Mouse._DBLCLICK_EVENT_NAME, callback);
        return this;
    };
    /**
     * Computes the mouse position from the given event, and if successful
     * calls all the callbacks in the provided callbackSet.
     */
    Mouse.prototype._measureAndDispatch = function (component, event, eventName, scope) {
        if (scope === void 0) { scope = "element"; }
        if (scope !== "page" && scope !== "element") {
            throw new Error("Invalid scope '" + scope + "', must be 'element' or 'page'");
        }
        if (scope === "page" || this.eventInside(component, event)) {
            var position = this._translator.computePosition(event.clientX, event.clientY);
            this._lastMousePosition = position;
            this._callCallbacksForEvent(eventName, this.lastMousePosition(), event);
        }
    };
    Mouse.prototype.eventInside = function (component, event) {
        return Utils.Translator.isEventInside(component, event);
    };
    /**
     * Returns the last computed mouse position in <svg> coordinate space.
     *
     * @return {Point}
     */
    Mouse.prototype.lastMousePosition = function () {
        return this._lastMousePosition;
    };
    Mouse._DISPATCHER_KEY = "__Plottable_Dispatcher_Mouse";
    Mouse._MOUSEOVER_EVENT_NAME = "mouseover";
    Mouse._MOUSEMOVE_EVENT_NAME = "mousemove";
    Mouse._MOUSEOUT_EVENT_NAME = "mouseout";
    Mouse._MOUSEDOWN_EVENT_NAME = "mousedown";
    Mouse._MOUSEUP_EVENT_NAME = "mouseup";
    Mouse._WHEEL_EVENT_NAME = "wheel";
    Mouse._DBLCLICK_EVENT_NAME = "dblclick";
    return Mouse;
}(dispatcher_1.Dispatcher));
exports.Mouse = Mouse;

},{"../utils":624,"./dispatcher":557,"tslib":635}],561:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Touch = void 0;
var tslib_1 = require("tslib");
var Utils = require("../utils");
var dispatcher_1 = require("./dispatcher");
var Touch = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Touch, _super);
    /**
     * This constructor should not be invoked directly.
     *
     * @param {SVGElement} svg The root <svg> to attach to.
     */
    function Touch(component) {
        var _this = _super.call(this) || this;
        _this._translator = Utils.getTranslator(component);
        _this._eventToProcessingFunction[Touch._TOUCHSTART_EVENT_NAME] =
            function (e) { return _this._measureAndDispatch(component, e, Touch._TOUCHSTART_EVENT_NAME, "page"); };
        _this._eventToProcessingFunction[Touch._TOUCHMOVE_EVENT_NAME] =
            function (e) { return _this._measureAndDispatch(component, e, Touch._TOUCHMOVE_EVENT_NAME, "page"); };
        _this._eventToProcessingFunction[Touch._TOUCHEND_EVENT_NAME] =
            function (e) { return _this._measureAndDispatch(component, e, Touch._TOUCHEND_EVENT_NAME, "page"); };
        _this._eventToProcessingFunction[Touch._TOUCHCANCEL_EVENT_NAME] =
            function (e) { return _this._measureAndDispatch(component, e, Touch._TOUCHCANCEL_EVENT_NAME, "page"); };
        return _this;
    }
    /**
     * Gets a Touch Dispatcher for the component.
     * If one already exists, it will be returned; otherwise, a new one will be created.
     *
     * @param component
     * @return {Dispatchers.Touch}
     */
    Touch.getDispatcher = function (component) {
        var svg = component.root().rootElement();
        var dispatcher = svg[Touch._DISPATCHER_KEY];
        if (dispatcher == null) {
            dispatcher = new Touch(component);
            svg[Touch._DISPATCHER_KEY] = dispatcher;
        }
        return dispatcher;
    };
    /**
     * Registers a callback to be called when a touch starts.
     *
     * @param {TouchCallback} callback
     * @return {Dispatchers.Touch} The calling Touch Dispatcher.
     */
    Touch.prototype.onTouchStart = function (callback) {
        this._addCallbackForEvent(Touch._TOUCHSTART_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when a touch starts.
     *
     * @param {TouchCallback} callback
     * @return {Dispatchers.Touch} The calling Touch Dispatcher.
     */
    Touch.prototype.offTouchStart = function (callback) {
        this._removeCallbackForEvent(Touch._TOUCHSTART_EVENT_NAME, callback);
        return this;
    };
    /**
     * Registers a callback to be called when the touch position changes.
     *
     * @param {TouchCallback} callback
     * @return {Dispatchers.Touch} The calling Touch Dispatcher.
     */
    Touch.prototype.onTouchMove = function (callback) {
        this._addCallbackForEvent(Touch._TOUCHMOVE_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the touch position changes.
     *
     * @param {TouchCallback} callback
     * @return {Dispatchers.Touch} The calling Touch Dispatcher.
     */
    Touch.prototype.offTouchMove = function (callback) {
        this._removeCallbackForEvent(Touch._TOUCHMOVE_EVENT_NAME, callback);
        return this;
    };
    /**
     * Registers a callback to be called when a touch ends.
     *
     * @param {TouchCallback} callback
     * @return {Dispatchers.Touch} The calling Touch Dispatcher.
     */
    Touch.prototype.onTouchEnd = function (callback) {
        this._addCallbackForEvent(Touch._TOUCHEND_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when a touch ends.
     *
     * @param {TouchCallback} callback
     * @return {Dispatchers.Touch} The calling Touch Dispatcher.
     */
    Touch.prototype.offTouchEnd = function (callback) {
        this._removeCallbackForEvent(Touch._TOUCHEND_EVENT_NAME, callback);
        return this;
    };
    /**
     * Registers a callback to be called when a touch is cancelled.
     *
     * @param {TouchCallback} callback
     * @return {Dispatchers.Touch} The calling Touch Dispatcher.
     */
    Touch.prototype.onTouchCancel = function (callback) {
        this._addCallbackForEvent(Touch._TOUCHCANCEL_EVENT_NAME, callback);
        return this;
    };
    /**
     * Removes a callback that would be called when a touch is cancelled.
     *
     * @param {TouchCallback} callback
     * @return {Dispatchers.Touch} The calling Touch Dispatcher.
     */
    Touch.prototype.offTouchCancel = function (callback) {
        this._removeCallbackForEvent(Touch._TOUCHCANCEL_EVENT_NAME, callback);
        return this;
    };
    /**
     * Computes the Touch position from the given event, and if successful
     * calls all the callbacks in the provided callbackSet.
     */
    Touch.prototype._measureAndDispatch = function (component, event, eventName, scope) {
        if (scope === void 0) { scope = "element"; }
        if (scope !== "page" && scope !== "element") {
            throw new Error("Invalid scope '" + scope + "', must be 'element' or 'page'");
        }
        if (scope === "element" && !this.eventInside(component, event)) {
            return;
        }
        var touches = event.changedTouches;
        var touchPositions = {};
        var touchIdentifiers = [];
        for (var i = 0; i < touches.length; i++) {
            var touch = touches[i];
            var touchID = touch.identifier;
            var newTouchPosition = this._translator.computePosition(touch.clientX, touch.clientY);
            if (newTouchPosition != null) {
                touchPositions[touchID] = newTouchPosition;
                touchIdentifiers.push(touchID);
            }
        }
        if (touchIdentifiers.length > 0) {
            this._callCallbacksForEvent(eventName, touchIdentifiers, touchPositions, event);
        }
    };
    Touch.prototype.eventInside = function (component, event) {
        return Utils.Translator.isEventInside(component, event);
    };
    Touch._DISPATCHER_KEY = "__Plottable_Dispatcher_Touch";
    Touch._TOUCHSTART_EVENT_NAME = "touchstart";
    Touch._TOUCHMOVE_EVENT_NAME = "touchmove";
    Touch._TOUCHEND_EVENT_NAME = "touchend";
    Touch._TOUCHCANCEL_EVENT_NAME = "touchcancel";
    return Touch;
}(dispatcher_1.Dispatcher));
exports.Touch = Touch;

},{"../utils":624,"./dispatcher":557,"tslib":635}],562:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArcSVGDrawer = void 0;
var tslib_1 = require("tslib");
var svgDrawer_1 = require("./svgDrawer");
var ArcSVGDrawer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ArcSVGDrawer, _super);
    function ArcSVGDrawer() {
        return _super.call(this, "path", "arc fill") || this;
    }
    ArcSVGDrawer.prototype._applyDefaultAttributes = function (selection) {
        selection.style("stroke", "none");
    };
    return ArcSVGDrawer;
}(svgDrawer_1.SVGDrawer));
exports.ArcSVGDrawer = ArcSVGDrawer;

},{"./svgDrawer":573,"tslib":635}],563:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArcOutlineSVGDrawer = void 0;
var tslib_1 = require("tslib");
var svgDrawer_1 = require("./svgDrawer");
var ArcOutlineSVGDrawer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ArcOutlineSVGDrawer, _super);
    function ArcOutlineSVGDrawer() {
        return _super.call(this, "path", "arc outline") || this;
    }
    ArcOutlineSVGDrawer.prototype._applyDefaultAttributes = function (selection) {
        selection.style("fill", "none");
    };
    return ArcOutlineSVGDrawer;
}(svgDrawer_1.SVGDrawer));
exports.ArcOutlineSVGDrawer = ArcOutlineSVGDrawer;

},{"./svgDrawer":573,"tslib":635}],564:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeAreaCanvasDrawStep = exports.AreaSVGDrawer = void 0;
var tslib_1 = require("tslib");
var canvasDrawer_1 = require("./canvasDrawer");
var svgDrawer_1 = require("./svgDrawer");
var AreaSVGDrawer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(AreaSVGDrawer, _super);
    function AreaSVGDrawer() {
        return _super.call(this, "path", "area") || this;
    }
    AreaSVGDrawer.prototype._applyDefaultAttributes = function (selection) {
        selection.style("stroke", "none");
    };
    AreaSVGDrawer.prototype.getVisualPrimitiveAtIndex = function (index) {
        // areas are represented by one single element; always get that element
        // regardless of the data index.
        return _super.prototype.getVisualPrimitiveAtIndex.call(this, 0);
    };
    return AreaSVGDrawer;
}(svgDrawer_1.SVGDrawer));
exports.AreaSVGDrawer = AreaSVGDrawer;
var AREA_FILL_ATTRS = ["opacity", "fill", "fill-opacity"];
var AREA_STROKE_ATTRS = ["opacity", "stroke", "stroke-width"];
function makeAreaCanvasDrawStep(d3AreaFactory, d3LineFactory) {
    return function (context, data, projector) {
        var fillAttrs = (0, canvasDrawer_1.resolveAttributes)(projector, AREA_FILL_ATTRS, data[0], 0);
        (0, canvasDrawer_1.renderArea)(context, d3AreaFactory(), data[0], fillAttrs);
        var strokeAttrs = (0, canvasDrawer_1.resolveAttributes)(projector, AREA_STROKE_ATTRS, data[0], 0);
        (0, canvasDrawer_1.renderLine)(context, d3LineFactory(), data[0], strokeAttrs);
    };
}
exports.makeAreaCanvasDrawStep = makeAreaCanvasDrawStep;

},{"./canvasDrawer":566,"./svgDrawer":573,"tslib":635}],565:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanvasBuffer = void 0;
var CanvasBuffer = /** @class */ (function () {
    function CanvasBuffer(screenWidth, screenHeight, devicePixelRatio) {
        if (devicePixelRatio === void 0) { devicePixelRatio = window.devicePixelRatio; }
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
        this.devicePixelRatio = devicePixelRatio;
        this.pixelWidth = screenWidth * devicePixelRatio;
        this.pixelHeight = screenHeight * devicePixelRatio;
        this.canvas = document.createElement("canvas");
        this.ctx = this.canvas.getContext("2d");
        CanvasBuffer.sizePixels(this.ctx, screenWidth, screenHeight, devicePixelRatio);
    }
    /**
     * Resizes the canvas' internal pixel buffer to match the devicePixelRatio
     */
    CanvasBuffer.sizePixels = function (ctx, screenWidth, screenHeight, devicePixelRatio) {
        var canvas = ctx.canvas;
        canvas.width = screenWidth * devicePixelRatio;
        canvas.height = screenHeight * devicePixelRatio;
        canvas.style.width = screenWidth + "px";
        canvas.style.height = screenHeight + "px";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(devicePixelRatio, devicePixelRatio);
    };
    CanvasBuffer.prototype.blit = function (ctx, x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        ctx.drawImage(this.canvas, x, y, this.screenWidth, this.screenHeight);
    };
    CanvasBuffer.prototype.blitCenter = function (ctx, x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.blit(ctx, Math.floor(x - this.screenWidth / 2), Math.floor(y - this.screenHeight / 2));
    };
    /**
     * Changes the size of the underlying canvas in screen space, respecting the
     * current devicePixelRatio.
     *
     * @param center - optionally enable a translate transformation moving the
     *                 origin to the center of the canvas.
     */
    CanvasBuffer.prototype.resize = function (screenWidth, screenHeight, center) {
        if (center === void 0) { center = false; }
        var devicePixelRatio = this.devicePixelRatio;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
        this.pixelWidth = screenWidth * devicePixelRatio;
        this.pixelHeight = screenHeight * devicePixelRatio;
        CanvasBuffer.sizePixels(this.ctx, screenWidth, screenHeight, devicePixelRatio);
        if (center) {
            this.ctx.translate(screenWidth / 2, screenWidth / 2);
        }
        return this;
    };
    /**
     * Temporarily resets the current context transformation and fills the
     * entire canvas with the provided color. If no color is provided, the
     * canvas is cleared instead.
     */
    CanvasBuffer.prototype.clear = function (color) {
        var _a = this, pixelWidth = _a.pixelWidth, pixelHeight = _a.pixelHeight, ctx = _a.ctx;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (color == null) {
            ctx.clearRect(0, 0, pixelWidth, pixelHeight);
        }
        else {
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, pixelWidth, pixelHeight);
        }
        ctx.restore();
        return this;
    };
    CanvasBuffer.prototype.getImageData = function () {
        return this.ctx.getImageData(0, 0, this.pixelWidth, this.pixelHeight);
    };
    return CanvasBuffer;
}());
exports.CanvasBuffer = CanvasBuffer;

},{}],566:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderPathWithStyle = exports.renderLine = exports.renderArea = exports.getStrokeDashArray = exports.getStrokeWidth = exports.resolveAttributes = exports.resolveAttributesSubsetWithStyles = exports.ContextStyleAttrs = exports.CanvasDrawer = void 0;
var d3 = require("d3");
/**
 * A CanvasDrawer draws data onto a supplied Canvas Context.
 *
 * This class is immutable (but has internal state) and shouldn't be extended.
 */
var CanvasDrawer = /** @class */ (function () {
    /**
     * @param _context The context for a canvas that this drawer will draw to.
     * @param _drawStep The draw step logic that actually draws.
     */
    function CanvasDrawer(_context, _drawStep) {
        this._context = _context;
        this._drawStep = _drawStep;
    }
    // public for testing
    CanvasDrawer.prototype.getDrawStep = function () {
        return this._drawStep;
    };
    CanvasDrawer.prototype.draw = function (data, appliedDrawSteps) {
        var projector = appliedDrawSteps[appliedDrawSteps.length - 1].attrToAppliedProjector;
        // don't support animations for now; just draw the last draw step immediately
        this._context.save();
        this._drawStep(this._context, data, projector);
        this._context.restore();
    };
    CanvasDrawer.prototype.getVisualPrimitives = function () {
        return [];
    };
    CanvasDrawer.prototype.getVisualPrimitiveAtIndex = function (index) {
        return null;
    };
    CanvasDrawer.prototype.remove = function () {
        // NO op - canvas element owns the canvas; context is free
    };
    return CanvasDrawer;
}());
exports.CanvasDrawer = CanvasDrawer;
exports.ContextStyleAttrs = [
    "fill-opacity",
    "fill",
    "opacity",
    "stroke-opacity",
    "stroke-width",
    "stroke",
    "stroke-dasharray",
];
/**
 * DEPRECATED. Precompute the concatted array and use `resolveAttributes`
 * instead of using this in the inner loop.
 */
function resolveAttributesSubsetWithStyles(projector, extraKeys, datum, index) {
    var attrKeys = exports.ContextStyleAttrs.concat(extraKeys);
    return resolveAttributes(projector, attrKeys, datum, index);
}
exports.resolveAttributesSubsetWithStyles = resolveAttributesSubsetWithStyles;
function resolveAttributes(projector, attrKeys, datum, index) {
    var attrs = {};
    for (var _i = 0, attrKeys_1 = attrKeys; _i < attrKeys_1.length; _i++) {
        var attrKey = attrKeys_1[_i];
        if (projector.hasOwnProperty(attrKey)) {
            attrs[attrKey] = projector[attrKey](datum, index);
        }
    }
    return attrs;
}
exports.resolveAttributes = resolveAttributes;
function getStrokeOpacity(style) {
    var baseOpacity = style["opacity"] != null ? parseFloat(style["opacity"]) : 1;
    var strokeOpacity = style["stroke-opacity"] != null ? parseFloat(style["stroke-opacity"]) : 1;
    return strokeOpacity * baseOpacity;
}
function getFillOpacity(style) {
    var baseOpacity = style["opacity"] != null ? parseFloat(style["opacity"]) : 1;
    var fillOpacity = style["fill-opacity"] != null ? parseFloat(style["fill-opacity"]) : 1;
    return fillOpacity * baseOpacity;
}
function getStrokeWidth(style) {
    return style["stroke-width"] != null ? parseFloat(style["stroke-width"]) : 1;
}
exports.getStrokeWidth = getStrokeWidth;
function getStrokeDashArray(style) {
    var rawValue = style["stroke-dasharray"];
    if (rawValue != null) {
        try {
            return rawValue.split(/[ ,]+/).map(function (x) { return parseInt(x, 10); });
        }
        catch (e) {
            console.error("getStrokeDashArray failed with: " + e);
            return [];
        }
    }
    return [];
}
exports.getStrokeDashArray = getStrokeDashArray;
function renderArea(context, d3Area, data, style) {
    context.save();
    context.beginPath();
    d3Area.context(context);
    d3Area(data);
    context.lineJoin = "round";
    renderPathWithStyle(context, style);
    context.restore();
}
exports.renderArea = renderArea;
function renderLine(context, d3Line, data, style) {
    context.save();
    context.beginPath();
    d3Line.context(context);
    d3Line(data);
    context.lineJoin = "round";
    renderPathWithStyle(context, style);
    context.restore();
}
exports.renderLine = renderLine;
function renderPathWithStyle(context, style) {
    if (style["stroke"]) {
        context.lineWidth = getStrokeWidth(style);
        var strokeColor = d3.color(style["stroke"]);
        var strokeDashArray = getStrokeDashArray(style);
        context.setLineDash(strokeDashArray);
        strokeColor.opacity *= getStrokeOpacity(style);
        context.strokeStyle = strokeColor.toString();
        context.stroke();
    }
    if (style["fill"]) {
        var fillColor = d3.color(style["fill"]);
        fillColor.opacity *= getFillOpacity(style);
        context.fillStyle = fillColor.toString();
        context.fill();
    }
}
exports.renderPathWithStyle = renderPathWithStyle;

},{"d3":414}],567:[function(require,module,exports){
arguments[4][523][0].apply(exports,arguments)
},{"dup":523}],568:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyDrawer = void 0;
/**
 * A Drawer is a stateful class that holds one SVGDrawer and one CanvasDrawer, and can switch between
 * the two.
 */
var ProxyDrawer = /** @class */ (function () {
    /**
     * A Drawer draws svg elements based on the input Dataset.
     *
     * @constructor
     * @param _svgDrawerFactory A factory that will be invoked to create an SVGDrawer whenever useSVG is called
     * @param _canvasDrawStep The DrawStep to be fed into a new CanvasDrawer whenever useCanvas is called
     */
    function ProxyDrawer(_svgDrawerFactory, _canvasDrawerFactory) {
        this._svgDrawerFactory = _svgDrawerFactory;
        this._canvasDrawerFactory = _canvasDrawerFactory;
    }
    /**
     * Remove the old drawer and use SVG rendering from now on.
     */
    ProxyDrawer.prototype.useSVG = function (parent) {
        if (this._currentDrawer != null) {
            this._currentDrawer.remove();
        }
        var svgDrawer = this._svgDrawerFactory();
        svgDrawer.attachTo(parent);
        this._currentDrawer = svgDrawer;
    };
    /**
     * Remove the old drawer and use Canvas rendering from now on.
     */
    ProxyDrawer.prototype.useCanvas = function (canvas) {
        if (this._currentDrawer != null) {
            this._currentDrawer.remove();
        }
        this._currentDrawer = this._canvasDrawerFactory(canvas.node().getContext("2d"));
    };
    // public for testing
    ProxyDrawer.prototype.getDrawer = function () {
        return this._currentDrawer;
    };
    /**
     * Removes this Drawer's renderArea
     */
    ProxyDrawer.prototype.remove = function () {
        if (this._currentDrawer != null) {
            this._currentDrawer.remove();
        }
    };
    ProxyDrawer.prototype.draw = function (data, drawSteps) {
        this._currentDrawer.draw(data, drawSteps);
    };
    ProxyDrawer.prototype.getVisualPrimitives = function () {
        return this._currentDrawer.getVisualPrimitives();
    };
    ProxyDrawer.prototype.getVisualPrimitiveAtIndex = function (index) {
        return this._currentDrawer.getVisualPrimitiveAtIndex(index);
    };
    return ProxyDrawer;
}());
exports.ProxyDrawer = ProxyDrawer;

},{}],569:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
(0, tslib_1.__exportStar)(require("./arcDrawer"), exports);
(0, tslib_1.__exportStar)(require("./arcOutlineDrawer"), exports);
(0, tslib_1.__exportStar)(require("./areaDrawer"), exports);
(0, tslib_1.__exportStar)(require("./canvasDrawer"), exports);
(0, tslib_1.__exportStar)(require("./drawer"), exports);
(0, tslib_1.__exportStar)(require("./drawStep"), exports);
(0, tslib_1.__exportStar)(require("./lineDrawer"), exports);
(0, tslib_1.__exportStar)(require("./rectangleDrawer"), exports);
(0, tslib_1.__exportStar)(require("./segmentDrawer"), exports);
(0, tslib_1.__exportStar)(require("./svgDrawer"), exports);
(0, tslib_1.__exportStar)(require("./symbolDrawer"), exports);

},{"./arcDrawer":562,"./arcOutlineDrawer":563,"./areaDrawer":564,"./canvasDrawer":566,"./drawStep":567,"./drawer":568,"./lineDrawer":570,"./rectangleDrawer":571,"./segmentDrawer":572,"./svgDrawer":573,"./symbolDrawer":574,"tslib":635}],570:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeLineCanvasDrawStep = exports.LineSVGDrawer = void 0;
var tslib_1 = require("tslib");
var canvasDrawer_1 = require("./canvasDrawer");
var svgDrawer_1 = require("./svgDrawer");
var LineSVGDrawer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(LineSVGDrawer, _super);
    function LineSVGDrawer() {
        return _super.call(this, "path", "line") || this;
    }
    LineSVGDrawer.prototype._applyDefaultAttributes = function (selection) {
        selection.style("fill", "none");
    };
    LineSVGDrawer.prototype.getVisualPrimitiveAtIndex = function (index) {
        return _super.prototype.getVisualPrimitiveAtIndex.call(this, 0);
    };
    return LineSVGDrawer;
}(svgDrawer_1.SVGDrawer));
exports.LineSVGDrawer = LineSVGDrawer;
var LINE_ATTRIBUTES = [
    "opacity",
    "stroke-opacity",
    "stroke-width",
    "stroke",
    "stroke-dasharray",
];
/**
 * @param d3LineFactory A callback that gives this Line Drawer a d3.Line object which will be
 * used to draw with.
 *
 * TODO put the d3.Line into the attrToAppliedProjector directly
 */
function makeLineCanvasDrawStep(d3LineFactory) {
    return function (context, data, attrToAppliedProjector) {
        var lineStyle = (0, canvasDrawer_1.resolveAttributes)(attrToAppliedProjector, LINE_ATTRIBUTES, data[0], 0);
        (0, canvasDrawer_1.renderLine)(context, d3LineFactory(), data[0], lineStyle);
    };
}
exports.makeLineCanvasDrawStep = makeLineCanvasDrawStep;

},{"./canvasDrawer":566,"./svgDrawer":573,"tslib":635}],571:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RectangleCanvasDrawer = exports.RectangleCanvasDrawStep = exports.RectangleSVGDrawer = void 0;
var tslib_1 = require("tslib");
var canvasDrawer_1 = require("./canvasDrawer");
var svgDrawer_1 = require("./svgDrawer");
var RectangleSVGDrawer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(RectangleSVGDrawer, _super);
    function RectangleSVGDrawer(_rootClassName) {
        if (_rootClassName === void 0) { _rootClassName = ""; }
        var _this = _super.call(this, "rect", "") || this;
        _this._rootClassName = _rootClassName;
        _this._root.classed(_this._rootClassName, true);
        return _this;
    }
    return RectangleSVGDrawer;
}(svgDrawer_1.SVGDrawer));
exports.RectangleSVGDrawer = RectangleSVGDrawer;
var RECT_ATTRS = canvasDrawer_1.ContextStyleAttrs.concat(["x", "y", "width", "height"]);
var RectangleCanvasDrawStep = function (context, data, projector) {
    context.save();
    var dataLen = data.length;
    for (var index = 0; index < dataLen; index++) {
        var datum = data[index];
        if (datum == null) {
            continue;
        }
        var attrs = (0, canvasDrawer_1.resolveAttributes)(projector, RECT_ATTRS, datum, index);
        context.beginPath();
        context.rect(attrs["x"], attrs["y"], attrs["width"], attrs["height"]);
        (0, canvasDrawer_1.renderPathWithStyle)(context, attrs);
    }
    context.restore();
};
exports.RectangleCanvasDrawStep = RectangleCanvasDrawStep;
var RectangleCanvasDrawer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(RectangleCanvasDrawer, _super);
    function RectangleCanvasDrawer(ctx) {
        return _super.call(this, ctx, exports.RectangleCanvasDrawStep) || this;
    }
    return RectangleCanvasDrawer;
}(canvasDrawer_1.CanvasDrawer));
exports.RectangleCanvasDrawer = RectangleCanvasDrawer;

},{"./canvasDrawer":566,"./svgDrawer":573,"tslib":635}],572:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SegmentSVGDrawer = void 0;
var tslib_1 = require("tslib");
var svgDrawer_1 = require("./svgDrawer");
var SegmentSVGDrawer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(SegmentSVGDrawer, _super);
    function SegmentSVGDrawer() {
        return _super.call(this, "line", "") || this;
    }
    return SegmentSVGDrawer;
}(svgDrawer_1.SVGDrawer));
exports.SegmentSVGDrawer = SegmentSVGDrawer;

},{"./svgDrawer":573,"tslib":635}],573:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SVGDrawer = void 0;
var d3 = require("d3");
var Utils = require("../utils");
/**
 * An SVGDrawer draws data by creating DOM elements and setting specific attributes on them
 * to accurately reflect the data being passed in.
 *
 * This class is immutable (but has internal state).
 */
var SVGDrawer = /** @class */ (function () {
    /**
     * @param svgElementName an HTML/SVG tag name to be created, one per datum.
     * @param className CSS classes to be applied to the drawn primitives.
     * @param applyDefaultAttributes
     */
    function SVGDrawer(svgElementName, className) {
        this._root = d3.select(document.createElementNS("http://www.w3.org/2000/svg", "g"));
        this._className = className;
        this._svgElementName = svgElementName;
    }
    SVGDrawer.prototype.draw = function (data, appliedDrawSteps) {
        var _this = this;
        /*
         * Draw to the DOM by clearing old DOM elements, adding new DOM elements,
         * and then passing those DOM elements to the animator, which will set the
         * appropriate attributes on the DOM.
         */
        this._createAndDestroyDOMElements(data);
        var delay = 0;
        var drawLength = appliedDrawSteps.length;
        var _loop_1 = function (i) {
            var drawStep = appliedDrawSteps[i];
            Utils.Window.setTimeout(function () { return _this._drawStep(drawStep); }, delay);
            delay += drawStep.animator.totalTime(data.length);
        };
        for (var i = 0; i < drawLength; i++) {
            _loop_1(i);
        }
    };
    SVGDrawer.prototype.getVisualPrimitives = function () {
        if (this._cachedVisualPrimitivesNodes == null) {
            this._cachedVisualPrimitivesNodes = this._selection.nodes();
        }
        return this._cachedVisualPrimitivesNodes;
    };
    SVGDrawer.prototype.getVisualPrimitiveAtIndex = function (index) {
        if (this._cachedVisualPrimitivesNodeMap == null) {
            return null;
        }
        return this._cachedVisualPrimitivesNodeMap.get(index);
    };
    SVGDrawer.prototype.remove = function () {
        this._root.remove();
    };
    SVGDrawer.prototype.attachTo = function (parent) {
        parent.node().appendChild(this._root.node());
    };
    // public for testing
    SVGDrawer.prototype.getRoot = function () {
        return this._root;
    };
    /**
     * Returns the CSS selector for this Drawer's visual elements.
     */
    SVGDrawer.prototype.selector = function () {
        return this._svgElementName;
    };
    SVGDrawer.prototype._applyDefaultAttributes = function (selection) {
        // subclasses may override
    };
    SVGDrawer.prototype._createAndDestroyDOMElements = function (data) {
        // first store source data index before any filtering takes place
        var mappedData = data.map(function (d, i) { return d != null ? { d: d, i: i } : null; });
        // Whereas canvas renders can cope with null data values, svg renderer
        // attribute accessors assume non-null data values, so we must filter them
        // out. Unfortunately, this means the index passed to each accessor will
        // not necessarily match the index of the datum in the dataset.
        var filteredData = mappedData.filter(function (d) { return d != null; });
        var dataElementsUpdate = this._root.selectAll(this.selector()).data(filteredData);
        this._selection = dataElementsUpdate
            .enter()
            .append(this._svgElementName)
            .merge(dataElementsUpdate);
        dataElementsUpdate.exit().remove();
        // build map of source data index to Element
        var newMap = new Utils.Map();
        this._selection.each(function (dataAndIndex) {
            // TODO optionally attach data attributes to Element
            // this.setAttribute("data-source-data", dataAndIndex.d);
            // this.setAttribute("data-source-index", dataAndIndex.i);
            newMap.set(dataAndIndex.i, this);
        });
        this._cachedVisualPrimitivesNodeMap = newMap;
        this._cachedVisualPrimitivesNodes = null;
        // unwrap data now that elements match their original data index
        this._selection.data(this._selection.data().map(function (_a) {
            var d = _a.d;
            return d;
        }));
        if (this._className != null) {
            this._selection.classed(this._className, true);
        }
        this._applyDefaultAttributes(this._selection);
    };
    /**
     * Draws data using one step
     *
     * @param{AppliedDrawStep} step The step, how data should be drawn.
     */
    SVGDrawer.prototype._drawStep = function (step) {
        var _this = this;
        var colorAttributes = ["fill", "stroke"];
        colorAttributes.forEach(function (colorAttribute) {
            if (step.attrToAppliedProjector[colorAttribute] != null) {
                _this._selection.attr(colorAttribute, step.attrToAppliedProjector[colorAttribute]);
            }
        });
        step.animator.animate(this._selection, step.attrToAppliedProjector);
        if (this._className != null) {
            this._selection.classed(this._className, true);
        }
    };
    return SVGDrawer;
}());
exports.SVGDrawer = SVGDrawer;

},{"../utils":624,"d3":414}],574:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSymbolCanvasDrawStep = exports.SymbolSVGDrawer = void 0;
var tslib_1 = require("tslib");
var canvasDrawer_1 = require("./canvasDrawer");
var canvasBuffer_1 = require("./canvasBuffer");
var svgDrawer_1 = require("./svgDrawer");
var SymbolSVGDrawer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(SymbolSVGDrawer, _super);
    function SymbolSVGDrawer() {
        return _super.call(this, "path", "symbol") || this;
    }
    return SymbolSVGDrawer;
}(svgDrawer_1.SVGDrawer));
exports.SymbolSVGDrawer = SymbolSVGDrawer;
var SYMBOL_ATTRS = canvasDrawer_1.ContextStyleAttrs.concat(["x", "y"]);
function makeSymbolCanvasDrawStep(dataset, symbolProjector, sizeProjector, stepBuffer) {
    return function (context, data, attrToAppliedProjector) {
        var _a = context.canvas, clientWidth = _a.clientWidth, clientHeight = _a.clientHeight;
        var buffer = (stepBuffer === undefined) ? new canvasBuffer_1.CanvasBuffer(0, 0) : stepBuffer;
        var symbolAccessor = symbolProjector();
        var sizeAccessor = sizeProjector();
        var prevAttrs = null;
        var prevSymbolGenerator = null;
        var prevSymbolSize = null;
        for (var index = 0; index < data.length; index++) {
            var datum = data[index];
            if (datum == null) {
                continue;
            }
            // check symbol is in viewport
            var attrs = (0, canvasDrawer_1.resolveAttributes)(attrToAppliedProjector, SYMBOL_ATTRS, datum, index);
            var symbolSize = sizeAccessor(datum, index, dataset);
            if (!squareOverlapsBounds(clientWidth, clientHeight, attrs["x"], attrs["y"], symbolSize)) {
                continue;
            }
            // check attributes and symbol type
            var attrsSame = isAttributeValuesEqual(prevAttrs, attrs, canvasDrawer_1.ContextStyleAttrs);
            var symbolGenerator = symbolAccessor(datum, index, dataset);
            if (attrsSame && prevSymbolSize == symbolSize && prevSymbolGenerator == symbolGenerator) {
                // no-op;
            }
            else {
                // make room for bigger symbol if needed
                var strokeWidth = (0, canvasDrawer_1.getStrokeWidth)(attrs);
                // +1 to account for subpixel aliasing
                var wantedBufferSize = symbolSize + strokeWidth + 1;
                if (wantedBufferSize > buffer.screenWidth || wantedBufferSize > buffer.screenHeight) {
                    buffer.resize(wantedBufferSize, wantedBufferSize, true);
                }
                // draw actual symbol into buffer
                buffer.clear();
                var bufferCtx = buffer.ctx;
                bufferCtx.beginPath();
                symbolGenerator(symbolSize).context(bufferCtx)(null);
                bufferCtx.closePath();
                (0, canvasDrawer_1.renderPathWithStyle)(bufferCtx, attrs);
                // save the values that are in the buffer
                prevSymbolGenerator = symbolGenerator;
                prevSymbolSize = symbolSize;
                prevAttrs = attrs;
            }
            // blit the buffer to the canvas
            buffer.blitCenter(context, attrs["x"], attrs["y"]);
        }
    };
}
exports.makeSymbolCanvasDrawStep = makeSymbolCanvasDrawStep;
function squareOverlapsBounds(width, height, x, y, size) {
    return (x + size >= 0 && x - size <= width &&
        y + size >= 0 && y - size <= height);
}
function isAttributeValuesEqual(prevAttrs, attrs, attrKeys) {
    if (prevAttrs == null) {
        return false;
    }
    for (var i = 0; i < attrKeys.length; i++) {
        var attrKey = attrKeys[i];
        if (prevAttrs[attrKey] != attrs[attrKey]) {
            return false;
        }
    }
    return true;
}

},{"./canvasBuffer":565,"./canvasDrawer":566,"./svgDrawer":573,"tslib":635}],575:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.version = exports.TimeInterval = exports.Utils = exports.Scales = exports.Plots = exports.Interactions = exports.Drawers = exports.Dispatchers = exports.SymbolFactories = exports.RenderPolicies = exports.RenderController = exports.Formatters = exports.Configs = exports.Components = exports.Axes = exports.Animators = void 0;
var tslib_1 = require("tslib");
// HACKHACK d3-selection-multi doesn't play well with default "d3" package in a
// bundler environment (e.g. webpack) - see https://github.com/d3/d3-selection-multi/issues/11
// we add it manually to the default "d3" bundle
require("./utils/addD3SelectionMulti");
var Animators = require("./animators");
exports.Animators = Animators;
var Axes = require("./axes");
exports.Axes = Axes;
var Components = require("./components");
exports.Components = Components;
var Configs = require("./core/config");
exports.Configs = Configs;
var Formatters = require("./core/formatters");
exports.Formatters = Formatters;
var RenderController = require("./core/renderController");
exports.RenderController = RenderController;
var RenderPolicies = require("./core/renderPolicy");
exports.RenderPolicies = RenderPolicies;
var SymbolFactories = require("./core/symbolFactories");
exports.SymbolFactories = SymbolFactories;
var Dispatchers = require("./dispatchers");
exports.Dispatchers = Dispatchers;
var Drawers = require("./drawers");
exports.Drawers = Drawers;
var Interactions = require("./interactions");
exports.Interactions = Interactions;
var Plots = require("./plots");
exports.Plots = Plots;
var Scales = require("./scales");
exports.Scales = Scales;
var Utils = require("./utils");
exports.Utils = Utils;
(0, tslib_1.__exportStar)(require("./animators/animator"), exports);
(0, tslib_1.__exportStar)(require("./axes/axis"), exports);
var timeAxis_1 = require("./axes/timeAxis");
Object.defineProperty(exports, "TimeInterval", { enumerable: true, get: function () { return timeAxis_1.TimeInterval; } });
(0, tslib_1.__exportStar)(require("./components/component"), exports);
(0, tslib_1.__exportStar)(require("./components/componentContainer"), exports);
(0, tslib_1.__exportStar)(require("./core/dataset"), exports);
(0, tslib_1.__exportStar)(require("./core/interfaces"), exports);
var version_1 = require("./core/version");
Object.defineProperty(exports, "version", { enumerable: true, get: function () { return version_1.version; } });
(0, tslib_1.__exportStar)(require("./dispatchers/dispatcher"), exports);
(0, tslib_1.__exportStar)(require("./drawers/drawer"), exports);
(0, tslib_1.__exportStar)(require("./interactions/interaction"), exports);
(0, tslib_1.__exportStar)(require("./interactions/keyInteraction"), exports);
(0, tslib_1.__exportStar)(require("./plots/xyPlot"), exports);
(0, tslib_1.__exportStar)(require("./plots/plot"), exports);
(0, tslib_1.__exportStar)(require("./scales/quantitativeScale"), exports);
(0, tslib_1.__exportStar)(require("./scales/scale"), exports);

},{"./animators":525,"./animators/animator":523,"./axes":529,"./axes/axis":527,"./axes/timeAxis":531,"./components":539,"./components/component":532,"./components/componentContainer":533,"./core/config":549,"./core/dataset":550,"./core/formatters":551,"./core/interfaces":552,"./core/renderController":553,"./core/renderPolicy":554,"./core/symbolFactories":555,"./core/version":556,"./dispatchers":558,"./dispatchers/dispatcher":557,"./drawers":569,"./drawers/drawer":568,"./interactions":578,"./interactions/interaction":579,"./interactions/keyInteraction":580,"./plots":594,"./plots/plot":597,"./plots/xyPlot":604,"./scales":607,"./scales/quantitativeScale":612,"./scales/scale":613,"./utils":624,"./utils/addD3SelectionMulti":616,"tslib":635}],576:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Click = void 0;
var tslib_1 = require("tslib");
var Dispatchers = require("../dispatchers");
var Utils = require("../utils");
var interaction_1 = require("./interaction");
var Click = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Click, _super);
    function Click() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._clickedDown = false;
        _this._doubleClicking = false;
        _this._onClickCallbacks = new Utils.CallbackSet();
        _this._onDoubleClickCallbacks = new Utils.CallbackSet();
        /**
         * Note: we bind to mousedown, mouseup, touchstart and touchend because browsers
         * have a 300ms delay between touchstart and click to allow for scrolling cancelling etc.
         */
        _this._mouseDownCallback = function (p, event) { return _this._handleClickDown(p, event); };
        _this._mouseUpCallback = function (p, event) { return _this._handleClickUp(p, event); };
        _this._dblClickCallback = function (p, event) { return _this._handleDblClick(p, event); };
        _this._touchStartCallback = function (ids, idToPoint, event) { return _this._handleClickDown(idToPoint[ids[0]], event); };
        _this._touchEndCallback = function (ids, idToPoint, event) { return _this._handleClickUp(idToPoint[ids[0]], event); };
        _this._touchCancelCallback = function (ids, idToPoint) { return _this._clickedDown = false; };
        return _this;
    }
    Click.prototype._anchor = function (component) {
        _super.prototype._anchor.call(this, component);
        this._mouseDispatcher = Dispatchers.Mouse.getDispatcher(component);
        this._mouseDispatcher.onMouseDown(this._mouseDownCallback);
        this._mouseDispatcher.onMouseUp(this._mouseUpCallback);
        this._mouseDispatcher.onDblClick(this._dblClickCallback);
        this._touchDispatcher = Dispatchers.Touch.getDispatcher(component);
        this._touchDispatcher.onTouchStart(this._touchStartCallback);
        this._touchDispatcher.onTouchEnd(this._touchEndCallback);
        this._touchDispatcher.onTouchCancel(this._touchCancelCallback);
    };
    Click.prototype._unanchor = function () {
        _super.prototype._unanchor.call(this);
        this._mouseDispatcher.offMouseDown(this._mouseDownCallback);
        this._mouseDispatcher.offMouseUp(this._mouseUpCallback);
        this._mouseDispatcher.offDblClick(this._dblClickCallback);
        this._mouseDispatcher = null;
        this._touchDispatcher.offTouchStart(this._touchStartCallback);
        this._touchDispatcher.offTouchEnd(this._touchEndCallback);
        this._touchDispatcher.offTouchCancel(this._touchCancelCallback);
        this._touchDispatcher = null;
    };
    Click.prototype._handleClickDown = function (p, event) {
        var translatedP = this._translateToComponentSpace(p);
        if (this._isInsideComponent(translatedP)) {
            this._clickedDown = true;
            this._clickedPoint = translatedP;
        }
    };
    Click.prototype._handleClickUp = function (p, event) {
        var _this = this;
        var translatedP = this._translateToComponentSpace(p);
        if (this._clickedDown && Click._pointsEqual(translatedP, this._clickedPoint)) {
            setTimeout(function () {
                if (!_this._doubleClicking) {
                    _this._onClickCallbacks.callCallbacks(translatedP, event);
                }
            }, 0);
        }
        this._clickedDown = false;
    };
    Click.prototype._handleDblClick = function (p, event) {
        var _this = this;
        var translatedP = this._translateToComponentSpace(p);
        this._doubleClicking = true;
        this._onDoubleClickCallbacks.callCallbacks(translatedP, event);
        setTimeout(function () { return _this._doubleClicking = false; }, 0);
    };
    Click._pointsEqual = function (p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    };
    /**
     * Adds a callback to be called when the Component is clicked.
     *
     * @param {ClickCallback} callback
     * @return {Interactions.Click} The calling Click Interaction.
     */
    Click.prototype.onClick = function (callback) {
        this._onClickCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the Component is clicked.
     *
     * @param {ClickCallback} callback
     * @return {Interactions.Click} The calling Click Interaction.
     */
    Click.prototype.offClick = function (callback) {
        this._onClickCallbacks.delete(callback);
        return this;
    };
    /**
     * Adds a callback to be called when the Component is double-clicked.
     *
     * @param {ClickCallback} callback
     * @return {Interactions.Click} The calling Click Interaction.
     */
    Click.prototype.onDoubleClick = function (callback) {
        this._onDoubleClickCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the Component is double-clicked.
     *
     * @param {ClickCallback} callback
     * @return {Interactions.Click} The calling Click Interaction.
     */
    Click.prototype.offDoubleClick = function (callback) {
        this._onDoubleClickCallbacks.delete(callback);
        return this;
    };
    return Click;
}(interaction_1.Interaction));
exports.Click = Click;

},{"../dispatchers":558,"../utils":624,"./interaction":579,"tslib":635}],577:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Drag = void 0;
var tslib_1 = require("tslib");
var Dispatchers = require("../dispatchers");
var Utils = require("../utils");
var interaction_1 = require("./interaction");
var Drag = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Drag, _super);
    function Drag(mouseButton) {
        var _this = _super.call(this) || this;
        _this._dragging = false;
        _this._constrainedToComponent = true;
        /**
         * Only emit events when the mouseFilter is true for the source mouse
         * events. Use this to define custom filters (e.g. only right click,
         * require shift to be held down, etc.)
         */
        _this._mouseFilter = Drag._DEFAULT_MOUSE_FILTER;
        _this._dragStartCallbacks = new Utils.CallbackSet();
        _this._dragCallbacks = new Utils.CallbackSet();
        _this._dragEndCallbacks = new Utils.CallbackSet();
        _this._mouseDownCallback = function (p, e) { return _this._startDrag(p, e); };
        _this._mouseMoveCallback = function (p, e) { return _this._doDrag(p, e); };
        _this._mouseUpCallback = function (p, e) { return _this._endDrag(p, e); };
        _this._touchStartCallback = function (ids, idToPoint, e) { return _this._startDrag(idToPoint[ids[0]], e); };
        _this._touchMoveCallback = function (ids, idToPoint, e) { return _this._doDrag(idToPoint[ids[0]], e); };
        _this._touchEndCallback = function (ids, idToPoint, e) { return _this._endDrag(idToPoint[ids[0]], e); };
        _this._mouseButton = mouseButton !== undefined ? mouseButton : 0;
        return _this;
    }
    Drag.prototype._anchor = function (component) {
        _super.prototype._anchor.call(this, component);
        this._mouseDispatcher = Dispatchers.Mouse.getDispatcher(this._componentAttachedTo);
        this._mouseDispatcher.onMouseDown(this._mouseDownCallback);
        this._mouseDispatcher.onMouseMove(this._mouseMoveCallback);
        this._mouseDispatcher.onMouseUp(this._mouseUpCallback);
        this._touchDispatcher = Dispatchers.Touch.getDispatcher(this._componentAttachedTo);
        this._touchDispatcher.onTouchStart(this._touchStartCallback);
        this._touchDispatcher.onTouchMove(this._touchMoveCallback);
        this._touchDispatcher.onTouchEnd(this._touchEndCallback);
    };
    Drag.prototype._unanchor = function () {
        _super.prototype._unanchor.call(this);
        this._mouseDispatcher.offMouseDown(this._mouseDownCallback);
        this._mouseDispatcher.offMouseMove(this._mouseMoveCallback);
        this._mouseDispatcher.offMouseUp(this._mouseUpCallback);
        this._mouseDispatcher = null;
        this._touchDispatcher.offTouchStart(this._touchStartCallback);
        this._touchDispatcher.offTouchMove(this._touchMoveCallback);
        this._touchDispatcher.offTouchEnd(this._touchEndCallback);
        this._touchDispatcher = null;
    };
    Drag.prototype._translateAndConstrain = function (p) {
        var translatedP = this._translateToComponentSpace(p);
        if (!this._constrainedToComponent) {
            return translatedP;
        }
        return {
            x: Utils.Math.clamp(translatedP.x, 0, this._componentAttachedTo.width()),
            y: Utils.Math.clamp(translatedP.y, 0, this._componentAttachedTo.height()),
        };
    };
    Drag.prototype._startDrag = function (point, event) {
        if (event instanceof MouseEvent && !this._mouseFilter(event)) {
            return;
        }
        var translatedP = this._translateToComponentSpace(point);
        if (this._isInsideComponent(translatedP)) {
            event.preventDefault();
            this._dragging = true;
            this._dragOrigin = translatedP;
            this._dragStartCallbacks.callCallbacks(this._dragOrigin);
        }
    };
    Drag.prototype._doDrag = function (point, event) {
        if (this._dragging) {
            this._dragCallbacks.callCallbacks(this._dragOrigin, this._translateAndConstrain(point));
        }
    };
    Drag.prototype._endDrag = function (point, event) {
        if (event instanceof MouseEvent && event.button !== this._mouseButton) {
            return;
        }
        if (this._dragging) {
            this._dragging = false;
            this._dragEndCallbacks.callCallbacks(this._dragOrigin, this._translateAndConstrain(point));
        }
    };
    Drag.prototype.constrainedToComponent = function (constrainedToComponent) {
        if (constrainedToComponent == null) {
            return this._constrainedToComponent;
        }
        this._constrainedToComponent = constrainedToComponent;
        return this;
    };
    Drag.prototype.mouseFilter = function (filter) {
        if (arguments.length === 0) {
            return this._mouseFilter;
        }
        this._mouseFilter = filter;
        return this;
    };
    /**
     * Adds a callback to be called when dragging starts.
     *
     * @param {DragCallback} callback
     * @returns {Drag} The calling Drag Interaction.
     */
    Drag.prototype.onDragStart = function (callback) {
        this._dragStartCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when dragging starts.
     *
     * @param {DragCallback} callback
     * @returns {Drag} The calling Drag Interaction.
     */
    Drag.prototype.offDragStart = function (callback) {
        this._dragStartCallbacks.delete(callback);
        return this;
    };
    /**
     * Adds a callback to be called during dragging.
     *
     * @param {DragCallback} callback
     * @returns {Drag} The calling Drag Interaction.
     */
    Drag.prototype.onDrag = function (callback) {
        this._dragCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called during dragging.
     *
     * @param {DragCallback} callback
     * @returns {Drag} The calling Drag Interaction.
     */
    Drag.prototype.offDrag = function (callback) {
        this._dragCallbacks.delete(callback);
        return this;
    };
    /**
     * Adds a callback to be called when dragging ends.
     *
     * @param {DragCallback} callback
     * @returns {Drag} The calling Drag Interaction.
     */
    Drag.prototype.onDragEnd = function (callback) {
        this._dragEndCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when dragging ends.
     *
     * @param {DragCallback} callback
     * @returns {Drag} The calling Drag Interaction.
     */
    Drag.prototype.offDragEnd = function (callback) {
        this._dragEndCallbacks.delete(callback);
        return this;
    };
    Drag._DEFAULT_MOUSE_FILTER = function (event) { return event.button === 0; };
    return Drag;
}(interaction_1.Interaction));
exports.Drag = Drag;

},{"../dispatchers":558,"../utils":624,"./interaction":579,"tslib":635}],578:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.zoomOut = void 0;
var tslib_1 = require("tslib");
(0, tslib_1.__exportStar)(require("./clickInteraction"), exports);
(0, tslib_1.__exportStar)(require("./dragInteraction"), exports);
(0, tslib_1.__exportStar)(require("./keyInteraction"), exports);
(0, tslib_1.__exportStar)(require("./panZoomInteraction"), exports);
(0, tslib_1.__exportStar)(require("./pointerInteraction"), exports);
var panZoomConstraints_1 = require("./panZoomConstraints");
Object.defineProperty(exports, "zoomOut", { enumerable: true, get: function () { return panZoomConstraints_1.zoomOut; } });

},{"./clickInteraction":576,"./dragInteraction":577,"./keyInteraction":580,"./panZoomConstraints":581,"./panZoomInteraction":582,"./pointerInteraction":583,"tslib":635}],579:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interaction = void 0;
var Interaction = /** @class */ (function () {
    function Interaction() {
        var _this = this;
        this._anchorCallback = function (component) { return _this._anchor(component); };
        this._enabled = true;
    }
    /**
     * Attaches this Interaction to a Component.
     * If the Interaction was already attached to a Component, it first detaches itself from the old Component.
     *
     * @param {Component} component
     * @returns {Interaction} The calling Interaction.
     */
    Interaction.prototype.attachTo = function (component) {
        this._disconnect();
        this._componentAttachedTo = component;
        this._connect();
        return this;
    };
    /**
     * @deprecated renamed to .detach().
     */
    Interaction.prototype.detachFrom = function (_component) {
        return this.detach();
    };
    /**
     * Detaches this Interaction from whatever component it was attached to.
     * This Interaction can be reused.
     *
     * @returns {Interaction} The calling Interaction.
     */
    Interaction.prototype.detach = function () {
        this._disconnect();
        this._componentAttachedTo = null;
        return this;
    };
    Interaction.prototype.enabled = function (enabled) {
        if (enabled == null) {
            return this._enabled;
        }
        this._enabled = enabled;
        if (this._enabled) {
            this._connect();
        }
        else {
            this._disconnect();
        }
        return this;
    };
    Interaction.prototype._anchor = function (component) {
        this._isAnchored = true;
    };
    Interaction.prototype._unanchor = function () {
        this._isAnchored = false;
    };
    /**
     * Translates an <svg>-coordinate-space point to Component-space coordinates.
     *
     * @param {Point} p A Point in <svg>-space coordinates.
     * @return {Point} The same location in Component-space coordinates.
     */
    Interaction.prototype._translateToComponentSpace = function (p) {
        var origin = this._componentAttachedTo.originToRoot();
        return {
            x: p.x - origin.x,
            y: p.y - origin.y,
        };
    };
    /**
     * Checks whether a Component-coordinate-space Point is inside the Component.
     *
     * @param {Point} p A Point in Compoennt-space coordinates.
     * @return {boolean} Whether or not the point is inside the Component.
     */
    Interaction.prototype._isInsideComponent = function (p) {
        return 0 <= p.x && 0 <= p.y
            && p.x <= this._componentAttachedTo.width()
            && p.y <= this._componentAttachedTo.height();
    };
    Interaction.prototype._connect = function () {
        if (this.enabled() && this._componentAttachedTo != null && !this._isAnchored) {
            this._componentAttachedTo.onAnchor(this._anchorCallback);
        }
    };
    Interaction.prototype._disconnect = function () {
        if (this._isAnchored) {
            this._unanchor();
        }
        if (this._componentAttachedTo != null) {
            this._componentAttachedTo.offAnchor(this._anchorCallback);
        }
    };
    return Interaction;
}());
exports.Interaction = Interaction;

},{}],580:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Key = void 0;
var tslib_1 = require("tslib");
var Dispatchers = require("../dispatchers");
var Utils = require("../utils");
var interaction_1 = require("./interaction");
var Key = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Key, _super);
    function Key() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._keyPressCallbacks = {};
        _this._keyReleaseCallbacks = {};
        _this._mouseMoveCallback = function (point) { return false; }; // HACKHACK: registering a listener
        _this._downedKeys = new Utils.Set();
        _this._keyDownCallback = function (keyCode, event) { return _this._handleKeyDownEvent(keyCode, event); };
        _this._keyUpCallback = function (keyCode) { return _this._handleKeyUpEvent(keyCode); };
        return _this;
    }
    Key.prototype._anchor = function (component) {
        _super.prototype._anchor.call(this, component);
        this._positionDispatcher = Dispatchers.Mouse.getDispatcher(this._componentAttachedTo);
        this._positionDispatcher.onMouseMove(this._mouseMoveCallback);
        this._keyDispatcher = Dispatchers.Key.getDispatcher();
        this._keyDispatcher.onKeyDown(this._keyDownCallback);
        this._keyDispatcher.onKeyUp(this._keyUpCallback);
    };
    Key.prototype._unanchor = function () {
        _super.prototype._unanchor.call(this);
        this._positionDispatcher.offMouseMove(this._mouseMoveCallback);
        this._positionDispatcher = null;
        this._keyDispatcher.offKeyDown(this._keyDownCallback);
        this._keyDispatcher.offKeyUp(this._keyUpCallback);
        this._keyDispatcher = null;
    };
    Key.prototype._handleKeyDownEvent = function (keyCode, event) {
        var p = this._translateToComponentSpace(this._positionDispatcher.lastMousePosition());
        if (this._isInsideComponent(p) && !event.repeat) {
            if (this._keyPressCallbacks[keyCode]) {
                this._keyPressCallbacks[keyCode].callCallbacks(keyCode);
            }
            this._downedKeys.add(keyCode);
        }
    };
    Key.prototype._handleKeyUpEvent = function (keyCode) {
        if (this._downedKeys.has(keyCode) && this._keyReleaseCallbacks[keyCode]) {
            this._keyReleaseCallbacks[keyCode].callCallbacks(keyCode);
        }
        this._downedKeys.delete(keyCode);
    };
    /**
     * Adds a callback to be called when the key with the given keyCode is
     * pressed and the user is moused over the Component.
     *
     * @param {number} keyCode
     * @param {KeyCallback} callback
     * @returns {Interactions.Key} The calling Key Interaction.
     */
    Key.prototype.onKeyPress = function (keyCode, callback) {
        if (!this._keyPressCallbacks[keyCode]) {
            this._keyPressCallbacks[keyCode] = new Utils.CallbackSet();
        }
        this._keyPressCallbacks[keyCode].add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the key with the given keyCode is
     * pressed and the user is moused over the Component.
     *
     * @param {number} keyCode
     * @param {KeyCallback} callback
     * @returns {Interactions.Key} The calling Key Interaction.
     */
    Key.prototype.offKeyPress = function (keyCode, callback) {
        this._keyPressCallbacks[keyCode].delete(callback);
        if (this._keyPressCallbacks[keyCode].size === 0) {
            delete this._keyPressCallbacks[keyCode];
        }
        return this;
    };
    /**
     * Adds a callback to be called when the key with the given keyCode is
     * released if the key was pressed with the mouse inside of the Component.
     *
     * @param {number} keyCode
     * @param {KeyCallback} callback
     * @returns {Interactions.Key} The calling Key Interaction.
     */
    Key.prototype.onKeyRelease = function (keyCode, callback) {
        if (!this._keyReleaseCallbacks[keyCode]) {
            this._keyReleaseCallbacks[keyCode] = new Utils.CallbackSet();
        }
        this._keyReleaseCallbacks[keyCode].add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the key with the given keyCode is
     * released if the key was pressed with the mouse inside of the Component.
     *
     * @param {number} keyCode
     * @param {KeyCallback} callback
     * @returns {Interactions.Key} The calling Key Interaction.
     */
    Key.prototype.offKeyRelease = function (keyCode, callback) {
        this._keyReleaseCallbacks[keyCode].delete(callback);
        if (this._keyReleaseCallbacks[keyCode].size === 0) {
            delete this._keyReleaseCallbacks[keyCode];
        }
        return this;
    };
    return Key;
}(interaction_1.Interaction));
exports.Key = Key;

},{"../dispatchers":558,"../utils":624,"./interaction":579,"tslib":635}],581:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.constrainedTranslation = exports.constrainZoomValues = exports.constrainZoomExtents = exports.constrainedZoom = exports.zoomOut = void 0;
/**
 * Return `value` if its distance to `center` was scaled by `zoom`.
 *
 * e.g. zoomOut(100, 2, 50) -> 150
 * e.g. zoomOut(0, 2, 50) -> -50
 * e.g. zoomOut(100, 0.5, 50) -> 75
 * e.g. zoomOut(0, 0.5, 50) -> 25
 */
function zoomOut(value, zoom, center) {
    return center - (center - value) * zoom;
}
exports.zoomOut = zoomOut;
/**
 * This is the zoomOut method algebra-ed to solve for the `center` value
 * given the other three. The "target" is the return value of zoomOut.
 */
function getZoomOutCenter(value, zoom, target) {
    return (value * zoom - target) / (zoom - 1);
}
/**
 * Return possibly different zoomAmount and centerPoint values such that applying the zoom
 * to the scale respects the given min/max extents and values.
 */
function constrainedZoom(scale, zoomAmount, centerPoint, minDomainExtent, maxDomainExtent, minDomainValue, maxDomainValue) {
    zoomAmount = constrainZoomExtents(scale, zoomAmount, minDomainExtent, maxDomainExtent);
    return constrainZoomValues(scale, zoomAmount, centerPoint, minDomainValue, maxDomainValue);
}
exports.constrainedZoom = constrainedZoom;
function constrainZoomExtents(scale, zoomAmount, minDomainExtent, maxDomainExtent) {
    var extentIncreasing = zoomAmount > 1;
    var boundingDomainExtent = extentIncreasing ? maxDomainExtent : minDomainExtent;
    if (boundingDomainExtent == null) {
        return zoomAmount;
    }
    var _a = scale.getTransformationDomain(), scaleDomainMin = _a[0], scaleDomainMax = _a[1];
    var domainExtent = Math.abs(scaleDomainMax - scaleDomainMin);
    var compareF = extentIncreasing ? Math.min : Math.max;
    return compareF(zoomAmount, boundingDomainExtent / domainExtent);
}
exports.constrainZoomExtents = constrainZoomExtents;
/**
 * Modify zoomAmount and centerPoint such that a panzoom will stay inside
 * the bounds defined by minDomainValue and maxDomainValue.
 */
function constrainZoomValues(scale, zoomAmount, centerPoint, minDomainValue, maxDomainValue) {
    // when zooming in, we don't have to worry about overflowing domain
    if (zoomAmount <= 1) {
        return { centerPoint: centerPoint, zoomAmount: zoomAmount };
    }
    // if no constraints set, we're done
    if (minDomainValue == null && maxDomainValue == null) {
        return { centerPoint: centerPoint, zoomAmount: zoomAmount };
    }
    var rangeReversed = isRangeReversed(scale);
    var domainReversed = isDomainReversed(scale);
    var defaultDomainMin = domainReversed ? Infinity : -Infinity;
    var defaultDomainMax = domainReversed ? -Infinity : Infinity;
    minDomainValue = minDomainValue == null ? defaultDomainMin : minDomainValue;
    maxDomainValue = maxDomainValue == null ? defaultDomainMax : maxDomainValue;
    var _a = scale.getTransformationDomain(), scaleDomainMin = _a[0], scaleDomainMax = _a[1];
    var maxRange = scale.scaleTransformation(maxDomainValue);
    var currentMaxRange = scale.scaleTransformation(scaleDomainMax);
    var newMaxRange = zoomOut(currentMaxRange, zoomAmount, centerPoint);
    var minRange = scale.scaleTransformation(minDomainValue);
    var currentMinRange = scale.scaleTransformation(scaleDomainMin);
    var newMinRange = zoomOut(currentMinRange, zoomAmount, centerPoint);
    var minMaxLength = Math.abs(maxRange - minRange);
    var newRangeLength = Math.abs(newMaxRange - newMinRange);
    if (newRangeLength > minMaxLength) {
        // The new zoom simply won't fit. Instead just set the zoom amount to a full zoom out.
        var wantedZoomAmount = (maxRange - minRange) / (currentMaxRange - currentMinRange);
        if (wantedZoomAmount !== 1) {
            // only solve for centerPoint if wantedZoomAmount isn't 1 to prevent NaN.
            var wantedCenterPoint = getZoomOutCenter(currentMaxRange, wantedZoomAmount, maxRange);
            return {
                centerPoint: wantedCenterPoint,
                zoomAmount: wantedZoomAmount,
            };
        }
        else {
            // the centerPoint doesn't matter at all here but we must include it
            return {
                centerPoint: centerPoint,
                zoomAmount: wantedZoomAmount,
            };
        }
    }
    else {
        // the zoom does fit, but one end is outside. In this case just nudge the edge in
        if (newMaxRange > maxRange != rangeReversed) {
            // prevent out of bounds on max edge.
            return {
                centerPoint: getZoomOutCenter(currentMaxRange, zoomAmount, maxRange),
                zoomAmount: zoomAmount,
            };
        }
        else if (newMinRange < minRange != rangeReversed) {
            // prevent out of bounds on min edge.
            return {
                centerPoint: getZoomOutCenter(currentMinRange, zoomAmount, minRange),
                zoomAmount: zoomAmount,
            };
        }
        else {
            return { centerPoint: centerPoint, zoomAmount: zoomAmount };
        }
    }
}
exports.constrainZoomValues = constrainZoomValues;
/**
 * Returns a new translation value that respects domain min/max value
 * constraints.
 */
function constrainedTranslation(scale, translation, minDomainValue, maxDomainValue) {
    var _a = scale.getTransformationDomain(), scaleDomainMin = _a[0], scaleDomainMax = _a[1];
    var reversed = isRangeReversed(scale);
    if (translation > 0 !== reversed) {
        var bound = maxDomainValue;
        if (bound != null) {
            var currentMaxRange = scale.scaleTransformation(scaleDomainMax);
            var maxRange = scale.scaleTransformation(bound);
            translation = (reversed ? Math.max : Math.min)(currentMaxRange + translation, maxRange) - currentMaxRange;
        }
    }
    else {
        var bound = minDomainValue;
        if (bound != null) {
            var currentMinRange = scale.scaleTransformation(scaleDomainMin);
            var minRange = scale.scaleTransformation(bound);
            translation = (reversed ? Math.min : Math.max)(currentMinRange + translation, minRange) - currentMinRange;
        }
    }
    return translation;
}
exports.constrainedTranslation = constrainedTranslation;
/**
 * Returns true iff the scale.range[1] < scale.range[0].
 */
function isRangeReversed(scale) {
    var range = scale.range();
    return range[1] < range[0];
}
function isDomainReversed(scale) {
    var domain = scale.getTransformationDomain();
    return domain[1] < domain[0];
}

},{}],582:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PanZoom = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Dispatchers = require("../dispatchers");
var Scales = require("../scales");
var Utils = require("../utils");
var Interactions = require("./");
var interaction_1 = require("./interaction");
var panZoomConstraints_1 = require("./panZoomConstraints");
var PanZoom = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(PanZoom, _super);
    /**
     * A PanZoom Interaction updates the domains of an x-scale and/or a y-scale
     * in response to the user panning or zooming.
     *
     * @constructor
     * @param {TransformableScale} [xScale] The x-scale to update on panning/zooming.
     * @param {TransformableScale} [yScale] The y-scale to update on panning/zooming.
     */
    function PanZoom(xScale, yScale) {
        var _this = _super.call(this) || this;
        _this._wheelFilter = function (e) { return true; };
        _this._wheelCallback = function (p, e) { return _this._handleWheelEvent(p, e); };
        _this._touchStartCallback = function (ids, idToPoint, e) { return _this._handleTouchStart(ids, idToPoint, e); };
        _this._touchMoveCallback = function (ids, idToPoint, e) { return _this._handlePinch(ids, idToPoint, e); };
        _this._touchEndCallback = function (ids, idToPoint, e) { return _this._handleTouchEnd(ids, idToPoint, e); };
        _this._touchCancelCallback = function (ids, idToPoint, e) { return _this._handleTouchEnd(ids, idToPoint, e); };
        _this._panEndCallbacks = new Utils.CallbackSet();
        _this._zoomEndCallbacks = new Utils.CallbackSet();
        _this._panZoomUpdateCallbacks = new Utils.CallbackSet();
        _this._xScales = new Utils.Set();
        _this._yScales = new Utils.Set();
        _this._dragInteraction = new Interactions.Drag();
        _this._setupDragInteraction();
        _this._touchIds = d3.map();
        _this._minDomainExtents = new Utils.Map();
        _this._maxDomainExtents = new Utils.Map();
        _this._minDomainValues = new Utils.Map();
        _this._maxDomainValues = new Utils.Map();
        if (xScale != null) {
            _this.addXScale(xScale);
        }
        if (yScale != null) {
            _this.addYScale(yScale);
        }
        return _this;
    }
    /**
     * Get the backing drag interaction. Useful to customize the panzoom interaction.
     * @returns {Drag}
     */
    PanZoom.prototype.dragInteraction = function () {
        return this._dragInteraction;
    };
    PanZoom.prototype.wheelFilter = function (filter) {
        if (arguments.length === 0) {
            return this._wheelFilter;
        }
        this._wheelFilter = filter;
        return this;
    };
    /**
     * Pans the chart by a specified amount
     *
     * @param {Plottable.Point} [translateAmount] The amount by which to translate the x and y scales.
     */
    PanZoom.prototype.pan = function (translateAmount) {
        var _this = this;
        this.xScales().forEach(function (xScale) {
            xScale.pan(_this._constrainedTranslation(xScale, translateAmount.x));
        });
        this.yScales().forEach(function (yScale) {
            yScale.pan(_this._constrainedTranslation(yScale, translateAmount.y));
        });
        this._panZoomUpdateCallbacks.callCallbacks();
    };
    /**
     * Zooms the chart by a specified amount around a specific point
     *
     * @param {number} [zoomAmount] The percentage by which to zoom the x and y scale.
     * A value of 0.9 zooms in by 10%. A value of 1.1 zooms out by 10%. A value of 1 has
     * no effect.
     * @param {Plottable.Point} [centerValue] The center in pixels around which to zoom.
     * By default, `centerValue` is the center of the x and y range of each scale.
     * @param {boolean} [constrained] Whether to respect the zoom extents and min/max
     * values. Default true.
     */
    PanZoom.prototype.zoom = function (zoomAmount, centerValue, constrained) {
        var _this = this;
        if (constrained === void 0) { constrained = true; }
        var centerX;
        var centerY;
        if (centerValue != null) {
            centerX = centerValue.x;
            centerY = centerValue.y;
            if (constrained) {
                this.xScales().forEach(function (xScale) {
                    var constrained = _this._constrainedZoom(xScale, zoomAmount, centerX);
                    centerX = constrained.centerPoint;
                    zoomAmount = constrained.zoomAmount;
                });
                this.yScales().forEach(function (yScale) {
                    var constrained = _this._constrainedZoom(yScale, zoomAmount, centerY);
                    centerY = constrained.centerPoint;
                    zoomAmount = constrained.zoomAmount;
                });
            }
        }
        this.xScales().forEach(function (xScale) {
            var range = xScale.range();
            var xCenter = centerX == null
                ? (range[1] + range[0]) / 2
                : centerX;
            xScale.zoom(zoomAmount, xCenter);
        });
        this.yScales().forEach(function (yScale) {
            var range = yScale.range();
            var yCenter = centerY == null
                ? (range[1] + range[0]) / 2
                : centerY;
            yScale.zoom(zoomAmount, yCenter);
        });
        this._panZoomUpdateCallbacks.callCallbacks();
        return { zoomAmount: zoomAmount, centerValue: { centerX: centerX, centerY: centerY } };
    };
    PanZoom.prototype._anchor = function (component) {
        _super.prototype._anchor.call(this, component);
        this._dragInteraction.attachTo(component);
        this._mouseDispatcher = Dispatchers.Mouse.getDispatcher(this._componentAttachedTo);
        this._mouseDispatcher.onWheel(this._wheelCallback);
        this._touchDispatcher = Dispatchers.Touch.getDispatcher(this._componentAttachedTo);
        this._touchDispatcher.onTouchStart(this._touchStartCallback);
        this._touchDispatcher.onTouchMove(this._touchMoveCallback);
        this._touchDispatcher.onTouchEnd(this._touchEndCallback);
        this._touchDispatcher.onTouchCancel(this._touchCancelCallback);
    };
    PanZoom.prototype._unanchor = function () {
        _super.prototype._unanchor.call(this);
        this._mouseDispatcher.offWheel(this._wheelCallback);
        this._mouseDispatcher = null;
        this._touchDispatcher.offTouchStart(this._touchStartCallback);
        this._touchDispatcher.offTouchMove(this._touchMoveCallback);
        this._touchDispatcher.offTouchEnd(this._touchEndCallback);
        this._touchDispatcher.offTouchCancel(this._touchCancelCallback);
        this._touchDispatcher = null;
        this._dragInteraction.detach();
    };
    PanZoom.prototype._handleTouchStart = function (ids, idToPoint, e) {
        for (var i = 0; i < ids.length && this._touchIds.size() < 2; i++) {
            var id = ids[i];
            this._touchIds.set(id.toString(), this._translateToComponentSpace(idToPoint[id]));
        }
    };
    PanZoom.prototype._handlePinch = function (ids, idToPoint, e) {
        var _this = this;
        if (this._touchIds.size() < 2) {
            return;
        }
        var oldPoints = this._touchIds.values();
        if (!this._isInsideComponent(this._translateToComponentSpace(oldPoints[0])) || !this._isInsideComponent(this._translateToComponentSpace(oldPoints[1]))) {
            return;
        }
        var oldCornerDistance = PanZoom._pointDistance(oldPoints[0], oldPoints[1]);
        if (oldCornerDistance === 0) {
            return;
        }
        ids.forEach(function (id) {
            if (_this._touchIds.has(id.toString())) {
                _this._touchIds.set(id.toString(), _this._translateToComponentSpace(idToPoint[id]));
            }
        });
        var points = this._touchIds.values();
        var newCornerDistance = PanZoom._pointDistance(points[0], points[1]);
        if (newCornerDistance === 0) {
            return;
        }
        var initMagnifyAmount = oldCornerDistance / newCornerDistance;
        var normalizedPointDiffs = points.map(function (point, i) {
            return {
                x: (point.x - oldPoints[i].x) / initMagnifyAmount,
                y: (point.y - oldPoints[i].y) / initMagnifyAmount,
            };
        });
        var oldCenterPoint = PanZoom.centerPoint(oldPoints[0], oldPoints[1]);
        var _a = this.zoom(initMagnifyAmount, oldCenterPoint), centerValue = _a.centerValue, zoomAmount = _a.zoomAmount;
        var centerX = centerValue.centerX, centerY = centerValue.centerY;
        var constrainedPoints = oldPoints.map(function (oldPoint, i) {
            return {
                x: normalizedPointDiffs[i].x * zoomAmount + oldPoint.x,
                y: normalizedPointDiffs[i].y * zoomAmount + oldPoint.y,
            };
        });
        var translateAmount = {
            x: centerX - ((constrainedPoints[0].x + constrainedPoints[1].x) / 2),
            y: centerY - ((constrainedPoints[0].y + constrainedPoints[1].y) / 2),
        };
        this.pan(translateAmount);
    };
    PanZoom.centerPoint = function (point1, point2) {
        var leftX = Math.min(point1.x, point2.x);
        var rightX = Math.max(point1.x, point2.x);
        var topY = Math.min(point1.y, point2.y);
        var bottomY = Math.max(point1.y, point2.y);
        return { x: (leftX + rightX) / 2, y: (bottomY + topY) / 2 };
    };
    PanZoom._pointDistance = function (point1, point2) {
        var leftX = Math.min(point1.x, point2.x);
        var rightX = Math.max(point1.x, point2.x);
        var topY = Math.min(point1.y, point2.y);
        var bottomY = Math.max(point1.y, point2.y);
        return Math.sqrt(Math.pow(rightX - leftX, 2) + Math.pow(bottomY - topY, 2));
    };
    PanZoom.prototype._handleTouchEnd = function (ids, idToPoint, e) {
        var _this = this;
        ids.forEach(function (id) {
            _this._touchIds.remove(id.toString());
        });
        if (this._touchIds.size() > 0) {
            this._zoomEndCallbacks.callCallbacks();
        }
    };
    PanZoom.prototype._handleWheelEvent = function (p, e) {
        if (!this._wheelFilter(e)) {
            return;
        }
        var translatedP = this._translateToComponentSpace(p);
        if (this._isInsideComponent(translatedP)) {
            e.preventDefault();
            // in cases where only horizontal scroll is present, use that in lieu of nothing.
            var deltaAmount = e.deltaY !== 0 ? e.deltaY : e.deltaX;
            var deltaPixelAmount = deltaAmount * (e.deltaMode ? PanZoom._PIXELS_PER_LINE : 1);
            var zoomAmount = Math.pow(2, deltaPixelAmount * .002);
            this.zoom(zoomAmount, translatedP);
            this._zoomEndCallbacks.callCallbacks();
        }
    };
    PanZoom.prototype._constrainedZoom = function (scale, zoomAmount, centerPoint) {
        return (0, panZoomConstraints_1.constrainedZoom)(scale, zoomAmount, centerPoint, this.minDomainExtent(scale), this.maxDomainExtent(scale), this.minDomainValue(scale), this.maxDomainValue(scale));
    };
    PanZoom.prototype._constrainedTranslation = function (scale, translation) {
        return (0, panZoomConstraints_1.constrainedTranslation)(scale, translation, this.minDomainValue(scale), this.maxDomainValue(scale));
    };
    PanZoom.prototype._setupDragInteraction = function () {
        var _this = this;
        this._dragInteraction.constrainedToComponent(false);
        var lastDragPoint;
        this._dragInteraction.onDragStart(function () { return lastDragPoint = null; });
        this._dragInteraction.onDrag(function (startPoint, endPoint) {
            if (_this._touchIds.size() >= 2) {
                return;
            }
            var translateAmount = {
                x: (lastDragPoint == null ? startPoint.x : lastDragPoint.x) - endPoint.x,
                y: (lastDragPoint == null ? startPoint.y : lastDragPoint.y) - endPoint.y,
            };
            _this.pan(translateAmount);
            lastDragPoint = endPoint;
        });
        this._dragInteraction.onDragEnd(function () { return _this._panEndCallbacks.callCallbacks(); });
    };
    PanZoom.prototype._nonLinearScaleWithExtents = function (scale) {
        return this.minDomainExtent(scale) != null && this.maxDomainExtent(scale) != null && !(scale instanceof Scales.Linear) && !(scale instanceof Scales.Time);
    };
    PanZoom.prototype.xScales = function (xScales) {
        var _this = this;
        if (xScales == null) {
            var scales_1 = [];
            this._xScales.forEach(function (xScale) {
                scales_1.push(xScale);
            });
            return scales_1;
        }
        this._xScales = new Utils.Set();
        xScales.forEach(function (xScale) {
            _this.addXScale(xScale);
        });
        return this;
    };
    PanZoom.prototype.yScales = function (yScales) {
        var _this = this;
        if (yScales == null) {
            var scales_2 = [];
            this._yScales.forEach(function (yScale) {
                scales_2.push(yScale);
            });
            return scales_2;
        }
        this._yScales = new Utils.Set();
        yScales.forEach(function (yScale) {
            _this.addYScale(yScale);
        });
        return this;
    };
    /**
     * Adds an x scale to this PanZoom Interaction
     *
     * @param {TransformableScale} An x scale to add
     * @returns {Interactions.PanZoom} The calling PanZoom Interaction.
     */
    PanZoom.prototype.addXScale = function (xScale) {
        this._xScales.add(xScale);
        return this;
    };
    /**
     * Removes an x scale from this PanZoom Interaction
     *
     * @param {TransformableScale} An x scale to remove
     * @returns {Interactions.PanZoom} The calling PanZoom Interaction.
     */
    PanZoom.prototype.removeXScale = function (xScale) {
        this._xScales.delete(xScale);
        this._minDomainExtents.delete(xScale);
        this._maxDomainExtents.delete(xScale);
        this._minDomainValues.delete(xScale);
        this._maxDomainValues.delete(xScale);
        return this;
    };
    /**
     * Adds a y scale to this PanZoom Interaction
     *
     * @param {TransformableScale} A y scale to add
     * @returns {Interactions.PanZoom} The calling PanZoom Interaction.
     */
    PanZoom.prototype.addYScale = function (yScale) {
        this._yScales.add(yScale);
        return this;
    };
    /**
     * Removes a y scale from this PanZoom Interaction
     *
     * @param {TransformableScale} A y scale to remove
     * @returns {Interactions.PanZoom} The calling PanZoom Interaction.
     */
    PanZoom.prototype.removeYScale = function (yScale) {
        this._yScales.delete(yScale);
        this._minDomainExtents.delete(yScale);
        this._maxDomainExtents.delete(yScale);
        this._minDomainValues.delete(yScale);
        this._maxDomainValues.delete(yScale);
        return this;
    };
    PanZoom.prototype.minDomainExtent = function (scale, minDomainExtent) {
        if (minDomainExtent == null) {
            return this._minDomainExtents.get(scale);
        }
        if (minDomainExtent.valueOf() < 0) {
            throw new Error("extent must be non-negative");
        }
        var maxExtentForScale = this.maxDomainExtent(scale);
        if (maxExtentForScale != null && maxExtentForScale.valueOf() < minDomainExtent.valueOf()) {
            throw new Error("minDomainExtent must be smaller than maxDomainExtent for the same Scale");
        }
        if (this._nonLinearScaleWithExtents(scale)) {
            Utils.Window.warn("Panning and zooming with extents on a nonlinear scale may have unintended behavior.");
        }
        this._minDomainExtents.set(scale, minDomainExtent);
        return this;
    };
    PanZoom.prototype.maxDomainExtent = function (scale, maxDomainExtent) {
        if (maxDomainExtent == null) {
            return this._maxDomainExtents.get(scale);
        }
        if (maxDomainExtent.valueOf() <= 0) {
            throw new Error("extent must be positive");
        }
        var minExtentForScale = this.minDomainExtent(scale);
        if (minExtentForScale != null && maxDomainExtent.valueOf() < minExtentForScale.valueOf()) {
            throw new Error("maxDomainExtent must be larger than minDomainExtent for the same Scale");
        }
        if (this._nonLinearScaleWithExtents(scale)) {
            Utils.Window.warn("Panning and zooming with extents on a nonlinear scale may have unintended behavior.");
        }
        this._maxDomainExtents.set(scale, maxDomainExtent);
        return this;
    };
    PanZoom.prototype.minDomainValue = function (scale, minDomainValue) {
        if (minDomainValue == null) {
            return this._minDomainValues.get(scale);
        }
        this._minDomainValues.set(scale, minDomainValue);
        return this;
    };
    PanZoom.prototype.maxDomainValue = function (scale, maxDomainValue) {
        if (maxDomainValue == null) {
            return this._maxDomainValues.get(scale);
        }
        this._maxDomainValues.set(scale, maxDomainValue);
        return this;
    };
    /**
     * Uses the current domain of the scale to apply a minimum and maximum
     * domain value for that scale.
     *
     * This constrains the pan/zoom interaction to show no more than the domain
     * of the scale.
     */
    PanZoom.prototype.setMinMaxDomainValuesTo = function (scale) {
        this._minDomainValues.delete(scale);
        this._maxDomainValues.delete(scale);
        var _a = scale.getTransformationDomain(), domainMin = _a[0], domainMax = _a[1];
        this.minDomainValue(scale, domainMin);
        this.maxDomainValue(scale, domainMax);
        return this;
    };
    /**
     * Adds a callback to be called when panning ends.
     *
     * @param {PanCallback} callback
     * @returns {this} The calling PanZoom Interaction.
     */
    PanZoom.prototype.onPanEnd = function (callback) {
        this._panEndCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when panning ends.
     *
     * @param {PanCallback} callback
     * @returns {this} The calling PanZoom Interaction.
     */
    PanZoom.prototype.offPanEnd = function (callback) {
        this._panEndCallbacks.delete(callback);
        return this;
    };
    /**
     * Adds a callback to be called when zooming ends.
     *
     * @param {ZoomCallback} callback
     * @returns {this} The calling PanZoom Interaction.
     */
    PanZoom.prototype.onZoomEnd = function (callback) {
        this._zoomEndCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when zooming ends.
     *
     * @param {ZoomCallback} callback
     * @returns {this} The calling PanZoom Interaction.
     */
    PanZoom.prototype.offZoomEnd = function (callback) {
        this._zoomEndCallbacks.delete(callback);
        return this;
    };
    /**
     * Adds a callback to be called when any pan or zoom update occurs. This is
     * called on every frame, so be sure your callback is fast.
     *
     * @param {PanZoomUpdateCallback} callback
     * @returns {this} The calling PanZoom Interaction.
     */
    PanZoom.prototype.onPanZoomUpdate = function (callback) {
        this._panZoomUpdateCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when any pan or zoom update occurs.
     *
     * @param {PanZoomUpdateCallback} callback
     * @returns {this} The calling PanZoom Interaction.
     */
    PanZoom.prototype.offPanZoomUpdate = function (callback) {
        this._panZoomUpdateCallbacks.delete(callback);
        return this;
    };
    /**
     * The number of pixels occupied in a line.
     */
    PanZoom._PIXELS_PER_LINE = 120;
    return PanZoom;
}(interaction_1.Interaction));
exports.PanZoom = PanZoom;

},{"../dispatchers":558,"../scales":607,"../utils":624,"./":578,"./interaction":579,"./panZoomConstraints":581,"d3":414,"tslib":635}],583:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pointer = void 0;
var tslib_1 = require("tslib");
var Dispatchers = require("../dispatchers");
var Utils = require("../utils");
var interaction_1 = require("./interaction");
var Pointer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Pointer, _super);
    function Pointer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._overComponent = false;
        _this._pointerEnterCallbacks = new Utils.CallbackSet();
        _this._pointerMoveCallbacks = new Utils.CallbackSet();
        _this._pointerExitCallbacks = new Utils.CallbackSet();
        _this._mouseMoveCallback = function (p, e) { return _this._handleMouseEvent(p, e); };
        _this._touchStartCallback = function (ids, idToPoint, e) { return _this._handleTouchEvent(idToPoint[ids[0]], e); };
        return _this;
    }
    Pointer.prototype._anchor = function (component) {
        _super.prototype._anchor.call(this, component);
        this._mouseDispatcher = Dispatchers.Mouse.getDispatcher(this._componentAttachedTo);
        this._mouseDispatcher.onMouseMove(this._mouseMoveCallback);
        this._touchDispatcher = Dispatchers.Touch.getDispatcher(this._componentAttachedTo);
        this._touchDispatcher.onTouchStart(this._touchStartCallback);
    };
    Pointer.prototype._unanchor = function () {
        _super.prototype._unanchor.call(this);
        this._mouseDispatcher.offMouseMove(this._mouseMoveCallback);
        this._mouseDispatcher = null;
        this._touchDispatcher.offTouchStart(this._touchStartCallback);
        this._touchDispatcher = null;
    };
    Pointer.prototype._handleMouseEvent = function (p, e) {
        var insideSVG = this._mouseDispatcher.eventInside(this._componentAttachedTo, e);
        this._handlePointerEvent(p, insideSVG);
    };
    Pointer.prototype._handleTouchEvent = function (p, e) {
        var insideSVG = this._touchDispatcher.eventInside(this._componentAttachedTo, e);
        this._handlePointerEvent(p, insideSVG);
    };
    Pointer.prototype._handlePointerEvent = function (p, insideSVG) {
        var translatedP = this._translateToComponentSpace(p);
        var overComponent = this._isInsideComponent(translatedP);
        if (overComponent && insideSVG) {
            if (!this._overComponent) {
                this._pointerEnterCallbacks.callCallbacks(translatedP);
            }
            this._pointerMoveCallbacks.callCallbacks(translatedP);
        }
        else if (this._overComponent) {
            this._pointerExitCallbacks.callCallbacks(translatedP);
        }
        this._overComponent = overComponent && insideSVG;
    };
    /**
     * Adds a callback to be called when the pointer enters the Component.
     *
     * @param {PointerCallback} callback
     * @return {Interactions.Pointer} The calling Pointer Interaction.
     */
    Pointer.prototype.onPointerEnter = function (callback) {
        this._pointerEnterCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the pointer enters the Component.
     *
     * @param {PointerCallback} callback
     * @return {Interactions.Pointer} The calling Pointer Interaction.
     */
    Pointer.prototype.offPointerEnter = function (callback) {
        this._pointerEnterCallbacks.delete(callback);
        return this;
    };
    /**
     * Adds a callback to be called when the pointer moves within the Component.
     *
     * @param {PointerCallback} callback
     * @return {Interactions.Pointer} The calling Pointer Interaction.
     */
    Pointer.prototype.onPointerMove = function (callback) {
        this._pointerMoveCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the pointer moves within the Component.
     *
     * @param {PointerCallback} callback
     * @return {Interactions.Pointer} The calling Pointer Interaction.
     */
    Pointer.prototype.offPointerMove = function (callback) {
        this._pointerMoveCallbacks.delete(callback);
        return this;
    };
    /**
     * Adds a callback to be called when the pointer exits the Component.
     *
     * @param {PointerCallback} callback
     * @return {Interactions.Pointer} The calling Pointer Interaction.
     */
    Pointer.prototype.onPointerExit = function (callback) {
        this._pointerExitCallbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the pointer exits the Component.
     *
     * @param {PointerCallback} callback
     * @return {Interactions.Pointer} The calling Pointer Interaction.
     */
    Pointer.prototype.offPointerExit = function (callback) {
        this._pointerExitCallbacks.delete(callback);
        return this;
    };
    return Pointer;
}(interaction_1.Interaction));
exports.Pointer = Pointer;

},{"../dispatchers":558,"../utils":624,"./interaction":579,"tslib":635}],584:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.sign = void 0;
var tslib_1 = require("tslib");
(0, tslib_1.__exportStar)(require("./memoize"), exports);
(0, tslib_1.__exportStar)(require("./memoizeProjectors"), exports);
(0, tslib_1.__exportStar)(require("./memThunk"), exports);
var signature_1 = require("./signature");
Object.defineProperty(exports, "sign", { enumerable: true, get: function () { return signature_1.sign; } });

},{"./memThunk":585,"./memoize":586,"./memoizeProjectors":587,"./signature":588,"tslib":635}],585:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 * @fileoverview Implements a convenient thunk function to handle the common case
 * of creating a memoized function that takes its inputs from mutable class properties.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.memThunk = void 0;
var index_1 = require("./index");
/**
 * First pass argument thunks that will be evaluated whenever the memThunk
 * is accessed. This should be fast and simple.
 *
 * Then pass a pure function that, when given the argument thunks' values,
 * will output some computed value. It should not use `this` in the body.
 *
 * We memoize and return this pure function.
 *
 * This way, memThunk lets you implement a performant, always-up-to-date "computed"
 * value getter.
 */
function memThunk() {
    var argsAndCompute = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        argsAndCompute[_i] = arguments[_i];
    }
    var inputs = argsAndCompute.slice(0, -1);
    var compute = argsAndCompute[argsAndCompute.length - 1];
    var memoizedCompute = (0, index_1.memoize)(compute);
    var memoizedThunk = function () {
        var _this = this;
        var inputEval = inputs.map(function (inputFn) { return inputFn.apply(_this); });
        return memoizedCompute.apply(undefined, inputEval);
    };
    return memoizedThunk;
}
exports.memThunk = memThunk;

},{"./index":584}],586:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 * @fileoverview Implements a function memoizer using the Signature API.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoize = void 0;
var signature_1 = require("./signature");
/**
 * Return a memoized version of the input function. The memoized function
 * reduces unnecessary invocations of the input by keeping a cache of the
 * return value of compute:
 *
 * <pre>
 * function compute(a, b) { return a + b }
 * const memoizedCompute = memoize(compute);
 *
 * compute(3, 7) == 10
 * compute(3, 7) == 10 // cache hit
 * </pre>
 *
 * Cache invalidation is complicated by mutable classes (Scales and Datasets).
 * The Signature API is built to solve this issue by constructing an immutable
 * snapshot of Scales/Datasets on memoized function invocation, which is itself
 * a performance hit. Thus we introduce a "doLocked" method that momentarily
 * bypasses sign/comparison logic and simply returns the cached value.
 *
 * See the Signature API for more information.
 *
 * @param {F} compute
 * @returns {MemoizedFunction<F extends Function>}
 */
function memoize(compute) {
    var lastSignature = undefined;
    var lastValue;
    var locked = false;
    var logPerformance = false;
    var memoizeFn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (locked) {
            return lastValue;
        }
        var inputSignature = (0, signature_1.signArray)(args);
        if (lastSignature === undefined
            || lastSignature.isDifferent(inputSignature)) {
            if (logPerformance) {
                console.warn("cache miss! computing");
            }
            lastSignature = inputSignature;
            lastValue = compute.apply(this, args);
        }
        else {
            if (logPerformance) {
                console.warn("cache hit!");
            }
        }
        return lastValue;
    };
    memoizeFn.doLocked = function (cb) {
        if (locked) {
            throw new Error("Locking an already locked memoize function!");
        }
        locked = true;
        var retVal = cb.apply(this);
        locked = false;
        return retVal;
    };
    memoizeFn.logPerformance = function (log) {
        if (log === void 0) { log = true; }
        logPerformance = log;
        return this;
    };
    return memoizeFn;
}
exports.memoize = memoize;

},{"./signature":588}],587:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoizeProjectors = exports.memoizeProjector = void 0;
var memoize_1 = require("lodash-es/memoize");
/**
 * An index that stores values by numeric key.
 *
 * Internally this uses prototype-less objects as key lookups are marginally
 * faster than `{}`s.
 */
var IndexMap = /** @class */ (function () {
    function IndexMap() {
        this.map = Object.create(null);
        this.exists = Object.create(null);
    }
    IndexMap.prototype.delete = function (key) {
        delete this.map[key];
        delete this.exists[key];
        return true;
    };
    IndexMap.prototype.get = function (key) {
        return this.map[key];
    };
    IndexMap.prototype.has = function (key) {
        return !!this.exists[key];
    };
    IndexMap.prototype.set = function (key, value) {
        this.map[key] = value;
        this.exists[key] = true;
        return this;
    };
    return IndexMap;
}());
/**
 * A lodash-style `MapCache` that utilizes a [number, number] key to create a
 * fast-lookup 2D index. This is much faster than stringifying the key.
 */
var DatasetIndexCache = /** @class */ (function () {
    function DatasetIndexCache() {
        this.map = new IndexMap();
    }
    DatasetIndexCache.prototype.get = function (key) {
        return this.map.get(key[0]).get(key[1]);
    };
    DatasetIndexCache.prototype.has = function (key) {
        return this.map.has(key[0]) && this.map.get(key[0]).has(key[1]);
    };
    DatasetIndexCache.prototype.set = function (key, value) {
        this.map.has(key[0]) || this.map.set(key[0], new IndexMap());
        this.map.get(key[0]).set(key[1], value);
        return this;
    };
    DatasetIndexCache.prototype.delete = function (key) {
        // NOTE: this can potentially leave dangling `IndexMap`s if we delete
        // all the keys from the index instead of using `clear`. The overhead is
        // minimal, so this is fine.
        this.map.has(key[0]) && this.map.get(key[0]).delete(key[1]);
        return true;
    };
    DatasetIndexCache.prototype.clear = function () {
        this.map = new IndexMap();
    };
    DatasetIndexCache.resolver = function (d, i, dataset) { return [dataset.updateId(), i]; };
    return DatasetIndexCache;
}());
function memoizeProjector(projector) {
    var memo = (0, memoize_1.default)(projector, DatasetIndexCache.resolver);
    memo.cache = new DatasetIndexCache();
    return memo;
}
exports.memoizeProjector = memoizeProjector;
function memoizeProjectors(attrToProjector) {
    Object.keys(attrToProjector).forEach(function (key) {
        attrToProjector[key] = memoizeProjector(attrToProjector[key]);
    });
    return attrToProjector;
}
exports.memoizeProjectors = memoizeProjectors;

},{"lodash-es/memoize":522}],588:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 * @fileoverview Implements the Signature API to help in comparing when two
 * Plottable objects have "changed".
 *
 * Memoization in Plottable is complicated by mutable scales and datasets. We cannot simply
 * reference compare two e.g. scales since it may have internally mutated. To resolve this,
 * we write a recursive Signature interface that holds an immutable snapshot of whatever
 * state the scale/data was in at the time. Then on memoized function invocation we sign the
 * new inputs and compare the signatures to decide if we should recompute.
 *
 * We must hand-write a signature for each custom class we wish to support.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectSignature = exports.ReferenceSignature = exports.ArraySignature = exports.Signature = exports.signObj = exports.signArray = exports.signRef = exports.signDataset = exports.signScale = exports.sign = void 0;
var tslib_1 = require("tslib");
var isPlainObject = require("is-plain-object");
var dataset_1 = require("../core/dataset");
var scale_1 = require("../scales/scale");
/**
 * Generic signature factory - pass any value and get a signature for it.
 *
 * Datasets and Scales are handled specially - see their respective signing methods.
 *
 * If the input is already a signature, simply return it.
 *
 * @param a
 * @returns {Signature}
 */
function sign(a) {
    if (a instanceof Signature) {
        return a;
    }
    else if (a instanceof Date) {
        return signRef(a.valueOf());
    }
    else if (a instanceof scale_1.Scale) {
        return signScale(a);
    }
    else if (a instanceof dataset_1.Dataset) {
        return signDataset(a);
    }
    else if (isPlainObject(a)) {
        return signObj(a);
    }
    else if (Array.isArray(a)) {
        return signArray(a);
    }
    else {
        return signRef(a);
    }
}
exports.sign = sign;
function signScale(scale) {
    var scaleObj = {
        // required in case the domain has changed without the updateId changing
        domain: scale.domain(),
        // required in case the range has changed without the updateId changing
        range: scale.range(),
        // generic catch-all for scale updates (existing code doesn't fully catch all
        // updates, but it's good for something)
        updateId: scale.updateId(),
        // keep a ref to the scale in case the ref changes
        ref: signRef(scale),
    };
    return signObj(scaleObj);
}
exports.signScale = signScale;
function signDataset(dataset) {
    var datasetObj = {
        ref: signRef(dataset),
        // only sign updateId since only data() and metadata() exist as properties
        // and both update updateId
        updateId: dataset.updateId(),
    };
    return signObj(datasetObj);
}
exports.signDataset = signDataset;
function signRef(a) {
    return new ReferenceSignature(a);
}
exports.signRef = signRef;
function signArray(a) {
    return new ArraySignature(a.map(function (element) { return sign(element); }));
}
exports.signArray = signArray;
function signObj(obj) {
    var signatureRecord = {};
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            signatureRecord[key] = sign(obj[key]);
        }
    }
    return new ObjectSignature(signatureRecord);
}
exports.signObj = signObj;
/**
 * Base signature. Subclasses should implement isSignatureDifferent. All classes
 * should be immutable.
 *
 * Users should only call `isDifferent`, not `isSignatureDifferent`.
 */
var Signature = /** @class */ (function () {
    function Signature() {
    }
    Signature.prototype.isDifferent = function (other) {
        if (other instanceof this.constructor) {
            return this.isSignatureDifferent(other);
        }
        else {
            return true;
        }
    };
    return Signature;
}());
exports.Signature = Signature;
/**
 * A signature for an array.
 */
var ArraySignature = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ArraySignature, _super);
    function ArraySignature(array) {
        var _this = _super.call(this) || this;
        _this.array = array;
        return _this;
    }
    /**
     * An array of signatures is different if any of the elements isDifferent.
     */
    ArraySignature.prototype.isSignatureDifferent = function (other) {
        if (other.array.length !== this.array.length) {
            return true;
        }
        else {
            for (var i = 0; i < this.array.length; i++) {
                if (this.array[i].isDifferent(other.array[i])) {
                    return true;
                }
            }
            return false;
        }
    };
    return ArraySignature;
}(Signature));
exports.ArraySignature = ArraySignature;
var ReferenceSignature = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ReferenceSignature, _super);
    function ReferenceSignature(ref) {
        var _this = _super.call(this) || this;
        _this.ref = ref;
        return _this;
    }
    ReferenceSignature.prototype.isSignatureDifferent = function (other) {
        return this.ref !== other.ref;
    };
    return ReferenceSignature;
}(Signature));
exports.ReferenceSignature = ReferenceSignature;
/**
 * A signature for a plain js object.
 */
var ObjectSignature = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ObjectSignature, _super);
    function ObjectSignature(obj) {
        var _this = _super.call(this) || this;
        _this.obj = obj;
        return _this;
    }
    /**
     * An object signature is different if any of the elements isDifferent.
     */
    ObjectSignature.prototype.isSignatureDifferent = function (other) {
        var myKeys = Object.keys(this.obj);
        var otherKeys = Object.keys(other.obj);
        if (myKeys.length !== otherKeys.length) {
            return true;
        }
        for (var _i = 0, myKeys_1 = myKeys; _i < myKeys_1.length; _i++) {
            var key = myKeys_1[_i];
            if (!other.obj.hasOwnProperty(key)) {
                return true;
            }
            if (this.obj[key].isDifferent(other.obj[key])) {
                return true;
            }
        }
        return false;
    };
    return ObjectSignature;
}(Signature));
exports.ObjectSignature = ObjectSignature;

},{"../core/dataset":550,"../scales/scale":613,"is-plain-object":477,"tslib":635}],589:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Area = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Scales = require("../scales");
var Utils = require("../utils");
var Drawers = require("../drawers");
var areaDrawer_1 = require("../drawers/areaDrawer");
var drawer_1 = require("../drawers/drawer");
var lineDrawer_1 = require("../drawers/lineDrawer");
var Plots = require("./");
var linePlot_1 = require("./linePlot");
var plot_1 = require("./plot");
var Area = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Area, _super);
    /**
     * An Area Plot draws a filled region (area) between Y and Y0.
     *
     * @constructor
     */
    function Area() {
        var _this = _super.call(this) || this;
        _this.addClass("area-plot");
        _this.y0(0); // default
        _this.attr("fill-opacity", 0.25);
        _this.attr("fill", new Scales.Color().range()[0]);
        _this._lineDrawers = new Utils.Map();
        return _this;
    }
    Area.prototype.y = function (y, yScale) {
        if (y == null) {
            return _super.prototype.y.call(this);
        }
        if (yScale == null) {
            _super.prototype.y.call(this, y);
        }
        else {
            _super.prototype.y.call(this, y, yScale);
        }
        if (yScale != null) {
            var y0 = this.y0().accessor;
            if (y0 != null) {
                this._bindProperty(Area._Y0_KEY, y0, yScale);
            }
            this._updateYScale();
        }
        return this;
    };
    Area.prototype.y0 = function (y0) {
        if (y0 == null) {
            return this._propertyBindings.get(Area._Y0_KEY);
        }
        var yBinding = this.y();
        var yScale = yBinding && yBinding.scale;
        this._bindProperty(Area._Y0_KEY, y0, yScale);
        this._updateYScale();
        this.render();
        return this;
    };
    Area.prototype._onDatasetUpdate = function () {
        _super.prototype._onDatasetUpdate.call(this);
        this._updateYScale();
    };
    Area.prototype._addDataset = function (dataset) {
        var _this = this;
        this._lineDrawers.set(dataset, new Drawers.ProxyDrawer(function () { return new lineDrawer_1.LineSVGDrawer(); }, function (ctx) { return new Drawers.CanvasDrawer(ctx, (0, lineDrawer_1.makeLineCanvasDrawStep)(function () {
            var xProjector = plot_1.Plot._scaledAccessor(_this.x());
            var yProjector = plot_1.Plot._scaledAccessor(_this.y());
            return _this._d3LineFactory(dataset, xProjector, yProjector);
        })); }));
        _super.prototype._addDataset.call(this, dataset);
        return this;
    };
    Area.prototype._createNodesForDataset = function (dataset) {
        _super.prototype._createNodesForDataset.call(this, dataset);
        var drawer = this._lineDrawers.get(dataset);
        if (this.renderer() === "svg") {
            drawer.useSVG(this._renderArea);
        }
        else {
            drawer.useCanvas(this._canvas);
        }
        return drawer;
    };
    Area.prototype._removeDatasetNodes = function (dataset) {
        _super.prototype._removeDatasetNodes.call(this, dataset);
        this._lineDrawers.get(dataset).remove();
    };
    Area.prototype._additionalPaint = function () {
        var _this = this;
        var drawSteps = this._generateLineDrawSteps();
        var dataToDraw = this._getDataToDraw();
        this.datasets().forEach(function (dataset) {
            var appliedDrawSteps = plot_1.Plot.applyDrawSteps(drawSteps, dataset);
            _this._lineDrawers.get(dataset).draw(dataToDraw.get(dataset), appliedDrawSteps);
        });
    };
    Area.prototype._generateLineDrawSteps = function () {
        var drawSteps = [];
        if (this._animateOnNextRender()) {
            var attrToProjector = this._generateLineAttrToProjector();
            attrToProjector["d"] = this._constructLineProjector(plot_1.Plot._scaledAccessor(this.x()), this._getResetYFunction());
            drawSteps.push({ attrToProjector: attrToProjector, animator: this._getAnimator(Plots.Animator.RESET) });
        }
        drawSteps.push({
            attrToProjector: this._generateLineAttrToProjector(),
            animator: this._getAnimator(Plots.Animator.MAIN),
        });
        return drawSteps;
    };
    Area.prototype._generateLineAttrToProjector = function () {
        var lineAttrToProjector = this._getAttrToProjector();
        lineAttrToProjector["d"] = this._constructLineProjector(plot_1.Plot._scaledAccessor(this.x()), plot_1.Plot._scaledAccessor(this.y()));
        return lineAttrToProjector;
    };
    Area.prototype._createDrawer = function (dataset) {
        var _this = this;
        return new drawer_1.ProxyDrawer(function () { return new areaDrawer_1.AreaSVGDrawer(); }, function (ctx) {
            return new Drawers.CanvasDrawer(ctx, (0, areaDrawer_1.makeAreaCanvasDrawStep)(function () {
                var _a = _this._coordinateProjectors(), xProjector = _a[0], yProjector = _a[1], y0Projector = _a[2];
                var definedProjector = _this._createDefinedProjector(xProjector, yProjector);
                return _this._createAreaGenerator(xProjector, yProjector, y0Projector, definedProjector, dataset);
            }, function () {
                var _a = _this._coordinateProjectors(), xProjector = _a[0], yProjector = _a[1];
                var definedProjector = _this._createDefinedProjector(xProjector, yProjector);
                return _this._createTopLineGenerator(xProjector, yProjector, definedProjector, dataset);
            }));
        });
    };
    Area.prototype._generateDrawSteps = function () {
        var drawSteps = [];
        if (this._animateOnNextRender()) {
            var attrToProjector = this._getAttrToProjector();
            attrToProjector["d"] = this._constructAreaProjector(plot_1.Plot._scaledAccessor(this.x()), this._getResetYFunction(), plot_1.Plot._scaledAccessor(this.y0()));
            drawSteps.push({ attrToProjector: attrToProjector, animator: this._getAnimator(Plots.Animator.RESET) });
        }
        drawSteps.push({
            attrToProjector: this._getAttrToProjector(),
            animator: this._getAnimator(Plots.Animator.MAIN),
        });
        return drawSteps;
    };
    Area.prototype._updateYScale = function () {
        var extents = this.getExtentsForProperty("y0");
        var extent = Utils.Array.flatten(extents);
        var uniqExtentVals = Utils.Array.uniq(extent);
        var constantBaseline = uniqExtentVals.length === 1 ? uniqExtentVals[0] : null;
        var yBinding = this.y();
        var yScale = (yBinding && yBinding.scale);
        if (yScale == null) {
            return;
        }
        if (this._constantBaselineValueProvider != null) {
            yScale.removePaddingExceptionsProvider(this._constantBaselineValueProvider);
            this._constantBaselineValueProvider = null;
        }
        if (constantBaseline != null) {
            this._constantBaselineValueProvider = function () { return [constantBaseline]; };
            yScale.addPaddingExceptionsProvider(this._constantBaselineValueProvider);
        }
    };
    Area.prototype._getResetYFunction = function () {
        return plot_1.Plot._scaledAccessor(this.y0());
    };
    Area.prototype._coordinateProjectors = function () {
        return [
            plot_1.Plot._scaledAccessor(this.x()),
            plot_1.Plot._scaledAccessor(this.y()),
            plot_1.Plot._scaledAccessor(this.y0()),
        ];
    };
    Area.prototype._propertyProjectors = function () {
        var propertyToProjectors = _super.prototype._propertyProjectors.call(this);
        var _a = this._coordinateProjectors(), xProject = _a[0], yProjector = _a[1], y0Projector = _a[2];
        propertyToProjectors["d"] = this._constructAreaProjector(xProject, yProjector, y0Projector);
        return propertyToProjectors;
    };
    Area.prototype.selections = function (datasets) {
        var _this = this;
        if (datasets === void 0) { datasets = this.datasets(); }
        if (this.renderer() === "canvas") {
            return d3.selectAll();
        }
        var allSelections = _super.prototype.selections.call(this, datasets).nodes();
        var lineDrawers = datasets.map(function (dataset) { return _this._lineDrawers.get(dataset); })
            .filter(function (drawer) { return drawer != null; });
        lineDrawers.forEach(function (ld) { return allSelections.push.apply(allSelections, ld.getVisualPrimitives()); });
        return d3.selectAll(allSelections);
    };
    Area.prototype._constructAreaProjector = function (xProjector, yProjector, y0Projector) {
        var _this = this;
        var definedProjector = this._createDefinedProjector(plot_1.Plot._scaledAccessor(this.x()), plot_1.Plot._scaledAccessor(this.y()));
        return function (datum, index, dataset) {
            var areaGenerator = _this._createAreaGenerator(xProjector, yProjector, y0Projector, definedProjector, dataset);
            return areaGenerator(datum);
        };
    };
    Area.prototype._createDefinedProjector = function (xProjector, yProjector) {
        return function (d, i, dataset) {
            var positionX = xProjector(d, i, dataset);
            var positionY = yProjector(d, i, dataset);
            return Utils.Math.isValidNumber(positionX) && Utils.Math.isValidNumber(positionY);
        };
    };
    Area.prototype._createAreaGenerator = function (xProjector, yProjector, y0Projector, definedProjector, dataset) {
        // just runtime error if user passes curveBundle to area plot
        var curveFactory = this._getCurveFactory();
        var areaGenerator = d3.area()
            .x(function (innerDatum, innerIndex) { return xProjector(innerDatum, innerIndex, dataset); })
            .y1(function (innerDatum, innerIndex) { return yProjector(innerDatum, innerIndex, dataset); })
            .y0(function (innerDatum, innerIndex) { return y0Projector(innerDatum, innerIndex, dataset); })
            .curve(curveFactory)
            .defined(function (innerDatum, innerIndex) { return definedProjector(innerDatum, innerIndex, dataset); });
        return areaGenerator;
    };
    Area.prototype._createTopLineGenerator = function (xProjector, yProjector, definedProjector, dataset) {
        var curveFactory = this._getCurveFactory();
        var areaGenerator = d3.line()
            .x(function (innerDatum, innerIndex) { return xProjector(innerDatum, innerIndex, dataset); })
            .y(function (innerDatum, innerIndex) { return yProjector(innerDatum, innerIndex, dataset); })
            .curve(curveFactory)
            .defined(function (innerDatum, innerIndex) { return definedProjector(innerDatum, innerIndex, dataset); });
        return areaGenerator;
    };
    Area._Y0_KEY = "y0";
    return Area;
}(linePlot_1.Line));
exports.Area = Area;

},{"../drawers":569,"../drawers/areaDrawer":564,"../drawers/drawer":568,"../drawers/lineDrawer":570,"../scales":607,"../utils":624,"./":594,"./linePlot":595,"./plot":597,"d3":414,"tslib":635}],590:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bar = exports.BarAlignment = exports.LabelsPosition = exports.BarOrientation = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Typesettable = require("typesettable");
var Animators = require("../animators");
var label_1 = require("../components/label");
var Formatters = require("../core/formatters");
var Drawers = require("../drawers");
var drawer_1 = require("../drawers/drawer");
var rectangleDrawer_1 = require("../drawers/rectangleDrawer");
var memoize_1 = require("../memoize");
var Scales = require("../scales");
var quantitativeScale_1 = require("../scales/quantitativeScale");
var Utils = require("../utils");
var makeEnum_1 = require("../utils/makeEnum");
var Plots = require("./");
var plot_1 = require("./plot");
var xyPlot_1 = require("./xyPlot");
exports.BarOrientation = (0, makeEnum_1.makeEnum)(["vertical", "horizontal"]);
exports.LabelsPosition = (0, makeEnum_1.makeEnum)(["start", "middle", "end", "outside"]);
exports.BarAlignment = (0, makeEnum_1.makeEnum)(["start", "middle", "end"]);
var Bar = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Bar, _super);
    /**
     * A Bar Plot draws bars growing out from a baseline to some value
     *
     * @constructor
     * @param {string} [orientation="vertical"] One of "vertical"/"horizontal".
     */
    function Bar(orientation) {
        if (orientation === void 0) { orientation = "vertical"; }
        var _this = _super.call(this) || this;
        _this._labelFormatter = Formatters.identity();
        _this._labelsEnabled = false;
        _this._labelsPosition = exports.LabelsPosition.end;
        _this._labelFontSize = label_1.Label._DEFAULT_FONT_SIZE_PX;
        _this._hideBarsIfAnyAreTooWide = true;
        _this._barAlignment = "middle";
        _this._computeBarPixelThickness = (0, memoize_1.memoize)(computeBarPixelThickness);
        /**
         * Whether all the bars in this barPlot have the same pixel thickness.
         * If so, use the _barPixelThickness property to access the thickness.
         */
        _this._fixedBarPixelThickness = true;
        _this.addClass("bar-plot");
        if (orientation !== "vertical" && orientation !== "horizontal") {
            throw new Error(orientation + " is not a valid orientation for Plots.Bar");
        }
        _this._isVertical = orientation === "vertical";
        _this.animator("baseline", new Animators.Null());
        _this.attr("fill", new Scales.Color().range()[0]);
        _this.attr(Bar._BAR_THICKNESS_KEY, function () { return _this._barPixelThickness(); });
        _this._labelConfig = new Utils.Map();
        _this._baselineValueProvider = function () { return [_this.baselineValue()]; };
        return _this;
    }
    Bar.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        this._updateExtents();
        return this;
    };
    Bar.prototype.x = function (x, xScale) {
        if (x == null) {
            return _super.prototype.x.call(this);
        }
        if (xScale == null) {
            _super.prototype.x.call(this, x);
        }
        else {
            _super.prototype.x.call(this, x, xScale);
        }
        this._updateThicknessAttr();
        this._updateLengthScale();
        return this;
    };
    Bar.prototype.y = function (y, yScale) {
        if (y == null) {
            return _super.prototype.y.call(this);
        }
        if (yScale == null) {
            _super.prototype.y.call(this, y);
        }
        else {
            _super.prototype.y.call(this, y, yScale);
        }
        this._updateLengthScale();
        return this;
    };
    /**
     * The binding associated with bar length. Length is the count or value the bar is trying to show.
     * This is the .y() for a vertical plot and .x() for a horizontal plot.
     */
    Bar.prototype.length = function () {
        return this._isVertical ? this.y() : this.x();
    };
    /**
     * The binding associated with bar position. Position separates the different bar categories.
     * This is the .x() for a vertical plot and .y() for a horizontal plot.
     */
    Bar.prototype.position = function () {
        return this._isVertical ? this.x() : this.y();
    };
    Bar.prototype.barEnd = function (end) {
        if (end == null) {
            return this._propertyBindings.get(Bar._BAR_END_KEY);
        }
        var binding = this.position();
        var scale = binding && binding.scale;
        this._bindProperty(Bar._BAR_END_KEY, end, scale);
        this._updateThicknessAttr();
        this._updateLengthScale();
        this.render();
        return this;
    };
    Bar.prototype.barAlignment = function (align) {
        if (align == null) {
            return this._barAlignment;
        }
        this._barAlignment = align;
        this._clearAttrToProjectorCache();
        this.render();
        return this;
    };
    /**
     * Gets the orientation of the plot
     *
     * @return "vertical" | "horizontal"
     */
    Bar.prototype.orientation = function () {
        return this._isVertical ? "vertical" : "horizontal";
    };
    Bar.prototype._createDrawer = function () {
        return new drawer_1.ProxyDrawer(function () { return new rectangleDrawer_1.RectangleSVGDrawer(Bar._BAR_AREA_CLASS); }, function (ctx) { return new Drawers.RectangleCanvasDrawer(ctx); });
    };
    Bar.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._baseline = this._renderArea.append("line").classed("baseline", true);
    };
    Bar.prototype.baselineValue = function (value) {
        if (value == null) {
            if (this._baselineValue != null) {
                return this._baselineValue;
            }
            if (!this._projectorsReady()) {
                return 0;
            }
            var lengthScale = this.length().scale;
            if (!lengthScale) {
                return 0;
            }
            if (lengthScale instanceof Scales.Time) {
                return new Date(0);
            }
            return 0;
        }
        this._baselineValue = value;
        this._updateLengthScale();
        this._clearAttrToProjectorCache();
        this.render();
        return this;
    };
    Bar.prototype.addDataset = function (dataset) {
        _super.prototype.addDataset.call(this, dataset);
        return this;
    };
    Bar.prototype._addDataset = function (dataset) {
        _super.prototype._addDataset.call(this, dataset);
        return this;
    };
    Bar.prototype.removeDataset = function (dataset) {
        _super.prototype.removeDataset.call(this, dataset);
        return this;
    };
    Bar.prototype._removeDataset = function (dataset) {
        _super.prototype._removeDataset.call(this, dataset);
        return this;
    };
    Bar.prototype.datasets = function (datasets) {
        if (datasets == null) {
            return _super.prototype.datasets.call(this);
        }
        _super.prototype.datasets.call(this, datasets);
        return this;
    };
    Bar.prototype.labelsEnabled = function (enabled, labelsPosition) {
        if (enabled == null) {
            return this._labelsEnabled;
        }
        else {
            this._labelsEnabled = enabled;
            if (labelsPosition != null) {
                this._labelsPosition = labelsPosition;
            }
            this._clearAttrToProjectorCache();
            this.render();
            return this;
        }
    };
    Bar.prototype.labelFormatter = function (formatter) {
        if (formatter == null) {
            return this._labelFormatter;
        }
        else {
            this._labelFormatter = formatter;
            this._clearAttrToProjectorCache();
            this.render();
            return this;
        }
    };
    Bar.prototype.labelFontSize = function (fontSize) {
        var _this = this;
        if (fontSize == null) {
            return this._labelFontSize;
        }
        else {
            this.invalidateCache();
            this._labelFontSize = fontSize;
            this._labelConfig.forEach(function (_a) {
                var labelArea = _a.labelArea;
                // clearing to remove outdated font-size classes
                labelArea.attr("class", null)
                    .classed(Bar._LABEL_AREA_CLASS, true)
                    .classed("label-" + _this._labelFontSize, true);
            });
            return this.render();
        }
    };
    Bar.prototype._createNodesForDataset = function (dataset) {
        var drawer = _super.prototype._createNodesForDataset.call(this, dataset);
        var labelArea = this._renderArea.append("g")
            .classed(Bar._LABEL_AREA_CLASS, true)
            .classed("label-" + this._labelFontSize, true);
        var context = new Typesettable.SvgContext(labelArea.node());
        var measurer = new Typesettable.CacheMeasurer(context);
        var writer = new Typesettable.Writer(measurer, context);
        this._labelConfig.set(dataset, { labelArea: labelArea, measurer: measurer, writer: writer });
        return drawer;
    };
    Bar.prototype._removeDatasetNodes = function (dataset) {
        _super.prototype._removeDatasetNodes.call(this, dataset);
        var labelConfig = this._labelConfig.get(dataset);
        if (labelConfig != null) {
            labelConfig.labelArea.remove();
            this._labelConfig.delete(dataset);
        }
    };
    /**
     * Returns the PlotEntity nearest to the query point according to the following algorithm:
     *   - If the query point is inside a bar, returns the PlotEntity for that bar.
     *   - Otherwise, gets the nearest PlotEntity by the positional direction (X for vertical, Y for horizontal),
     *     breaking ties with the secondary direction.
     * Returns undefined if no PlotEntity can be found.
     *
     * @param {Point} queryPoint
     * @returns {PlotEntity} The nearest PlotEntity, or undefined if no PlotEntity can be found.
     */
    Bar.prototype.entityNearest = function (queryPoint) {
        var _this = this;
        var worker = function () {
            var nearest = _this._isVertical ?
                _this._getEntityStore().entityNearestX(queryPoint) :
                _this._getEntityStore().entityNearestY(queryPoint);
            return nearest === undefined ? undefined : _this._lightweightPlotEntityToPlotEntity(nearest);
        };
        return this._fixedBarPixelThickness ? this._computeBarPixelThickness.doLocked(worker) : worker();
    };
    /**
     * Gets the Entities at a particular Point.
     *
     * @param {Point} p
     * @returns {PlotEntity[]}
     */
    Bar.prototype.entitiesAt = function (p) {
        var _this = this;
        var worker = function () { return _this._entitiesIntersecting(p.x, p.y); };
        return this._fixedBarPixelThickness ? this._computeBarPixelThickness.doLocked(worker) : worker();
    };
    Bar.prototype.entitiesInBounds = function (queryBounds) {
        var _this = this;
        var worker = function () { return _super.prototype.entitiesInBounds.call(_this, queryBounds); };
        return this._fixedBarPixelThickness ? this._computeBarPixelThickness.doLocked(worker) : worker();
    };
    Bar.prototype.entitiesInXBounds = function (queryBounds) {
        var _this = this;
        var worker = function () { return _super.prototype.entitiesInXBounds.call(_this, queryBounds); };
        return this._fixedBarPixelThickness ? this._computeBarPixelThickness.doLocked(worker) : worker();
    };
    Bar.prototype.entitiesInYBounds = function (queryBounds) {
        var _this = this;
        var worker = function () { return _super.prototype.entitiesInYBounds.call(_this, queryBounds); };
        return this._fixedBarPixelThickness ? this._computeBarPixelThickness.doLocked(worker) : worker();
    };
    Bar.prototype._entitiesIntersecting = function (xValOrRange, yValOrRange) {
        var intersected = [];
        var entities = this._getEntityStore().entities();
        var entitiesLen = entities.length;
        for (var i = 0; i < entitiesLen; i++) {
            var entity = entities[i];
            if (Utils.DOM.intersectsBBox(xValOrRange, yValOrRange, this._entityBounds(entity))) {
                intersected.push(this._lightweightPlotEntityToPlotEntity(entity));
            }
        }
        return intersected;
    };
    Bar.prototype._updateLengthScale = function () {
        if (!this._projectorsReady()) {
            return;
        }
        var lengthScale = this.length().scale;
        if (lengthScale instanceof quantitativeScale_1.QuantitativeScale) {
            lengthScale.addPaddingExceptionsProvider(this._baselineValueProvider);
            lengthScale.addIncludedValuesProvider(this._baselineValueProvider);
        }
    };
    Bar.prototype.renderImmediately = function () {
        var _this = this;
        // HACK update bar pixel thickness
        this._barPixelThickness();
        return this._computeBarPixelThickness.doLocked(function () { return _super.prototype.renderImmediately.call(_this); });
    };
    Bar.prototype._additionalPaint = function (time) {
        var _this = this;
        var lengthScale = this.length().scale;
        var scaledBaseline = lengthScale.scale(this.baselineValue());
        var baselineAttr = {
            x1: this._isVertical ? 0 : scaledBaseline,
            y1: this._isVertical ? scaledBaseline : 0,
            x2: this._isVertical ? this.width() : scaledBaseline,
            y2: this._isVertical ? scaledBaseline : this.height(),
        };
        this._getAnimator("baseline").animate(this._baseline, baselineAttr);
        this.datasets().forEach(function (dataset) { return _this._labelConfig.get(dataset).labelArea.selectAll("g").remove(); });
        if (this._labelsEnabled) {
            Utils.Window.setTimeout(function () { return _this._drawLabels(); }, time);
        }
    };
    /**
     * Makes sure the extent takes into account the widths of the bars
     */
    Bar.prototype.getExtentsForProperty = function (property) {
        var _this = this;
        var extents = _super.prototype.getExtentsForProperty.call(this, property);
        var accScaleBinding;
        if (property === "x" && this._isVertical) {
            accScaleBinding = this.x();
        }
        else if (property === "y" && !this._isVertical) {
            accScaleBinding = this.y();
        }
        else {
            return extents;
        }
        if (!(accScaleBinding && accScaleBinding.scale && accScaleBinding.scale instanceof quantitativeScale_1.QuantitativeScale)) {
            return extents;
        }
        var scale = accScaleBinding.scale;
        var width = this._barPixelThickness();
        // To account for inverted domains
        extents = extents.map(function (extent) { return d3.extent([
            scale.invert(_this._getPositionAttr(scale.scale(extent[0]), width)),
            scale.invert(_this._getPositionAttr(scale.scale(extent[0]), width) + width),
            scale.invert(_this._getPositionAttr(scale.scale(extent[1]), width)),
            scale.invert(_this._getPositionAttr(scale.scale(extent[1]), width) + width),
        ]); });
        return extents;
    };
    /**
     * Return the <rect>'s x or y attr value given the position and thickness of
     * that bar. This method is responsible for account for barAlignment, in particular.
     */
    Bar.prototype._getPositionAttr = function (position, thickness) {
        // account for flipped vertical axis
        if (!this._isVertical) {
            position -= thickness;
            thickness *= -1;
        }
        switch (this._barAlignment) {
            case "start":
                return position;
            case "end":
                return position - thickness;
            case "middle":
            default:
                return position - thickness / 2;
        }
    };
    Bar.prototype._drawLabels = function () {
        var _this = this;
        var dataToDraw = this._getDataToDraw();
        var attrToProjector = this._getAttrToProjector();
        var anyLabelTooWide = this.datasets().some(function (dataset) {
            return dataToDraw.get(dataset).some(function (datum, index) {
                if (datum == null) {
                    return false;
                }
                return _this._drawLabel(datum, index, dataset, attrToProjector);
            });
        });
        if (this._hideBarsIfAnyAreTooWide && anyLabelTooWide) {
            this.datasets().forEach(function (dataset) { return _this._labelConfig.get(dataset).labelArea.selectAll("g").remove(); });
        }
    };
    Bar.prototype._drawLabel = function (datum, index, dataset, attrToProjector) {
        var _a = this._labelConfig.get(dataset), labelArea = _a.labelArea, measurer = _a.measurer, writer = _a.writer;
        var lengthAccessor = this.length().accessor;
        var length = lengthAccessor(datum, index, dataset);
        var lengthScale = this.length().scale;
        var scaledLength = lengthScale != null ? lengthScale.scale(length) : length;
        var scaledBaseline = lengthScale != null ? lengthScale.scale(this.baselineValue()) : this.baselineValue();
        var barCoordinates = { x: attrToProjector["x"](datum, index, dataset), y: attrToProjector["y"](datum, index, dataset) };
        var barDimensions = { width: attrToProjector["width"](datum, index, dataset), height: attrToProjector["height"](datum, index, dataset) };
        var text = this._labelFormatter(length, datum, index, dataset);
        var measurement = measurer.measure(text);
        var showLabelOnBar = this._shouldShowLabelOnBar(barCoordinates, barDimensions, measurement);
        // show label on right when value === baseline for horizontal plots
        var aboveOrLeftOfBaseline = this._isVertical ? scaledLength <= scaledBaseline : scaledLength < scaledBaseline;
        var _b = this._calculateLabelProperties(barCoordinates, barDimensions, measurement, showLabelOnBar, aboveOrLeftOfBaseline), containerDimensions = _b.containerDimensions, labelContainerOrigin = _b.labelContainerOrigin, labelOrigin = _b.labelOrigin, alignment = _b.alignment;
        var color = attrToProjector["fill"](datum, index, dataset);
        var labelContainer = this._createLabelContainer(labelArea, labelContainerOrigin, labelOrigin, measurement, showLabelOnBar, color);
        var writeOptions = { xAlign: alignment.x, yAlign: alignment.y };
        writer.write(text, containerDimensions.width, containerDimensions.height, writeOptions, labelContainer.node());
        var tooWide = this._isVertical
            ? barDimensions.width < (measurement.width)
            : barDimensions.height < (measurement.height);
        return tooWide;
    };
    /**
     * Labels are "on-bar" by default, but if the bar is not long enough to fit the text,
     * we can try putting the label "off-bar", if there's enough space outside of the bar
     * to fit it.
     */
    Bar.prototype._shouldShowLabelOnBar = function (barCoordinates, barDimensions, labelDimensions) {
        if (this._labelsPosition === exports.LabelsPosition.outside) {
            return false;
        }
        var barStart = this._isVertical ? barCoordinates.y : barCoordinates.x;
        var barLength = this._isVertical ? barDimensions.height : barDimensions.width;
        var totalLength = this._isVertical ? this.height() : this.width();
        var labelLength = this._isVertical ? labelDimensions.height : labelDimensions.width;
        var barEnd = barStart + barLength;
        var barLengthVisibleOnScreen = barLength;
        if (barEnd > totalLength) {
            barLengthVisibleOnScreen = totalLength - barStart;
        }
        else if (barStart < 0) {
            barLengthVisibleOnScreen = barEnd;
        }
        return (labelLength + Bar._LABEL_MARGIN_INSIDE_BAR <= barLengthVisibleOnScreen);
    };
    Bar.prototype._calculateLabelProperties = function (barCoordinates, barDimensions, measurement, showLabelOnBar, aboveOrLeftOfBaseline) {
        var _this = this;
        var barCoordinate = this._isVertical ? barCoordinates.y : barCoordinates.x;
        var barDimension = this._isVertical ? barDimensions.height : barDimensions.width;
        var measurementDimension = this._isVertical ? measurement.height : measurement.width;
        var alignmentDimension = "center";
        var containerDimension = barDimension;
        var labelContainerOriginCoordinate = barCoordinate;
        var labelOriginCoordinate = barCoordinate;
        var updateCoordinates = function (position) {
            switch (position) {
                case "topLeft":
                    alignmentDimension = _this._isVertical ? "top" : "left";
                    labelContainerOriginCoordinate += Bar._LABEL_MARGIN_INSIDE_BAR;
                    labelOriginCoordinate += Bar._LABEL_MARGIN_INSIDE_BAR;
                    return;
                case "center":
                    labelOriginCoordinate += (barDimension + measurementDimension) / 2;
                    return;
                case "bottomRight":
                    alignmentDimension = _this._isVertical ? "bottom" : "right";
                    labelContainerOriginCoordinate -= Bar._LABEL_MARGIN_INSIDE_BAR;
                    labelOriginCoordinate += containerDimension - Bar._LABEL_MARGIN_INSIDE_BAR - measurementDimension;
                    return;
            }
        };
        if (showLabelOnBar) {
            switch (this._labelsPosition) {
                case exports.LabelsPosition.start:
                    aboveOrLeftOfBaseline ? updateCoordinates("bottomRight") : updateCoordinates("topLeft");
                    break;
                case exports.LabelsPosition.middle:
                    updateCoordinates("center");
                    break;
                case exports.LabelsPosition.end:
                    aboveOrLeftOfBaseline ? updateCoordinates("topLeft") : updateCoordinates("bottomRight");
                    break;
            }
        }
        else {
            if (aboveOrLeftOfBaseline) {
                alignmentDimension = this._isVertical ? "top" : "left";
                containerDimension = barDimension + Bar._LABEL_MARGIN_INSIDE_BAR + measurementDimension;
                labelContainerOriginCoordinate -= Bar._LABEL_MARGIN_INSIDE_BAR + measurementDimension;
                labelOriginCoordinate -= Bar._LABEL_MARGIN_INSIDE_BAR + measurementDimension;
            }
            else {
                alignmentDimension = this._isVertical ? "bottom" : "right";
                containerDimension = barDimension + Bar._LABEL_MARGIN_INSIDE_BAR + measurementDimension;
                labelOriginCoordinate += barDimension + Bar._LABEL_MARGIN_INSIDE_BAR;
            }
        }
        return {
            containerDimensions: {
                width: this._isVertical ? barDimensions.width : containerDimension,
                height: this._isVertical ? containerDimension : barDimensions.height,
            },
            labelContainerOrigin: {
                x: this._isVertical ? barCoordinates.x : labelContainerOriginCoordinate,
                y: this._isVertical ? labelContainerOriginCoordinate : barCoordinates.y,
            },
            labelOrigin: {
                x: this._isVertical ? (barCoordinates.x + barDimensions.width / 2 - measurement.width / 2) : labelOriginCoordinate,
                y: this._isVertical ? labelOriginCoordinate : (barCoordinates.y + barDimensions.height / 2 - measurement.height / 2),
            },
            alignment: {
                x: this._isVertical ? "center" : alignmentDimension,
                y: this._isVertical ? alignmentDimension : "center",
            },
        };
    };
    Bar.prototype._createLabelContainer = function (labelArea, labelContainerOrigin, labelOrigin, measurement, showLabelOnBar, color) {
        var labelContainer = labelArea.append("g").attr("transform", "translate(" + labelContainerOrigin.x + ", " + labelContainerOrigin.y + ")");
        if (showLabelOnBar) {
            labelContainer.classed("on-bar-label", true);
            var dark = Utils.Color.contrast("white", color) * 1.6 < Utils.Color.contrast("black", color);
            labelContainer.classed(dark ? "dark-label" : "light-label", true);
        }
        else {
            labelContainer.classed("off-bar-label", true);
        }
        return labelContainer;
    };
    Bar.prototype._generateDrawSteps = function () {
        var drawSteps = [];
        if (this._animateOnNextRender()) {
            var resetAttrToProjector = this._getAttrToProjector();
            var lengthScale = this.length().scale;
            var scaledBaseline_1 = lengthScale.scale(this.baselineValue());
            var lengthAttr = this._isVertical ? "y" : "x";
            var thicknessAttr = this._isVertical ? "height" : "width";
            resetAttrToProjector[lengthAttr] = function () { return scaledBaseline_1; };
            resetAttrToProjector[thicknessAttr] = function () { return 0; };
            drawSteps.push({ attrToProjector: resetAttrToProjector, animator: this._getAnimator(Plots.Animator.RESET) });
        }
        drawSteps.push({
            attrToProjector: this._getAttrToProjector(),
            animator: this._getAnimator(Plots.Animator.MAIN),
        });
        return drawSteps;
    };
    Bar.prototype._generateAttrToProjector = function () {
        var _this = this;
        var attrToProjector = _super.prototype._generateAttrToProjector.call(this);
        var lengthScale = this.length().scale;
        var scaledBaseline = lengthScale.scale(this.baselineValue());
        var lengthAttr = this._isVertical ? "y" : "x";
        var positionAttr = this._isVertical ? "x" : "y";
        var positionF = plot_1.Plot._scaledAccessor(this.position());
        var originalLengthFn = plot_1.Plot._scaledAccessor(this.length());
        var lengthFn = function (d, i, dataset) {
            return Math.abs(scaledBaseline - originalLengthFn(d, i, dataset));
        };
        var thicknessF = attrToProjector[Bar._BAR_THICKNESS_KEY];
        var gapF = attrToProjector["gap"];
        var thicknessMinusGap = gapF == null ? thicknessF : function (d, i, dataset) {
            var thick = thicknessF(d, i, dataset);
            // only subtract gap if bars are at least 2 pixels wide, otherwise canvas
            // interpolation can cause bars to become invisible due to subpixel
            // sampling
            return thick < Bar._BAR_GAPLESS_THRESHOLD_PX ? thick : thick - gapF(d, i, dataset);
        };
        // re-interpret "width" attr from representing "thickness" to actually meaning
        // width (that is, x-direction specific) again
        attrToProjector["width"] = this._isVertical ? thicknessMinusGap : lengthFn;
        attrToProjector["height"] = this._isVertical ? lengthFn : thicknessMinusGap;
        attrToProjector[lengthAttr] = function (d, i, dataset) {
            var originalLength = originalLengthFn(d, i, dataset);
            // If it is past the baseline, it should start at the baseline then width/height
            // carries it over. If it's not past the baseline, leave it at original position and
            // then width/height carries it to baseline
            return (originalLength > scaledBaseline) ? scaledBaseline : originalLength;
        };
        attrToProjector[positionAttr] = function (d, i, dataset) {
            return _this._getPositionAttr(positionF(d, i, dataset), thicknessF(d, i, dataset));
        };
        return attrToProjector;
    };
    Bar.prototype._updateThicknessAttr = function () {
        var _this = this;
        var startProj = this.position();
        var endProj = this.barEnd();
        if (startProj != null && endProj != null) {
            this._fixedBarPixelThickness = false;
            this.attr(Bar._BAR_THICKNESS_KEY, function (d, i, data) {
                var v1 = startProj.accessor(d, i, data);
                var v2 = endProj.accessor(d, i, data);
                v1 = startProj.scale ? startProj.scale.scale(v1) : v1;
                v2 = endProj.scale ? endProj.scale.scale(v2) : v2;
                return Math.abs(v2 - v1);
            });
        }
        else {
            this._fixedBarPixelThickness = true;
            this.attr(Bar._BAR_THICKNESS_KEY, function () { return _this._barPixelThickness(); });
        }
    };
    Bar.prototype._barPixelThickness = function () {
        if (this._fixedBarPixelThickness) {
            if (this._projectorsReady()) {
                return this._computeBarPixelThickness(this.position(), this.datasets(), this._isVertical ? this.width() : this.height());
            }
            else {
                return 0;
            }
        }
        else {
            return 0;
        }
    };
    Bar.prototype.entities = function (datasets) {
        if (datasets === void 0) { datasets = this.datasets(); }
        if (!this._projectorsReady()) {
            return [];
        }
        var entities = _super.prototype.entities.call(this, datasets);
        return entities;
    };
    Bar.prototype._entityBounds = function (entity) {
        var datum = entity.datum, index = entity.index, dataset = entity.dataset;
        return this._pixelBounds(datum, index, dataset);
    };
    /**
     * The rectangular bounds of a bar. Note that the x/y coordinates are not the
     * same as the "pixel point" because they are always at the top/left of the
     * bar.
     */
    Bar.prototype._pixelBounds = function (datum, index, dataset) {
        var attrToProjector = this._getAttrToProjector();
        return {
            x: attrToProjector["x"](datum, index, dataset),
            y: attrToProjector["y"](datum, index, dataset),
            width: attrToProjector["width"](datum, index, dataset),
            height: attrToProjector["height"](datum, index, dataset),
        };
    };
    /**
     * The "pixel point" of a bar is the farthest point from the baseline.
     *
     * For example, in a vertical bar chart with positive bar values, the pixel
     * point will be at the top of the bar. For negative bar values, the pixel
     * point will be at the bottom of the bar.
     */
    Bar.prototype._pixelPoint = function (datum, index, dataset) {
        var rect = this._pixelBounds(datum, index, dataset);
        var originalPosition = (this._isVertical ? plot_1.Plot._scaledAccessor(this.y()) : plot_1.Plot._scaledAccessor(this.x()))(datum, index, dataset);
        var scaledBaseline = (this._isVertical ? this.y().scale : this.x().scale).scale(this.baselineValue());
        return this._pixelPointBar(originalPosition, scaledBaseline, rect);
    };
    Bar.prototype._pixelPointBar = function (originalPosition, scaledBaseline, rect) {
        var x, y;
        if (this._isVertical) {
            x = rect.x + rect.width / 2;
            y = originalPosition <= scaledBaseline ? rect.y : rect.y + rect.height;
        }
        else {
            x = originalPosition >= scaledBaseline ? rect.x + rect.width : rect.x;
            y = rect.y + rect.height / 2;
        }
        return { x: x, y: y };
    };
    Bar.prototype._uninstallScaleForKey = function (scale, key) {
        _super.prototype._uninstallScaleForKey.call(this, scale, key);
    };
    Bar.prototype._getDataToDraw = function () {
        var _this = this;
        var dataToDraw = new Utils.Map();
        var attrToProjector = this._getAttrToProjector();
        var plotWidth = this.width();
        var plotHeight = this.height();
        this.datasets().forEach(function (dataset) {
            var data = dataset.data().map(function (d, i) {
                var isValid = _this._isDatumOnScreen(attrToProjector, plotWidth, plotHeight, d, i, dataset);
                return isValid ? d : null;
            });
            dataToDraw.set(dataset, data);
        });
        return dataToDraw;
    };
    Bar.prototype._isDatumOnScreen = function (attrToProjector, plotWidth, plotHeight, d, i, dataset) {
        var pixelX = attrToProjector["x"](d, i, dataset);
        var pixelY = attrToProjector["y"](d, i, dataset);
        var pixelWidth = attrToProjector["width"](d, i, dataset);
        var pixelHeight = attrToProjector["height"](d, i, dataset);
        var isValid = Utils.Math.isValidNumber(pixelX) &&
            Utils.Math.isValidNumber(pixelY) &&
            Utils.Math.isValidNumber(pixelWidth) &&
            Utils.Math.isValidNumber(pixelHeight);
        if (!isValid) {
            return false;
        }
        return Utils.Math.boundsIntersects(pixelX, pixelY, pixelWidth, pixelHeight, 0, 0, plotWidth, plotHeight);
    };
    Bar.prototype.invalidateCache = function () {
        var _this = this;
        _super.prototype.invalidateCache.call(this);
        this.datasets().forEach(function (dataset) {
            var labelConfig = _this._labelConfig.get(dataset);
            if (labelConfig != null) {
                labelConfig.measurer.reset();
            }
        });
    };
    Bar._BAR_THICKNESS_RATIO = 0.95;
    Bar._BAR_GAPLESS_THRESHOLD_PX = 3;
    Bar._SINGLE_BAR_DIMENSION_RATIO = 0.4;
    Bar._BAR_AREA_CLASS = "bar-area";
    Bar._BAR_END_KEY = "barEnd";
    // we special case the "width" property to represent the bar thickness
    // (aka the distance between adjacent bar positions); in _generateAttrToProjector
    // we re-assign "width" to specifically refer to <rect>'s width attribute
    Bar._BAR_THICKNESS_KEY = "width";
    Bar._LABEL_AREA_CLASS = "bar-label-text-area";
    /**
     * In the case of "start" or "end" LabelPositions, put the label this many px away
     * from the bar's length distance edge
     */
    Bar._LABEL_MARGIN_INSIDE_BAR = 10;
    return Bar;
}(xyPlot_1.XYPlot));
exports.Bar = Bar;
/**
 * Computes the barPixelThickness of all the bars in the plot.
 *
 * If the position scale of the plot is a CategoryScale and in bands mode, then the rangeBands function will be used.
 * If the position scale of the plot is a QuantitativeScale, then the bar thickness is equal to the smallest distance between
 * two adjacent data points, padded for visualisation.
 *
 * This is ignored when explicitly setting the barEnd.
 */
function computeBarPixelThickness(positionBinding, datasets, plotPositionDimensionLength) {
    var barPixelThickness;
    var positionScale = positionBinding.scale;
    if (positionScale instanceof Scales.Category) {
        barPixelThickness = positionScale.rangeBand();
    }
    else {
        var positionAccessor_1 = positionBinding.accessor;
        var numberBarAccessorData = d3.set(Utils.Array.flatten(datasets.map(function (dataset) {
            return dataset.data().map(function (d, i) { return positionAccessor_1(d, i, dataset); })
                .filter(function (d) { return d != null; })
                .map(function (d) { return d.valueOf(); });
        }))).values().map(function (value) { return +value; });
        numberBarAccessorData.sort(function (a, b) { return a - b; });
        var scaledData = numberBarAccessorData.map(function (datum) { return positionScale.scale(datum); });
        var barAccessorDataPairs = d3.pairs(scaledData);
        barPixelThickness = Utils.Math.min(barAccessorDataPairs, function (pair, i) {
            return Math.abs(pair[1] - pair[0]);
        }, plotPositionDimensionLength * Bar._SINGLE_BAR_DIMENSION_RATIO);
        barPixelThickness *= Bar._BAR_THICKNESS_RATIO;
    }
    return barPixelThickness;
}

},{"../animators":525,"../components/label":541,"../core/formatters":551,"../drawers":569,"../drawers/drawer":568,"../drawers/rectangleDrawer":571,"../memoize":584,"../scales":607,"../scales/quantitativeScale":612,"../utils":624,"../utils/makeEnum":625,"./":594,"./plot":597,"./xyPlot":604,"d3":414,"tslib":635,"typesettable":640}],591:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusteredBar = void 0;
var tslib_1 = require("tslib");
var Scales = require("../scales");
var Utils = require("../utils");
var barPlot_1 = require("./barPlot");
var plot_1 = require("./plot");
var ClusteredBar = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ClusteredBar, _super);
    /**
     * A ClusteredBar Plot groups bars across Datasets based on the primary value of the bars.
     *   On a vertical ClusteredBar Plot, the bars with the same X value are grouped.
     *   On a horizontal ClusteredBar Plot, the bars with the same Y value are grouped.
     *
     * @constructor
     * @param {string} [orientation="vertical"] One of "vertical"/"horizontal".
     */
    function ClusteredBar(orientation) {
        if (orientation === void 0) { orientation = "vertical"; }
        var _this = _super.call(this, orientation) || this;
        _this._clusterOffsets = new Utils.Map();
        return _this;
    }
    ClusteredBar.prototype._generateAttrToProjector = function () {
        var _this = this;
        var attrToProjector = _super.prototype._generateAttrToProjector.call(this);
        // the width is constant, so set the inner scale range to that
        var innerScale = this._makeInnerScale();
        var innerWidthF = function (d, i) { return innerScale.rangeBand(); };
        attrToProjector["width"] = this._isVertical ? innerWidthF : attrToProjector["width"];
        attrToProjector["height"] = !this._isVertical ? innerWidthF : attrToProjector["height"];
        var xAttr = attrToProjector["x"];
        var yAttr = attrToProjector["y"];
        attrToProjector["x"] = this._isVertical ?
            function (d, i, ds) { return xAttr(d, i, ds) + _this._clusterOffsets.get(ds); } :
            function (d, i, ds) { return xAttr(d, i, ds); };
        attrToProjector["y"] = this._isVertical ?
            function (d, i, ds) { return yAttr(d, i, ds); } :
            function (d, i, ds) { return yAttr(d, i, ds) + _this._clusterOffsets.get(ds); };
        return attrToProjector;
    };
    ClusteredBar.prototype._updateClusterPosition = function () {
        var _this = this;
        var innerScale = this._makeInnerScale();
        this.datasets().forEach(function (d, i) { return _this._clusterOffsets.set(d, innerScale.scale(String(i)) - innerScale.rangeBand() / 2); });
    };
    ClusteredBar.prototype._makeInnerScale = function () {
        var innerScale = new Scales.Category();
        innerScale.domain(this.datasets().map(function (d, i) { return String(i); }));
        var widthProjector = plot_1.Plot._scaledAccessor(this.attr(barPlot_1.Bar._BAR_THICKNESS_KEY));
        innerScale.range([0, widthProjector(null, 0, null)]);
        return innerScale;
    };
    ClusteredBar.prototype._getDataToDraw = function () {
        this._updateClusterPosition();
        return _super.prototype._getDataToDraw.call(this);
    };
    return ClusteredBar;
}(barPlot_1.Bar));
exports.ClusteredBar = ClusteredBar;

},{"../scales":607,"../utils":624,"./barPlot":590,"./plot":597,"tslib":635}],592:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Animator = void 0;
var Animator;
(function (Animator) {
    Animator.MAIN = "main";
    Animator.RESET = "reset";
})(Animator = exports.Animator || (exports.Animator = {}));

},{}],593:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeferredRenderer = void 0;
/**
 * Stores the deferred transformation state for a single scale.
 */
var DomainTransform = /** @class */ (function () {
    function DomainTransform() {
        var _this = this;
        this.scale = 0;
        this.translate = 0;
        this.cachedDomain = [null, null];
        this.lastSeenDomain = [null, null];
        this.updateDomain = function (scale) {
            _this.lastSeenDomain = scale.getTransformationDomain();
            var cachedLength = scale.scaleTransformation(_this.cachedDomain[1]) - scale.scaleTransformation(_this.cachedDomain[0]);
            var lastSeenLength = scale.scaleTransformation(_this.lastSeenDomain[1]) - scale.scaleTransformation(_this.lastSeenDomain[0]);
            _this.scale = (cachedLength / lastSeenLength) || 1;
            _this.translate = scale.scaleTransformation(_this.cachedDomain[0]) - scale.scaleTransformation(_this.lastSeenDomain[0]) * _this.scale || 0;
        };
    }
    DomainTransform.prototype.reset = function () {
        this.scale = 1;
        this.translate = 0;
        this.cachedDomain = this.lastSeenDomain;
    };
    DomainTransform.prototype.setDomain = function (scale) {
        this.cachedDomain = scale.getTransformationDomain();
    };
    return DomainTransform;
}());
/**
 * Manages deferred rendering callbacks.
 *
 * Call `setDomains` when deferred rendering is initially enabled to fix the
 * current domain values.
 *
 * Call `updateDomains` when scale domains change, which uses the domain to
 * compute CSS-tyle transform parameters passed to `applyTransformCallback`,
 * mimicking the result of a full re-render. After a deferred timeout, invoke
 * `applyTransformCallback` again with an identity transform and finally invoke
 * `renderCallback`, which should actually redraw the plot.
 *
 * Call `resetTransforms` just prior to re-rendering into the canvas. This
 * ensures that the canvas is at 1:1 scaling.
 */
var DeferredRenderer = /** @class */ (function () {
    function DeferredRenderer(renderCallback, applyTransformCallback) {
        var _this = this;
        this.renderCallback = renderCallback;
        this.applyTransformCallback = applyTransformCallback;
        this.domainTransformX = new DomainTransform();
        this.domainTransformY = new DomainTransform();
        this.renderDeferred = function () {
            _this.applyTransform();
            clearTimeout(_this.timeoutToken);
            _this.timeoutToken = setTimeout(function () {
                _this.renderCallback();
            }, DeferredRenderer.DEFERRED_RENDERING_DELAY);
        };
    }
    DeferredRenderer.prototype.setDomains = function (scaleX, scaleY) {
        if (scaleX) {
            this.domainTransformX.setDomain(scaleX);
        }
        if (scaleY) {
            this.domainTransformY.setDomain(scaleY);
        }
        this.renderDeferred();
    };
    DeferredRenderer.prototype.updateDomains = function (scaleX, scaleY) {
        if (scaleX) {
            this.domainTransformX.updateDomain(scaleX);
        }
        if (scaleY) {
            this.domainTransformY.updateDomain(scaleY);
        }
        this.renderDeferred();
    };
    DeferredRenderer.prototype.resetTransforms = function () {
        this.domainTransformX.reset();
        this.domainTransformY.reset();
        this.applyTransform();
    };
    DeferredRenderer.prototype.applyTransform = function () {
        this.applyTransformCallback(this.domainTransformX.translate, this.domainTransformY.translate, this.domainTransformX.scale, this.domainTransformY.scale);
    };
    DeferredRenderer.DEFERRED_RENDERING_DELAY = 200;
    return DeferredRenderer;
}());
exports.DeferredRenderer = DeferredRenderer;

},{}],594:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
(0, tslib_1.__exportStar)(require("./areaPlot"), exports);
(0, tslib_1.__exportStar)(require("./barPlot"), exports);
(0, tslib_1.__exportStar)(require("./commons"), exports);
(0, tslib_1.__exportStar)(require("./clusteredBarPlot"), exports);
(0, tslib_1.__exportStar)(require("./linePlot"), exports);
(0, tslib_1.__exportStar)(require("./piePlot"), exports);
(0, tslib_1.__exportStar)(require("./rectanglePlot"), exports);
(0, tslib_1.__exportStar)(require("./scatterPlot"), exports);
(0, tslib_1.__exportStar)(require("./segmentPlot"), exports);
(0, tslib_1.__exportStar)(require("./stackedAreaPlot"), exports);
(0, tslib_1.__exportStar)(require("./stackedBarPlot"), exports);
(0, tslib_1.__exportStar)(require("./waterfallPlot"), exports);

},{"./areaPlot":589,"./barPlot":590,"./clusteredBarPlot":591,"./commons":592,"./linePlot":595,"./piePlot":596,"./rectanglePlot":598,"./scatterPlot":599,"./segmentPlot":600,"./stackedAreaPlot":601,"./stackedBarPlot":602,"./waterfallPlot":603,"tslib":635}],595:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Line = exports.CurveName = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Animators = require("../animators");
var Drawers = require("../drawers");
var drawer_1 = require("../drawers/drawer");
var lineDrawer_1 = require("../drawers/lineDrawer");
var Scales = require("../scales");
var quantitativeScale_1 = require("../scales/quantitativeScale");
var Utils = require("../utils");
var makeEnum_1 = require("../utils/makeEnum");
var Plots = require("./");
var plot_1 = require("./plot");
var xyPlot_1 = require("./xyPlot");
var CURVE_NAME_MAPPING = {
    linear: d3.curveLinear,
    linearClosed: d3.curveLinearClosed,
    step: d3.curveStep,
    stepBefore: d3.curveStepBefore,
    stepAfter: d3.curveStepAfter,
    basis: d3.curveBasis,
    basisOpen: d3.curveBasisOpen,
    basisClosed: d3.curveBasisClosed,
    bundle: d3.curveBundle,
    cardinal: d3.curveCardinal,
    cardinalOpen: d3.curveCardinalOpen,
    cardinalClosed: d3.curveCardinalClosed,
    monotone: d3.curveMonotoneX,
};
/**
 * Known curve types that line and area plot's .curve() methods understand
 */
exports.CurveName = (0, makeEnum_1.makeEnum)([
    "linear",
    "linearClosed",
    "step",
    "stepBefore",
    "stepAfter",
    "basis",
    "basisOpen",
    "basisClosed",
    "bundle",
    "cardinal",
    "cardinalOpen",
    "cardinalClosed",
    "monotone",
]);
var Line = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Line, _super);
    /**
     * A Line Plot draws line segments starting from the first data point to the next.
     *
     * @constructor
     */
    function Line() {
        var _this = _super.call(this) || this;
        _this._curve = "linear";
        _this._autorangeSmooth = false;
        _this._croppedRenderingEnabled = true;
        _this._collapseDenseVerticalLinesEnabled = false;
        _this._downsamplingEnabled = false;
        _this.addClass("line-plot");
        var animator = new Animators.Easing();
        animator.stepDuration(plot_1.Plot._ANIMATION_MAX_DURATION);
        animator.easingMode("expInOut");
        animator.maxTotalDuration(plot_1.Plot._ANIMATION_MAX_DURATION);
        _this.animator(Plots.Animator.MAIN, animator);
        _this.attr("stroke", new Scales.Color().range()[0]);
        _this.attr("stroke-width", "2px");
        return _this;
    }
    Line.prototype.x = function (x, xScale, postScale) {
        if (x == null) {
            return _super.prototype.x.call(this);
        }
        else {
            _super.prototype.x.call(this, x, xScale, postScale);
            this._setScaleSnapping();
            return this;
        }
    };
    Line.prototype.y = function (y, yScale, postScale) {
        if (y == null) {
            return _super.prototype.y.call(this);
        }
        else {
            _super.prototype.y.call(this, y, yScale, postScale);
            this._setScaleSnapping();
            return this;
        }
    };
    Line.prototype.autorangeMode = function (autorangeMode) {
        if (autorangeMode == null) {
            return _super.prototype.autorangeMode.call(this);
        }
        _super.prototype.autorangeMode.call(this, autorangeMode);
        this._setScaleSnapping();
        return this;
    };
    Line.prototype.autorangeSmooth = function (autorangeSmooth) {
        if (autorangeSmooth == null) {
            return this._autorangeSmooth;
        }
        this._autorangeSmooth = autorangeSmooth;
        this._setScaleSnapping();
        return this;
    };
    Line.prototype._setScaleSnapping = function () {
        if (this.autorangeMode() === "x" && this.x() && this.x().scale && this.x().scale instanceof quantitativeScale_1.QuantitativeScale) {
            this.x().scale.snappingDomainEnabled(!this.autorangeSmooth());
        }
        if (this.autorangeMode() === "y" && this.y() && this.y().scale && this.y().scale instanceof quantitativeScale_1.QuantitativeScale) {
            this.y().scale.snappingDomainEnabled(!this.autorangeSmooth());
        }
    };
    Line.prototype.curve = function (curve) {
        if (curve == null) {
            return this._curve;
        }
        this._curve = curve;
        this.render();
        return this;
    };
    Line.prototype.downsamplingEnabled = function (downsampling) {
        if (downsampling == null) {
            return this._downsamplingEnabled;
        }
        this._downsamplingEnabled = downsampling;
        return this;
    };
    Line.prototype.croppedRenderingEnabled = function (croppedRendering) {
        if (croppedRendering == null) {
            return this._croppedRenderingEnabled;
        }
        this._croppedRenderingEnabled = croppedRendering;
        this.render();
        return this;
    };
    Line.prototype.collapseDenseLinesEnabled = function (collapseDenseLines) {
        if (collapseDenseLines == null) {
            return this._collapseDenseVerticalLinesEnabled;
        }
        this._collapseDenseVerticalLinesEnabled = collapseDenseLines;
        this.render();
        return this;
    };
    Line.prototype._createDrawer = function (dataset) {
        var _this = this;
        return new drawer_1.ProxyDrawer(function () { return new lineDrawer_1.LineSVGDrawer(); }, function (ctx) { return new Drawers.CanvasDrawer(ctx, (0, lineDrawer_1.makeLineCanvasDrawStep)(function () { return _this._d3LineFactory(dataset); })); });
    };
    Line.prototype.getExtentsForProperty = function (property) {
        var extents = _super.prototype.getExtentsForProperty.call(this, property);
        if (!this._autorangeSmooth) {
            return extents;
        }
        if (this.autorangeMode() !== property) {
            return extents;
        }
        if (this.autorangeMode() !== "x" && this.autorangeMode() !== "y") {
            return extents;
        }
        var edgeIntersectionPoints = this._getEdgeIntersectionPoints();
        var includedValues;
        if (this.autorangeMode() === "y") {
            includedValues = edgeIntersectionPoints.left.concat(edgeIntersectionPoints.right).map(function (point) { return point.y; });
        }
        else { // === "x"
            includedValues = edgeIntersectionPoints.top.concat(edgeIntersectionPoints.bottom).map(function (point) { return point.x; });
        }
        return extents.map(function (extent) { return d3.extent(d3.merge([extent, includedValues])); });
    };
    Line.prototype._getEdgeIntersectionPoints = function () {
        var _this = this;
        if (!(this.y().scale instanceof quantitativeScale_1.QuantitativeScale && this.x().scale instanceof quantitativeScale_1.QuantitativeScale)) {
            return {
                left: [],
                right: [],
                top: [],
                bottom: [],
            };
        }
        var yScale = this.y().scale;
        var xScale = this.x().scale;
        var intersectionPoints = {
            left: [],
            right: [],
            top: [],
            bottom: [],
        };
        var leftX = xScale.scale(xScale.domain()[0]);
        var rightX = xScale.scale(xScale.domain()[1]);
        var bottomY = yScale.scale(yScale.domain()[0]);
        var topY = yScale.scale(yScale.domain()[1]);
        this.datasets().forEach(function (dataset) {
            var data = dataset.data();
            var x1, x2, y1, y2;
            var prevX, prevY, currX, currY;
            for (var i = 1; i < data.length; i++) {
                prevX = currX || xScale.scale(_this.x().accessor(data[i - 1], i - 1, dataset));
                prevY = currY || yScale.scale(_this.y().accessor(data[i - 1], i - 1, dataset));
                currX = xScale.scale(_this.x().accessor(data[i], i, dataset));
                currY = yScale.scale(_this.y().accessor(data[i], i, dataset));
                // If values crossed left edge
                if ((prevX < leftX) === (leftX <= currX)) {
                    x1 = leftX - prevX;
                    x2 = currX - prevX;
                    y2 = currY - prevY;
                    y1 = x1 * y2 / x2;
                    intersectionPoints.left.push({
                        x: leftX,
                        y: yScale.invert(prevY + y1),
                    });
                }
                // If values crossed right edge
                if ((prevX < rightX) === (rightX <= currX)) {
                    x1 = rightX - prevX;
                    x2 = currX - prevX;
                    y2 = currY - prevY;
                    y1 = x1 * y2 / x2;
                    intersectionPoints.right.push({
                        x: rightX,
                        y: yScale.invert(prevY + y1),
                    });
                }
                // If values crossed upper edge
                if ((prevY < topY) === (topY <= currY)) {
                    x2 = currX - prevX;
                    y1 = topY - prevY;
                    y2 = currY - prevY;
                    x1 = y1 * x2 / y2;
                    intersectionPoints.top.push({
                        x: xScale.invert(prevX + x1),
                        y: topY,
                    });
                }
                // If values crossed lower edge
                if ((prevY < bottomY) === (bottomY <= currY)) {
                    x2 = currX - prevX;
                    y1 = bottomY - prevY;
                    y2 = currY - prevY;
                    x1 = y1 * x2 / y2;
                    intersectionPoints.bottom.push({
                        x: xScale.invert(prevX + x1),
                        y: bottomY,
                    });
                }
            }
        });
        return intersectionPoints;
    };
    Line.prototype._getResetYFunction = function () {
        // gets the y-value generator for the animation start point
        var yDomain = this.y().scale.domain();
        var domainMax = Math.max(yDomain[0], yDomain[1]);
        var domainMin = Math.min(yDomain[0], yDomain[1]);
        // start from zero, or the closest domain value to zero
        // avoids lines zooming on from offscreen.
        var startValue = (domainMax < 0 && domainMax) || (domainMin > 0 && domainMin) || 0;
        var scaledStartValue = this.y().scale.scale(startValue);
        return function (d, i, dataset) { return scaledStartValue; };
    };
    Line.prototype._generateDrawSteps = function () {
        var drawSteps = [];
        if (this._animateOnNextRender()) {
            var attrToProjector = this._getAttrToProjector();
            attrToProjector["d"] = this._constructLineProjector(plot_1.Plot._scaledAccessor(this.x()), this._getResetYFunction());
            drawSteps.push({ attrToProjector: attrToProjector, animator: this._getAnimator(Plots.Animator.RESET) });
        }
        drawSteps.push({
            attrToProjector: this._getAttrToProjector(),
            animator: this._getAnimator(Plots.Animator.MAIN),
        });
        return drawSteps;
    };
    Line.prototype._generateAttrToProjector = function () {
        var attrToProjector = _super.prototype._generateAttrToProjector.call(this);
        Object.keys(attrToProjector).forEach(function (attribute) {
            if (attribute === "d") {
                return;
            }
            var projector = attrToProjector[attribute];
            attrToProjector[attribute] = function (data, i, dataset) {
                return data.length > 0 ? projector(data[0], i, dataset) : null;
            };
        });
        return attrToProjector;
    };
    Line.prototype.entitiesAt = function (point) {
        var entity = this.entityNearestByXThenY(point);
        if (entity != null) {
            return [entity];
        }
        else {
            return [];
        }
    };
    /**
     * Returns the PlotEntity nearest to the query point by X then by Y, or undefined if no PlotEntity can be found.
     *
     * @param {Point} queryPoint
     * @returns {PlotEntity} The nearest PlotEntity, or undefined if no PlotEntity can be found.
     */
    Line.prototype.entityNearestByXThenY = function (queryPoint) {
        var minXDist = Infinity;
        var minYDist = Infinity;
        var closest;
        var chartBounds = this.bounds();
        var entities = this.entities();
        var entityLen = entities.length;
        for (var i = 0; i < entityLen; i++) {
            var entity = entities[i];
            if (!Utils.Math.within(entity.position, chartBounds)) {
                continue;
            }
            var xDist = Math.abs(queryPoint.x - entity.position.x);
            var yDist = Math.abs(queryPoint.y - entity.position.y);
            if (xDist < minXDist || xDist === minXDist && yDist < minYDist) {
                closest = entity;
                minXDist = xDist;
                minYDist = yDist;
            }
        }
        return closest;
    };
    Line.prototype._propertyProjectors = function () {
        var propertyToProjectors = _super.prototype._propertyProjectors.call(this);
        propertyToProjectors["d"] = this._constructLineProjector(plot_1.Plot._scaledAccessor(this.x()), plot_1.Plot._scaledAccessor(this.y()));
        return propertyToProjectors;
    };
    Line.prototype._constructLineProjector = function (xProjector, yProjector) {
        var _this = this;
        return function (datum, index, dataset) {
            return _this._d3LineFactory(dataset, xProjector, yProjector)(datum);
        };
    };
    /**
     * Return a d3.Line whose .x, .y, and .defined accessors are hooked up to the xProjector and yProjector
     * after they've been fed the dataset, and whose curve is configured to this plot's curve.
     * @param dataset
     * @param xProjector
     * @param yProjector
     * @returns {Line<[number,number]>}
     * @private
     */
    Line.prototype._d3LineFactory = function (dataset, xProjector, yProjector) {
        if (xProjector === void 0) { xProjector = plot_1.Plot._scaledAccessor(this.x()); }
        if (yProjector === void 0) { yProjector = plot_1.Plot._scaledAccessor(this.y()); }
        var definedProjector = function (d, i, dataset) {
            var positionX = xProjector(d, i, dataset);
            var positionY = yProjector(d, i, dataset);
            return Utils.Math.isValidNumber(positionX) && Utils.Math.isValidNumber(positionY);
        };
        return d3.line()
            .x(function (innerDatum, innerIndex) { return xProjector(innerDatum, innerIndex, dataset); })
            .y(function (innerDatum, innerIndex) { return yProjector(innerDatum, innerIndex, dataset); })
            .curve(this._getCurveFactory())
            .defined(function (innerDatum, innerIndex) { return definedProjector(innerDatum, innerIndex, dataset); });
    };
    Line.prototype._getCurveFactory = function () {
        var curve = this.curve();
        if (typeof curve === "string") {
            var maybeCurveFunction = CURVE_NAME_MAPPING[curve];
            if (maybeCurveFunction == null) {
                // oops; name is wrong - default to linear instead
                return CURVE_NAME_MAPPING["linear"];
            }
            else {
                return maybeCurveFunction;
            }
        }
        else {
            return curve;
        }
    };
    /**
     * Line plots represent each dataset with a single <path> element, so we wrap the dataset data in a single element array.
     * @returns {Map<Dataset, any[]>}
     * @private
     */
    Line.prototype._getDataToDraw = function () {
        var _this = this;
        var dataToDraw = new Utils.Map();
        this.datasets().forEach(function (dataset) {
            var data = dataset.data();
            if (!_this._croppedRenderingEnabled && !_this._downsamplingEnabled) {
                dataToDraw.set(dataset, [data]);
                return;
            }
            var filteredDataIndices = [];
            var dataLen = data.length;
            for (var i = 0; i < dataLen; i++) {
                filteredDataIndices[i] = i;
            }
            if (_this._croppedRenderingEnabled) {
                filteredDataIndices = _this._filterCroppedRendering(dataset, filteredDataIndices);
            }
            if (_this._downsamplingEnabled) {
                filteredDataIndices = _this._filterDownsampling(dataset, filteredDataIndices);
            }
            if (_this._collapseDenseVerticalLinesEnabled) {
                filteredDataIndices = _this._filterDenseLines(dataset, filteredDataIndices);
            }
            var filteredData = [];
            var filteredIndicesLen = filteredDataIndices.length;
            for (var i = 0; i < filteredIndicesLen; i++) {
                var index = filteredDataIndices[i];
                filteredData[i] = data[index];
            }
            dataToDraw.set(dataset, [filteredData]);
        });
        return dataToDraw;
    };
    Line.prototype._filterCroppedRendering = function (dataset, indices) {
        var _this = this;
        var xProjector = plot_1.Plot._scaledAccessor(this.x());
        var yProjector = plot_1.Plot._scaledAccessor(this.y());
        var data = dataset.data();
        var filteredDataIndices = [];
        var pointInViewport = function (x, y) {
            return Utils.Math.inRange(x, 0, _this.width()) &&
                Utils.Math.inRange(y, 0, _this.height());
        };
        for (var i = 0; i < indices.length; i++) {
            var currXPoint = xProjector(data[indices[i]], indices[i], dataset);
            var currYPoint = yProjector(data[indices[i]], indices[i], dataset);
            var shouldShow = pointInViewport(currXPoint, currYPoint);
            if (!shouldShow && indices[i - 1] != null && data[indices[i - 1]] != null) {
                var prevXPoint = xProjector(data[indices[i - 1]], indices[i - 1], dataset);
                var prevYPoint = yProjector(data[indices[i - 1]], indices[i - 1], dataset);
                shouldShow = shouldShow || pointInViewport(prevXPoint, prevYPoint);
            }
            if (!shouldShow && indices[i + 1] != null && data[indices[i + 1]] != null) {
                var nextXPoint = xProjector(data[indices[i + 1]], indices[i + 1], dataset);
                var nextYPoint = yProjector(data[indices[i + 1]], indices[i + 1], dataset);
                shouldShow = shouldShow || pointInViewport(nextXPoint, nextYPoint);
            }
            if (shouldShow) {
                filteredDataIndices.push(indices[i]);
            }
        }
        return filteredDataIndices;
    };
    Line.prototype._filterDownsampling = function (dataset, indices) {
        if (indices.length === 0) {
            return [];
        }
        var data = dataset.data();
        var scaledXAccessor = plot_1.Plot._scaledAccessor(this.x());
        var scaledYAccessor = plot_1.Plot._scaledAccessor(this.y());
        var filteredIndices = [indices[0]];
        var indexOnCurrentSlope = function (i, currentSlope) {
            var p1x = scaledXAccessor(data[indices[i]], indices[i], dataset);
            var p1y = scaledYAccessor(data[indices[i]], indices[i], dataset);
            var p2x = scaledXAccessor(data[indices[i + 1]], indices[i + 1], dataset);
            var p2y = scaledYAccessor(data[indices[i + 1]], indices[i + 1], dataset);
            if (currentSlope === Infinity) {
                return Math.floor(p1x) === Math.floor(p2x);
            }
            else {
                var expectedP2y = p1y + (p2x - p1x) * currentSlope;
                return Math.floor(p2y) === Math.floor(expectedP2y);
            }
        };
        for (var i = 0; i < indices.length - 1;) {
            var indexFirst = indices[i];
            var p1x = scaledXAccessor(data[indices[i]], indices[i], dataset);
            var p1y = scaledYAccessor(data[indices[i]], indices[i], dataset);
            var p2x = scaledXAccessor(data[indices[i + 1]], indices[i + 1], dataset);
            var p2y = scaledYAccessor(data[indices[i + 1]], indices[i + 1], dataset);
            var currentSlope = (Math.floor(p1x) === Math.floor(p2x)) ? Infinity : (p2y - p1y) / (p2x - p1x);
            var indexMin = indices[i];
            var minScaledValue = (currentSlope === Infinity) ? p1y : p1x;
            var indexMax = indexMin;
            var maxScaledValue = minScaledValue;
            var firstIndexOnCurrentSlope = true;
            while (i < indices.length - 1 && (firstIndexOnCurrentSlope || indexOnCurrentSlope(i, currentSlope))) {
                i++;
                firstIndexOnCurrentSlope = false;
                var currScaledValue = currentSlope === Infinity ? scaledYAccessor(data[indices[i]], indices[i], dataset) :
                    scaledXAccessor(data[indices[i]], indices[i], dataset);
                if (currScaledValue > maxScaledValue) {
                    maxScaledValue = currScaledValue;
                    indexMax = indices[i];
                }
                if (currScaledValue < minScaledValue) {
                    minScaledValue = currScaledValue;
                    indexMin = indices[i];
                }
            }
            var indexLast = indices[i];
            if (indexMin !== indexFirst) {
                filteredIndices.push(indexMin);
            }
            if (indexMax !== indexMin && indexMax !== indexFirst) {
                filteredIndices.push(indexMax);
            }
            if (indexLast !== indexFirst && indexLast !== indexMin && indexLast !== indexMax) {
                filteredIndices.push(indexLast);
            }
        }
        return filteredIndices;
    };
    /**
     * Collapse line geometry
     *
     * Assuming that there are many points that are drawn on the same coordinate,
     * we can save a lot of render time by just drawing one line from the min to
     * max y-coordinate of all those points.
     */
    Line.prototype._filterDenseLines = function (dataset, indices) {
        if (indices.length === 0) {
            return [];
        }
        var data = dataset.data();
        var scaledXAccessor = plot_1.Plot._scaledAccessor(this.x());
        var scaledYAccessor = plot_1.Plot._scaledAccessor(this.y());
        var xFn = function (i) { return scaledXAccessor(data[i], i, dataset); };
        var yFn = function (i) { return scaledYAccessor(data[i], i, dataset); };
        // TODO determine if we should collapse x or y or not collapse at all.
        // For now, we assume line charts are always a function of x
        return this._bucketByX(dataset, indices, xFn, yFn);
    };
    /**
     * Iterates over the line points collapsing points that fall on the same
     * floored x coordinate.
     *
     * Once all the points with the same x coordinate are detected, we draw a
     * single line from the min to max y coorindate.
     *
     * The "entrance" and "exit" lines to/from this collapsed vertical line are
     * also drawn. This allows lines with no collapsed segments to render
     * correctly.
     */
    Line.prototype._bucketByX = function (dataset, indices, xFn, yFn) {
        var filteredIndices = [];
        var data = dataset.data();
        var bucket = null;
        var indicesLength = indices.length;
        for (var ii = 0; ii <= indicesLength; ++ii) {
            var i = indices[ii];
            if (data[i] == null) {
                continue;
            }
            var x = Math.floor(xFn(i));
            var y = yFn(i);
            if (bucket == null) {
                bucket = new Utils.Bucket(i, x, y);
            }
            else if (bucket.isInBucket(x)) {
                bucket.addToBucket(y, i);
            }
            else {
                filteredIndices.push.apply(filteredIndices, bucket.getUniqueIndices());
                bucket = new Utils.Bucket(i, x, y);
            }
        }
        if (bucket != null) {
            filteredIndices.push.apply(filteredIndices, bucket.getUniqueIndices());
        }
        return filteredIndices;
    };
    return Line;
}(xyPlot_1.XYPlot));
exports.Line = Line;

},{"../animators":525,"../drawers":569,"../drawers/drawer":568,"../drawers/lineDrawer":570,"../scales":607,"../scales/quantitativeScale":612,"../utils":624,"../utils/makeEnum":625,"./":594,"./plot":597,"./xyPlot":604,"d3":414,"tslib":635}],596:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pie = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Typesettable = require("typesettable");
var Animators = require("../animators");
var Formatters = require("../core/formatters");
var Scales = require("../scales");
var Utils = require("../utils");
var arcDrawer_1 = require("../drawers/arcDrawer");
var arcOutlineDrawer_1 = require("../drawers/arcOutlineDrawer");
var drawer_1 = require("../drawers/drawer");
var windowUtils_1 = require("../utils/windowUtils");
var plot_1 = require("./plot");
var Pie = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Pie, _super);
    /**
     * @constructor
     */
    function Pie() {
        var _this = _super.call(this) || this;
        _this._startAngle = 0;
        _this._endAngle = 2 * Math.PI;
        _this._labelFormatter = Formatters.identity();
        _this._labelsEnabled = false;
        _this.innerRadius(0);
        _this.outerRadius(function () {
            var pieCenter = _this._pieCenter();
            return Math.min(Math.max(_this.width() - pieCenter.x, pieCenter.x), Math.max(_this.height() - pieCenter.y, pieCenter.y));
        });
        _this.addClass("pie-plot");
        _this.attr("fill", function (d, i) { return String(i); }, new Scales.Color());
        _this._strokeDrawers = new Utils.Map();
        return _this;
    }
    Pie.prototype._setup = function () {
        var _this = this;
        _super.prototype._setup.call(this);
        this._strokeDrawers.forEach(function (d) { return d.attachTo(_this._renderArea); });
    };
    Pie.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        var pieCenter = this._pieCenter();
        this._renderArea.attr("transform", "translate(" + pieCenter.x + "," + pieCenter.y + ")");
        var radiusLimit = Math.min(Math.max(this.width() - pieCenter.x, pieCenter.x), Math.max(this.height() - pieCenter.y, pieCenter.y));
        if (this.innerRadius().scale != null) {
            this.innerRadius().scale.range([0, radiusLimit]);
        }
        if (this.outerRadius().scale != null) {
            this.outerRadius().scale.range([0, radiusLimit]);
        }
        return this;
    };
    Pie.prototype.addDataset = function (dataset) {
        _super.prototype.addDataset.call(this, dataset);
        return this;
    };
    Pie.prototype._addDataset = function (dataset) {
        if (this.datasets().length === 1) {
            Utils.Window.warn("Only one dataset is supported in Pie plots");
            return this;
        }
        this._updatePieAngles();
        _super.prototype._addDataset.call(this, dataset);
        var strokeDrawer = new arcOutlineDrawer_1.ArcOutlineSVGDrawer();
        if (this._isSetup) {
            strokeDrawer.attachTo(this._renderArea);
        }
        this._strokeDrawers.set(dataset, strokeDrawer);
        return this;
    };
    Pie.prototype.removeDataset = function (dataset) {
        _super.prototype.removeDataset.call(this, dataset);
        return this;
    };
    Pie.prototype._removeDatasetNodes = function (dataset) {
        _super.prototype._removeDatasetNodes.call(this, dataset);
        this._strokeDrawers.get(dataset).remove();
    };
    Pie.prototype._removeDataset = function (dataset) {
        _super.prototype._removeDataset.call(this, dataset);
        this._strokeDrawers.delete(dataset);
        this._startAngles = [];
        this._endAngles = [];
        return this;
    };
    Pie.prototype.selections = function (datasets) {
        var _this = this;
        if (datasets === void 0) { datasets = this.datasets(); }
        var allSelections = _super.prototype.selections.call(this, datasets).nodes();
        datasets.forEach(function (dataset) {
            var drawer = _this._strokeDrawers.get(dataset);
            if (drawer == null) {
                return;
            }
            allSelections.push.apply(allSelections, drawer.getVisualPrimitives());
        });
        return d3.selectAll(allSelections);
    };
    Pie.prototype._onDatasetUpdate = function () {
        _super.prototype._onDatasetUpdate.call(this);
        this._updatePieAngles();
        this.render();
    };
    Pie.prototype._createDrawer = function () {
        return new drawer_1.ProxyDrawer(function () { return new arcDrawer_1.ArcSVGDrawer(); }, function () {
            (0, windowUtils_1.warn)("canvas renderer is not supported on Pie Plot!");
            return null;
        });
    };
    Pie.prototype.entities = function (datasets) {
        var _this = this;
        if (datasets === void 0) { datasets = this.datasets(); }
        var entities = _super.prototype.entities.call(this, datasets);
        return entities.map(function (entity) {
            entity.position.x += _this.width() / 2;
            entity.position.y += _this.height() / 2;
            var stroke = d3.select(_this._strokeDrawers.get(entity.dataset).getVisualPrimitiveAtIndex(entity.index));
            var piePlotEntity = entity;
            piePlotEntity.strokeSelection = stroke;
            return piePlotEntity;
        });
    };
    Pie.prototype.sectorValue = function (sectorValue, scale) {
        if (sectorValue == null) {
            return this._propertyBindings.get(Pie._SECTOR_VALUE_KEY);
        }
        this._bindProperty(Pie._SECTOR_VALUE_KEY, sectorValue, scale);
        this._updatePieAngles();
        this.render();
        return this;
    };
    Pie.prototype.innerRadius = function (innerRadius, scale) {
        if (innerRadius == null) {
            return this._propertyBindings.get(Pie._INNER_RADIUS_KEY);
        }
        this._bindProperty(Pie._INNER_RADIUS_KEY, innerRadius, scale);
        this.render();
        return this;
    };
    Pie.prototype.outerRadius = function (outerRadius, scale) {
        if (outerRadius == null) {
            return this._propertyBindings.get(Pie._OUTER_RADIUS_KEY);
        }
        this._bindProperty(Pie._OUTER_RADIUS_KEY, outerRadius, scale);
        this.render();
        return this;
    };
    Pie.prototype.startAngle = function (angle) {
        if (angle == null) {
            return this._startAngle;
        }
        else {
            this._startAngle = angle;
            this._updatePieAngles();
            this.render();
            return this;
        }
    };
    Pie.prototype.endAngle = function (angle) {
        if (angle == null) {
            return this._endAngle;
        }
        else {
            this._endAngle = angle;
            this._updatePieAngles();
            this.render();
            return this;
        }
    };
    Pie.prototype.labelsEnabled = function (enabled) {
        if (enabled == null) {
            return this._labelsEnabled;
        }
        else {
            this._labelsEnabled = enabled;
            this.render();
            return this;
        }
    };
    Pie.prototype.labelFormatter = function (formatter) {
        if (formatter == null) {
            return this._labelFormatter;
        }
        else {
            this._labelFormatter = formatter;
            this.render();
            return this;
        }
    };
    /*
     * Gets the Entities at a particular Point.
     *
     * @param {Point} p
     * @param {PlotEntity[]}
     */
    Pie.prototype.entitiesAt = function (queryPoint) {
        var center = { x: this.width() / 2, y: this.height() / 2 };
        var adjustedQueryPoint = { x: queryPoint.x - center.x, y: queryPoint.y - center.y };
        var index = this._sliceIndexForPoint(adjustedQueryPoint);
        return index == null ? [] : [this.entities()[index]];
    };
    Pie.prototype._propertyProjectors = function () {
        var _this = this;
        var attrToProjector = _super.prototype._propertyProjectors.call(this);
        var innerRadiusAccessor = plot_1.Plot._scaledAccessor(this.innerRadius());
        var outerRadiusAccessor = plot_1.Plot._scaledAccessor(this.outerRadius());
        attrToProjector["d"] = function (datum, index, ds) {
            return d3.arc().innerRadius(innerRadiusAccessor(datum, index, ds))
                .outerRadius(outerRadiusAccessor(datum, index, ds))
                .startAngle(_this._startAngles[index])
                .endAngle(_this._endAngles[index])(datum, index);
        };
        return attrToProjector;
    };
    Pie.prototype._updatePieAngles = function () {
        if (this.sectorValue() == null) {
            return;
        }
        if (this.datasets().length === 0) {
            return;
        }
        var sectorValueAccessor = plot_1.Plot._scaledAccessor(this.sectorValue());
        var dataset = this.datasets()[0];
        var data = this._getDataToDraw().get(dataset);
        var pie = d3.pie().sort(null).startAngle(this._startAngle).endAngle(this._endAngle)
            .value(function (d, i) { return sectorValueAccessor(d, i, dataset); })(data);
        this._startAngles = pie.map(function (slice) { return slice.startAngle; });
        this._endAngles = pie.map(function (slice) { return slice.endAngle; });
    };
    Pie.prototype._pieCenter = function () {
        var a = this._startAngle < this._endAngle ? this._startAngle : this._endAngle;
        var b = this._startAngle < this._endAngle ? this._endAngle : this._startAngle;
        var sinA = Math.sin(a);
        var cosA = Math.cos(a);
        var sinB = Math.sin(b);
        var cosB = Math.cos(b);
        var hTop;
        var hBottom;
        var wRight;
        var wLeft;
        /**
         *  The center of the pie is computed using the sine and cosine of the start angle and the end angle
         *  The sine indicates whether the start and end fall on the right half or the left half of the pie
         *  The cosine indicates whether the start and end fall on the top or the bottom half of the pie
         *  Different combinations provide the different heights and widths the pie needs from the center to the sides
         */
        if (sinA >= 0 && sinB >= 0) {
            if (cosA >= 0 && cosB >= 0) {
                hTop = cosA;
                hBottom = 0;
                wLeft = 0;
                wRight = sinB;
            }
            else if (cosA < 0 && cosB < 0) {
                hTop = 0;
                hBottom = -cosB;
                wLeft = 0;
                wRight = sinA;
            }
            else if (cosA >= 0 && cosB < 0) {
                hTop = cosA;
                hBottom = -cosB;
                wLeft = 0;
                wRight = sinA;
            }
            else if (cosA < 0 && cosB >= 0) {
                hTop = 1;
                hBottom = 1;
                wLeft = 1;
                wRight = Math.max(sinA, sinB);
            }
        }
        else if (sinA >= 0 && sinB < 0) {
            if (cosA >= 0 && cosB >= 0) {
                hTop = Math.max(cosA, cosB);
                hBottom = 1;
                wLeft = 1;
                wRight = 1;
            }
            else if (cosA < 0 && cosB < 0) {
                hTop = 0;
                hBottom = 1;
                wLeft = -sinB;
                wRight = sinA;
            }
            else if (cosA >= 0 && cosB < 0) {
                hTop = cosA;
                hBottom = 1;
                wLeft = -sinB;
                wRight = 1;
            }
            else if (cosA < 0 && cosB >= 0) {
                hTop = cosB;
                hBottom = 1;
                wLeft = 1;
                wRight = sinA;
            }
        }
        else if (sinA < 0 && sinB >= 0) {
            if (cosA >= 0 && cosB >= 0) {
                hTop = 1;
                hBottom = 0;
                wLeft = -sinA;
                wRight = sinB;
            }
            else if (cosA < 0 && cosB < 0) {
                hTop = 1;
                hBottom = Math.max(-cosA, -cosB);
                wLeft = 1;
                wRight = 1;
            }
            else if (cosA >= 0 && cosB < 0) {
                hTop = 1;
                hBottom = -cosB;
                wLeft = -sinA;
                wRight = 1;
            }
            else if (cosA < 0 && cosB >= 0) {
                hTop = 1;
                hBottom = -cosA;
                wLeft = 1;
                wRight = sinB;
            }
        }
        else if (sinA < 0 && sinB < 0) {
            if (cosA >= 0 && cosB >= 0) {
                hTop = cosB;
                hBottom = 0;
                wLeft = -sinA;
                wRight = 0;
            }
            else if (cosA < 0 && cosB < 0) {
                hTop = 0;
                hBottom = -cosA;
                wLeft = -sinB;
                wRight = 0;
            }
            else if (cosA >= 0 && cosB < 0) {
                hTop = 1;
                hBottom = 1;
                wLeft = Math.max(cosA, -cosB);
                wRight = 1;
            }
            else if (cosA < 0 && cosB >= 0) {
                hTop = cosB;
                hBottom = -cosA;
                wLeft = 1;
                wRight = 0;
            }
        }
        return {
            x: wLeft + wRight == 0 ? 0 : (wLeft / (wLeft + wRight)) * this.width(),
            y: hTop + hBottom == 0 ? 0 : (hTop / (hTop + hBottom)) * this.height(),
        };
    };
    Pie.prototype._getDataToDraw = function () {
        var dataToDraw = _super.prototype._getDataToDraw.call(this);
        if (this.datasets().length === 0) {
            return dataToDraw;
        }
        var sectorValueAccessor = plot_1.Plot._scaledAccessor(this.sectorValue());
        var ds = this.datasets()[0];
        var data = dataToDraw.get(ds);
        var filteredData = data.filter(function (d, i) { return Pie._isValidData(sectorValueAccessor(d, i, ds)); });
        dataToDraw.set(ds, filteredData);
        return dataToDraw;
    };
    Pie._isValidData = function (value) {
        return Utils.Math.isValidNumber(value) && value >= 0;
    };
    Pie.prototype._pixelPoint = function (datum, index, dataset) {
        var scaledValueAccessor = plot_1.Plot._scaledAccessor(this.sectorValue());
        if (!Pie._isValidData(scaledValueAccessor(datum, index, dataset))) {
            return { x: NaN, y: NaN };
        }
        var innerRadius = plot_1.Plot._scaledAccessor(this.innerRadius())(datum, index, dataset);
        var outerRadius = plot_1.Plot._scaledAccessor(this.outerRadius())(datum, index, dataset);
        var avgRadius = (innerRadius + outerRadius) / 2;
        var pie = d3.pie()
            .sort(null)
            .value(function (d, i) {
            var value = scaledValueAccessor(d, i, dataset);
            return Pie._isValidData(value) ? value : 0;
        }).startAngle(this._startAngle).endAngle(this._endAngle)(dataset.data());
        var startAngle = pie[index].startAngle;
        var endAngle = pie[index].endAngle;
        var avgAngle = (startAngle + endAngle) / 2;
        return { x: avgRadius * Math.sin(avgAngle), y: -avgRadius * Math.cos(avgAngle) };
    };
    Pie.prototype._additionalPaint = function (time) {
        var _this = this;
        this._renderArea.select(".label-area").remove();
        if (this._labelsEnabled) {
            Utils.Window.setTimeout(function () { return _this._drawLabels(); }, time);
        }
        var drawSteps = this._generateStrokeDrawSteps();
        var dataToDraw = this._getDataToDraw();
        this.datasets().forEach(function (dataset) {
            var appliedDrawSteps = plot_1.Plot.applyDrawSteps(drawSteps, dataset);
            _this._strokeDrawers.get(dataset).draw(dataToDraw.get(dataset), appliedDrawSteps);
        });
    };
    Pie.prototype._generateStrokeDrawSteps = function () {
        var attrToProjector = this._getAttrToProjector();
        return [{ attrToProjector: attrToProjector, animator: new Animators.Null() }];
    };
    Pie.prototype._sliceIndexForPoint = function (p) {
        var pointRadius = Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
        var pointAngle = Math.acos(-p.y / pointRadius);
        if (p.x < 0) {
            pointAngle = Math.PI * 2 - pointAngle;
        }
        var index;
        for (var i = 0; i < this._startAngles.length; i++) {
            if (this._startAngles[i] < pointAngle && this._endAngles[i] > pointAngle) {
                index = i;
                break;
            }
        }
        if (index !== undefined) {
            var dataset = this.datasets()[0];
            var datum = dataset.data()[index];
            var innerRadius = this.innerRadius().accessor(datum, index, dataset);
            var outerRadius = this.outerRadius().accessor(datum, index, dataset);
            if (pointRadius > innerRadius && pointRadius < outerRadius) {
                return index;
            }
        }
        return null;
    };
    Pie.prototype._drawLabels = function () {
        var _this = this;
        var attrToProjector = this._getAttrToProjector();
        var labelArea = this._renderArea.append("g").classed("label-area", true);
        var context = new Typesettable.SvgContext(labelArea.node());
        var measurer = new Typesettable.CacheMeasurer(context);
        var writer = new Typesettable.Writer(measurer, context);
        var dataset = this.datasets()[0];
        var data = this._getDataToDraw().get(dataset);
        var dataLen = data.length;
        var _loop_1 = function (datumIndex) {
            var datum = data[datumIndex];
            var value = this_1.sectorValue().accessor(datum, datumIndex, dataset);
            if (!Utils.Math.isValidNumber(value)) {
                return "continue";
            }
            value = this_1._labelFormatter(value, datum, datumIndex, dataset);
            var measurement = measurer.measure(value);
            var theta = (this_1._endAngles[datumIndex] + this_1._startAngles[datumIndex]) / 2;
            var outerRadius = this_1.outerRadius().accessor(datum, datumIndex, dataset);
            if (this_1.outerRadius().scale) {
                outerRadius = this_1.outerRadius().scale.scale(outerRadius);
            }
            var innerRadius = this_1.innerRadius().accessor(datum, datumIndex, dataset);
            if (this_1.innerRadius().scale) {
                innerRadius = this_1.innerRadius().scale.scale(innerRadius);
            }
            var labelRadius = (outerRadius + innerRadius) / 2;
            var x = Math.sin(theta) * labelRadius - measurement.width / 2;
            var y = -Math.cos(theta) * labelRadius - measurement.height / 2;
            var corners = [
                { x: x, y: y },
                { x: x, y: y + measurement.height },
                { x: x + measurement.width, y: y },
                { x: x + measurement.width, y: y + measurement.height },
            ];
            var showLabel = corners.every(function (corner) {
                return Math.abs(corner.x) <= _this.width() / 2 && Math.abs(corner.y) <= _this.height() / 2;
            });
            if (showLabel) {
                var sliceIndices = corners.map(function (corner) { return _this._sliceIndexForPoint(corner); });
                showLabel = sliceIndices.every(function (index) { return index === datumIndex; });
            }
            var color = attrToProjector["fill"](datum, datumIndex, dataset);
            var dark = Utils.Color.contrast("white", color) * 1.6 < Utils.Color.contrast("black", color);
            var g = labelArea.append("g").attr("transform", "translate(" + x + "," + y + ")");
            var className = dark ? "dark-label" : "light-label";
            g.classed(className, true);
            g.style("visibility", showLabel ? "inherit" : "hidden");
            writer.write(value, measurement.width, measurement.height, {
                xAlign: "center",
                yAlign: "center",
            }, g.node());
        };
        var this_1 = this;
        for (var datumIndex = 0; datumIndex < dataLen; datumIndex++) {
            _loop_1(datumIndex);
        }
    };
    Pie._INNER_RADIUS_KEY = "inner-radius";
    Pie._OUTER_RADIUS_KEY = "outer-radius";
    Pie._SECTOR_VALUE_KEY = "sector-value";
    return Pie;
}(plot_1.Plot));
exports.Pie = Pie;

},{"../animators":525,"../core/formatters":551,"../drawers/arcDrawer":562,"../drawers/arcOutlineDrawer":563,"../drawers/drawer":568,"../scales":607,"../utils":624,"../utils/windowUtils":634,"./plot":597,"d3":414,"tslib":635,"typesettable":640}],597:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plot = exports.Renderer = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Animators = require("../animators");
var Utils = require("../utils");
var Plots = require("./commons");
var memoize_1 = require("../memoize");
var component_1 = require("../components/component");
var canvasDrawer_1 = require("../drawers/canvasDrawer");
var drawer_1 = require("../drawers/drawer");
var svgDrawer_1 = require("../drawers/svgDrawer");
var coerceD3_1 = require("../utils/coerceD3");
var makeEnum_1 = require("../utils/makeEnum");
var deferredRenderer_1 = require("./deferredRenderer");
exports.Renderer = (0, makeEnum_1.makeEnum)(["svg", "canvas"]);
var Plot = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Plot, _super);
    /**
     * A Plot draws some visualization of the inputted Datasets.
     *
     * @constructor
     */
    function Plot() {
        var _this = _super.call(this) || this;
        /**
         * Whether the backing datasets have changed since this plot's last render.
         */
        _this._dataChanged = false;
        /**
         * Mapping from attribute names to the extents ([min, max]) values that that attribute takes on.
         */
        _this._attrExtents = {};
        _this._animate = false;
        /**
         * The Animators for this plot. Each plot exposes a set of "animator key" strings that
         * define how different parts of that particular Plot animates. For instance, Rectangle
         * Plots have a "rectangles" animator key which controls how the <rect>s are animated.
         * @see animator()
         *
         * There are two common animators that most Plots respect: "main" and "reset". In general,
         * Plots draw in two steps: first they "reset" their visual elements (e.g. scatter plots set
         * all the dots to size 0), and then they do the "main" animation into the correct visualization
         * (e.g. scatter plot dots grow to their specified size).
         */
        _this._animators = {};
        /**
         * Mapping from property names to the extents ([min, max]) values that that
         * property takes on.
         */
        _this._propertyExtents = {};
        _this._resetEntityStore = function () {
            _this._cachedEntityStore = undefined;
        };
        _this._overflowHidden = true;
        _this.addClass("plot");
        _this._datasetToDrawer = new Utils.Map();
        _this._attrBindings = d3.map();
        _this._includedValuesProvider = function (scale, ignoreAnchorState) {
            return _this._includedValuesForScale(scale, ignoreAnchorState);
        };
        _this._renderCallback = function () { return _this.render(); };
        _this._onDatasetUpdateCallback = function () { return _this._onDatasetUpdate(); };
        _this._propertyBindings = d3.map();
        var mainAnimator = new Animators.Easing().maxTotalDuration(Plot._ANIMATION_MAX_DURATION);
        _this.animator(Plots.Animator.MAIN, mainAnimator);
        _this.animator(Plots.Animator.RESET, new Animators.Null());
        _this._deferredResetEntityStore = Utils.Window.debounce(deferredRenderer_1.DeferredRenderer.DEFERRED_RENDERING_DELAY, _this._resetEntityStore);
        return _this;
    }
    Plot.getTotalDrawTime = function (data, drawSteps) {
        return drawSteps.reduce(function (time, drawStep) { return time + drawStep.animator.totalTime(data.length); }, 0);
    };
    Plot.applyDrawSteps = function (drawSteps, dataset) {
        var appliedDrawSteps = drawSteps.map(function (drawStep) {
            var attrToProjector = drawStep.attrToProjector;
            var attrToAppliedProjector = {};
            Object.keys(attrToProjector).forEach(function (attr) {
                attrToAppliedProjector[attr] =
                    function (datum, index) { return attrToProjector[attr](datum, index, dataset); };
            });
            return {
                attrToAppliedProjector: attrToAppliedProjector,
                animator: drawStep.animator,
            };
        });
        return appliedDrawSteps;
    };
    Plot.prototype.anchor = function (selection) {
        selection = (0, coerceD3_1.coerceExternalD3)(selection);
        _super.prototype.anchor.call(this, selection);
        this._dataChanged = true;
        this._resetEntityStore();
        this._updateExtents();
        return this;
    };
    Plot.prototype._setup = function () {
        var _this = this;
        if (this._isSetup) {
            return;
        }
        _super.prototype._setup.call(this);
        if (this._canvas != null) {
            this._appendCanvasNode();
        }
        this._renderArea = this.content().append("g").classed("render-area", true);
        this.datasets().forEach(function (dataset) { return _this._createNodesForDataset(dataset); });
    };
    Plot.prototype._appendCanvasNode = function () {
        var canvasContainer = this.element().select(".plot-canvas-container");
        if (canvasContainer.empty()) {
            canvasContainer = this.element().append("div").classed("plot-canvas-container", true);
            canvasContainer.node().appendChild(this._canvas.node());
        }
    };
    Plot.prototype.setBounds = function (width, height, originX, originY) {
        _super.prototype.setBounds.call(this, width, height, originX, originY);
        this._updateExtents();
        if (this._canvas != null) {
            if (this._bufferCanvas && !this._bufferCanvasValid) {
                // copy current canvas to buffer 1:1
                //
                // Why use a buffer canvas?
                // As soon as we change the size of a canvas with css or attributes, it
                // clears the contents. Without a buffer canvas, this requires
                // drag-resizable charts to immediately do a full redraw while you
                // drag-resize, which can cause jank. To avoid that, this buffer canvas
                // stores the current canvas contents when the resize starts and redraws
                // it into the resized canvas. Eventually, the deferred rendering
                // callback will trigger and do a full-rez redraw. If deferred rendering
                // is disabled, the buffer copy will be overwritten immediately by a
                // full redraw.
                this._bufferCanvas.attr("width", this._canvas.attr("width"));
                this._bufferCanvas.attr("height", this._canvas.attr("height"));
                var btx = this._bufferCanvas.node().getContext("2d");
                // for headless test compat (jest)
                if (btx) {
                    var originalCanvas = this._canvas.node();
                    if (originalCanvas.width > 0 && originalCanvas.height > 0) {
                        if (btx.canvas.width > 0 && btx.canvas.height > 0) {
                            btx.drawImage(originalCanvas, 0, 0);
                        }
                    }
                    else {
                        console.warn("Failed to fill buffer canvas with with 0x0 canvas");
                    }
                }
                this._bufferCanvasValid = true;
            }
            // update canvas size
            var ratio = (window.devicePixelRatio != null) ? window.devicePixelRatio : 1;
            // update canvas width/height taking into account retina displays.
            // This will also clear the canvas of any drawn elements so we should
            // be sure not to computeLayout() without a render() in the future.
            this._canvas.attr("width", width * ratio);
            this._canvas.attr("height", height * ratio);
            // reset the transform then set the scale factor
            var ctx = this._canvas.node().getContext("2d");
            // null check for headless test compat (jest)
            if (ctx) {
                ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
                if (this._bufferCanvas) {
                    var bufferCanvas = this._bufferCanvas.node();
                    if (bufferCanvas.width > 0 && bufferCanvas.height > 0) {
                        if (ctx.canvas.width > 0 && ctx.canvas.height > 0) {
                            // draw buffer to current canvas at new size
                            ctx.drawImage(bufferCanvas, 0, 0, width, height);
                        }
                    }
                    else {
                        console.warn("Failed to fill canvas with 0x0 buffer canvas");
                    }
                }
            }
        }
        return this;
    };
    Plot.prototype.destroy = function () {
        var _this = this;
        _super.prototype.destroy.call(this);
        this._scales().forEach(function (scale) { return scale.offUpdate(_this._renderCallback); });
        this.datasets([]);
    };
    /**
     * Setup the DOM nodes for the given dataset. This is a separate
     * step from "creating the Drawer" since the element may not be setup yet
     * (in which case the _renderArea is null because the .element() and .content()
     * are null). Also because subclasses may do more than just configure one
     * single drawer (e.g. adding text drawing capabilities).
     */
    Plot.prototype._createNodesForDataset = function (dataset) {
        var drawer = this._datasetToDrawer.get(dataset);
        if (this.renderer() === "svg") {
            drawer.useSVG(this._renderArea);
        }
        else {
            drawer.useCanvas(this._canvas);
        }
        return drawer;
    };
    /**
     * Create a new Drawer. Subclasses should override this to return
     * a Drawer that draws the correct shapes for this plot.
     */
    Plot.prototype._createDrawer = function (dataset) {
        return new drawer_1.ProxyDrawer(function () { return new svgDrawer_1.SVGDrawer("path", ""); }, function (ctx) { return new canvasDrawer_1.CanvasDrawer(ctx, function () { }); });
    };
    Plot.prototype._getAnimator = function (key) {
        if (this._animateOnNextRender()) {
            return this._animators[key] || new Animators.Null();
        }
        else {
            return new Animators.Null();
        }
    };
    Plot.prototype._onDatasetUpdate = function () {
        this._updateExtents();
        this._dataChanged = true;
        this._resetEntityStore();
        this.renderLowPriority();
    };
    Plot.prototype.attr = function (attr, attrValue, scale) {
        if (attrValue == null) {
            return this._attrBindings.get(attr);
        }
        this._bindAttr(attr, attrValue, scale);
        this.render(); // queue a re-render upon changing projector
        return this;
    };
    Plot.prototype._bindProperty = function (property, valueOrFn, scale, postScale) {
        var binding = this._propertyBindings.get(property);
        var oldScale = binding != null ? binding.scale : null;
        var accessor = typeof valueOrFn === "function" ? valueOrFn : function () { return valueOrFn; };
        this._propertyBindings.set(property, { accessor: accessor, scale: scale, postScale: postScale });
        if (oldScale != null) {
            this._uninstallScaleForKey(oldScale, property);
        }
        if (scale != null) {
            this._installScaleForKey(scale, property);
        }
        this._clearAttrToProjectorCache();
    };
    Plot.prototype._bindAttr = function (attr, valueOrFn, scale) {
        var binding = this._attrBindings.get(attr);
        var oldScale = binding != null ? binding.scale : null;
        var accessor = typeof valueOrFn === "function" ? valueOrFn : function () { return valueOrFn; };
        this._attrBindings.set(attr, { accessor: accessor, scale: scale });
        if (oldScale != null) {
            this._uninstallScaleForKey(oldScale, attr);
        }
        if (scale != null) {
            this._installScaleForKey(scale, attr);
        }
        this._clearAttrToProjectorCache();
    };
    Plot.prototype._clearAttrToProjectorCache = function () {
        delete this._cachedAttrToProjector;
    };
    Plot.prototype._getAttrToProjector = function () {
        if (this._cachedAttrToProjector == null) {
            var projectors = this._generateAttrToProjector();
            if (Plot.OPTIMIZE_MEMOIZE_PROJECTORS) {
                projectors = (0, memoize_1.memoizeProjectors)(projectors);
            }
            this._cachedAttrToProjector = projectors;
        }
        // return shallow clone of cached projector
        return Utils.assign({}, this._cachedAttrToProjector);
    };
    Plot.prototype._generateAttrToProjector = function () {
        var h = {};
        this._attrBindings.each(function (binding, attr) {
            h[attr] = Plot._scaledAccessor(binding);
        });
        var propertyProjectors = this._propertyProjectors();
        Object.keys(propertyProjectors).forEach(function (key) {
            if (h[key] == null) {
                h[key] = propertyProjectors[key];
            }
        });
        return h;
    };
    Plot.prototype.renderImmediately = function () {
        _super.prototype.renderImmediately.call(this);
        if (this._isAnchored) {
            this._paint();
            this._dataChanged = false;
        }
        return this;
    };
    Plot.prototype.renderLowPriority = function () {
        this._renderCallback();
        return this;
    };
    Plot.prototype.animated = function (willAnimate) {
        if (willAnimate == null) {
            return this._animate;
        }
        this._animate = willAnimate;
        return this;
    };
    Plot.prototype.detach = function () {
        _super.prototype.detach.call(this);
        // make the domain resize
        this._updateExtents();
        return this;
    };
    /**
     * @returns {Scale[]} A unique array of all scales currently used by the Plot.
     */
    Plot.prototype._scales = function () {
        var scales = [];
        this._attrBindings.each(function (binding, attr) {
            var scale = binding.scale;
            if (scale != null && scales.indexOf(scale) === -1) {
                scales.push(scale);
            }
        });
        this._propertyBindings.each(function (binding, property) {
            var scale = binding.scale;
            if (scale != null && scales.indexOf(scale) === -1) {
                scales.push(scale);
            }
        });
        return scales;
    };
    /**
     * Updates the extents associated with each attribute, then autodomains all scales the Plot uses.
     */
    Plot.prototype._updateExtents = function () {
        var _this = this;
        this._resetEntityStore();
        this._scales().forEach(function (scale) { return scale.addIncludedValuesProvider(_this._includedValuesProvider); });
    };
    Plot.prototype._filterForProperty = function (property) {
        return null;
    };
    Plot.prototype.getExtentsForAttr = function (attr) {
        var _this = this;
        if (this._attrExtents[attr] == null) {
            var thunk = (0, memoize_1.memThunk)(function () { return _this.datasets(); }, function () { return _this._attrBindings.get(attr); }, function (datasets, accScaleBinding) {
                if (accScaleBinding == null || accScaleBinding.accessor == null) {
                    return null;
                }
                return datasets.map(function (dataset) { return computeExtent(dataset, accScaleBinding, null); });
            });
            this._attrExtents[attr] = thunk;
        }
        return this._attrExtents[attr]();
    };
    /**
     * Override in subclass to add special extents, such as included values
     */
    Plot.prototype.getExtentsForProperty = function (property) {
        var _this = this;
        if (this._propertyExtents[property] == null) {
            var thunk = (0, memoize_1.memThunk)(function () { return _this.datasets(); }, function () { return _this._propertyBindings.get(property); }, function () { return _this._filterForProperty(property); }, function (datasets, accScaleBinding, filter) {
                if (accScaleBinding == null || accScaleBinding.accessor == null) {
                    return null;
                }
                return datasets.map(function (dataset) { return computeExtent(dataset, accScaleBinding, filter); });
            });
            this._propertyExtents[property] = thunk;
        }
        return this._propertyExtents[property]();
    };
    Plot.prototype._includedValuesForScale = function (scale, ignoreAttachState) {
        var _this = this;
        if (!this._isAnchored && !ignoreAttachState) {
            return [];
        }
        var includedValues = [];
        this._attrBindings.each(function (binding, attr) {
            if (binding.scale === scale) {
                var extents = _this.getExtentsForAttr(attr);
                if (extents != null) {
                    includedValues = includedValues.concat(d3.merge(extents));
                }
            }
        });
        this._propertyBindings.each(function (binding, property) {
            if (binding.scale === scale) {
                var extents = _this.getExtentsForProperty(property);
                if (extents != null) {
                    includedValues = includedValues.concat(d3.merge(extents));
                }
            }
        });
        return includedValues;
    };
    Plot.prototype.animator = function (animatorKey, animator) {
        if (animator === undefined) {
            return this._animators[animatorKey];
        }
        else {
            this._animators[animatorKey] = animator;
            return this;
        }
    };
    Plot.prototype.renderer = function (renderer) {
        var _this = this;
        if (renderer === undefined) {
            return this._canvas == null ? "svg" : "canvas";
        }
        else {
            if (this._canvas == null && renderer === "canvas") {
                // construct the canvas, remove drawer's renderAreas, set drawer's canvas
                this._canvas = d3.select(document.createElement("canvas")).classed("plot-canvas", true);
                this._bufferCanvas = d3.select(document.createElement("canvas"));
                if (this.element() != null) {
                    this._appendCanvasNode();
                }
                this._datasetToDrawer.forEach(function (drawer) {
                    drawer.useCanvas(_this._canvas);
                });
                this.render();
            }
            else if (this._canvas != null && renderer == "svg") {
                this._canvas.remove();
                this._canvas = null;
                this._bufferCanvas = null;
                this._datasetToDrawer.forEach(function (drawer) {
                    drawer.useSVG(_this._renderArea);
                });
                this.render();
            }
            return this;
        }
    };
    /**
     * Adds a Dataset to the Plot.
     *
     * @param {Dataset} dataset
     * @returns {Plot} The calling Plot.
     */
    Plot.prototype.addDataset = function (dataset) {
        this._addDataset(dataset);
        this._onDatasetUpdate();
        return this;
    };
    Plot.prototype._addDataset = function (dataset) {
        this._removeDataset(dataset);
        var drawer = this._createDrawer(dataset);
        this._datasetToDrawer.set(dataset, drawer);
        if (this._isSetup) {
            this._createNodesForDataset(dataset);
        }
        dataset.onUpdate(this._onDatasetUpdateCallback);
        return this;
    };
    /**
     * Removes a Dataset from the Plot.
     *
     * @param {Dataset} dataset
     * @returns {Plot} The calling Plot.
     */
    Plot.prototype.removeDataset = function (dataset) {
        this._removeDataset(dataset);
        this._onDatasetUpdate();
        return this;
    };
    Plot.prototype._removeDataset = function (dataset) {
        if (this.datasets().indexOf(dataset) === -1) {
            return this;
        }
        this._removeDatasetNodes(dataset);
        dataset.offUpdate(this._onDatasetUpdateCallback);
        this._datasetToDrawer.delete(dataset);
        return this;
    };
    Plot.prototype._removeDatasetNodes = function (dataset) {
        var drawer = this._datasetToDrawer.get(dataset);
        drawer.remove();
    };
    Plot.prototype.datasets = function (datasets) {
        var _this = this;
        var currentDatasets = [];
        this._datasetToDrawer.forEach(function (drawer, dataset) { return currentDatasets.push(dataset); });
        if (datasets == null) {
            return currentDatasets;
        }
        currentDatasets.forEach(function (dataset) { return _this._removeDataset(dataset); });
        datasets.forEach(function (dataset) { return _this._addDataset(dataset); });
        this._onDatasetUpdate();
        return this;
    };
    Plot.prototype._generateDrawSteps = function () {
        return [{ attrToProjector: this._getAttrToProjector(), animator: new Animators.Null() }];
    };
    Plot.prototype._additionalPaint = function (time) {
        // no-op
    };
    /**
     * _buildLightweightPlotEntities constucts {LightweightPlotEntity[]} from
     * all the entities in the plot
     * @param {Dataset[]} [datasets] - datasets comprising this plot
     */
    Plot.prototype._buildLightweightPlotEntities = function (datasets) {
        var _this = this;
        var lightweightPlotEntities = [];
        datasets.forEach(function (dataset, datasetIndex) {
            var drawer = _this._datasetToDrawer.get(dataset);
            var validDatumIndex = 0;
            var data = dataset.data();
            var dataLen = data.length;
            var _loop_1 = function (datumIndex) {
                var datum = data[datumIndex];
                var position = _this._pixelPoint(datum, datumIndex, dataset);
                if (Utils.Math.isNaN(position.x) || Utils.Math.isNaN(position.y)) {
                    return "continue";
                }
                var plot = _this;
                lightweightPlotEntities.push({
                    datum: datum,
                    get position() {
                        // only calculate position when needing to improve pan zoom performance #3159
                        return plot._pixelPoint.call(plot, datum, datumIndex, dataset);
                    },
                    index: datumIndex,
                    dataset: dataset,
                    datasetIndex: datasetIndex,
                    component: _this,
                    drawer: drawer,
                    validDatumIndex: validDatumIndex,
                });
                validDatumIndex++;
            };
            for (var datumIndex = 0; datumIndex < dataLen; datumIndex++) {
                _loop_1(datumIndex);
            }
        });
        return lightweightPlotEntities;
    };
    Plot.prototype._getDataToDraw = function () {
        var dataToDraw = new Utils.Map();
        this.datasets().forEach(function (dataset) { return dataToDraw.set(dataset, dataset.data()); });
        return dataToDraw;
    };
    Plot.prototype._paint = function () {
        var _this = this;
        delete this._cachedAttrToProjector;
        var drawSteps = this._generateDrawSteps();
        var dataToDraw = this._getDataToDraw();
        var drawers = this.datasets().map(function (dataset) { return _this._datasetToDrawer.get(dataset); });
        if (this.renderer() === "canvas") {
            var canvas = this._canvas.node();
            var context_1 = canvas.getContext("2d");
            context_1.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
            this._bufferCanvasValid = false;
        }
        this.datasets().forEach(function (ds, i) {
            var appliedDrawSteps = Plot.applyDrawSteps(drawSteps, ds);
            drawers[i].draw(dataToDraw.get(ds), appliedDrawSteps);
        });
        var times = this.datasets().map(function (ds, i) { return Plot.getTotalDrawTime(dataToDraw.get(ds), drawSteps); });
        var maxTime = Utils.Math.max(times, 0);
        this._additionalPaint(maxTime);
    };
    /**
     * Retrieves the drawn visual elements for the specified Datasets as a d3 Selection.
     * Not supported on canvas renderer.
     *
     * @param {Dataset[]} [datasets] The Datasets to retrieve the Selections for.
     *   If not provided, Selections will be retrieved for all Datasets on the Plot.
     * @returns {d3.Selection}
     */
    Plot.prototype.selections = function (datasets) {
        var _this = this;
        if (datasets === void 0) { datasets = this.datasets(); }
        if (this.renderer() === "canvas") {
            // return empty selection
            return d3.selectAll();
        }
        else {
            var selections_1 = [];
            datasets.forEach(function (dataset) {
                var drawer = _this._datasetToDrawer.get(dataset);
                if (drawer == null) {
                    return;
                }
                var visualPrimitives = drawer.getVisualPrimitives();
                selections_1.push.apply(selections_1, visualPrimitives);
            });
            return d3.selectAll(selections_1);
        }
    };
    /**
     * Gets the Entities associated with the specified Datasets.
     *
     * @param {Dataset[]} datasets The Datasets to retrieve the Entities for.
     *   If not provided, returns defaults to all Datasets on the Plot.
     * @return {Plots.PlotEntity[]}
     */
    Plot.prototype.entities = function (datasets) {
        var _this = this;
        return this._getEntityStore(datasets).entities().map(function (entity) { return _this._lightweightPlotEntityToPlotEntity(entity); });
    };
    /**
     * Gets the `Plots.PlotEntity`s in the plot, whereby the
     * `Plots.ILightweightPlotEntity`s are filtered by the provided predicate.
     * Since `_lightweightPlotEntityToPlotEntity` can be expensive, this method
     * can be useful for performance optimization.
     *
     * @param where A filter predicate that is applied to lightweight entities
     * before upconverting them to full plot entities
     * @return {Plots.PlotEntity[]}
     */
    Plot.prototype.filterEntities = function (where) {
        var _this = this;
        return this._getEntityStore()
            .entities()
            .filter(where)
            .map(function (entity) { return _this._lightweightPlotEntityToPlotEntity(entity); });
    };
    /**
     * _getEntityStore returns the store of all Entities associated with the specified dataset
     *
     * @param {Dataset[]} [datasets] - The datasets with which to construct the store. If no datasets
     * are specified all datasets will be used.
     */
    Plot.prototype._getEntityStore = function (datasets) {
        var _this = this;
        var entityBoundsFactory = function (entity) { return _this._entityBounds(entity); };
        if (datasets !== undefined) {
            var entityStore = new Utils.EntityStore();
            entityStore.addAll(this._buildLightweightPlotEntities(datasets), entityBoundsFactory, this._localOriginBounds());
            return entityStore;
        }
        else if (this._cachedEntityStore === undefined) {
            var entityStore = new Utils.EntityStore();
            entityStore.addAll(this._buildLightweightPlotEntities(this.datasets()), entityBoundsFactory, this._localOriginBounds());
            this._cachedEntityStore = entityStore;
        }
        return this._cachedEntityStore;
    };
    /**
     * _localOriginBounds returns bounds of the plot from its own origin, rather than from parent origin (as provided by `this.bounds()`)
     *
     * @return {Bounds}
     */
    Plot.prototype._localOriginBounds = function () {
        return {
            topLeft: { x: 0, y: 0 },
            bottomRight: { x: this.width(), y: this.height() },
        };
    };
    Plot.prototype._entityBounds = function (entity) {
        var datum = entity.datum, index = entity.index, dataset = entity.dataset;
        var _a = this._pixelPoint(datum, index, dataset), x = _a.x, y = _a.y;
        return { x: x, y: y, width: 0, height: 0 };
    };
    Plot.prototype._lightweightPlotEntityToPlotEntity = function (entity) {
        var plotEntity = {
            bounds: this._entityBounds(entity),
            component: entity.component,
            dataset: entity.dataset,
            datasetIndex: entity.datasetIndex,
            datum: entity.datum,
            index: entity.index,
            position: entity.position,
            selection: d3.select(entity.drawer.getVisualPrimitiveAtIndex(entity.validDatumIndex)),
        };
        return plotEntity;
    };
    /**
     * Gets the PlotEntities at a particular Point.
     *
     * Each plot type determines how to locate entities at or near the query
     * point. For example, line and area charts will return the nearest entity,
     * but bar charts will only return the entities that fully contain the query
     * point.
     *
     * @param {Point} point The point to query.
     * @returns {PlotEntity[]} The PlotEntities at the particular point
     */
    Plot.prototype.entitiesAt = function (point) {
        throw new Error("plots must implement entitiesAt");
    };
    /**
     * Returns the {Plots.PlotEntity} nearest to the query point,
     * or undefined if no {Plots.PlotEntity} can be found.
     *
     * @param {Point} queryPoint
     * @returns {Plots.PlotEntity} The nearest PlotEntity, or undefined if no {Plots.PlotEntity} can be found.
     */
    Plot.prototype.entityNearest = function (queryPoint) {
        var nearest = this._getEntityStore().entityNearest(queryPoint);
        return nearest === undefined ? undefined : this._lightweightPlotEntityToPlotEntity(nearest);
    };
    Plot.prototype.entitiesIn = function (xRangeOrBounds, yRange) {
        var queryBounds;
        if (yRange == null) {
            var bounds = xRangeOrBounds;
            queryBounds = {
                x: bounds.topLeft.x,
                y: bounds.topLeft.y,
                width: bounds.bottomRight.x - bounds.topLeft.x,
                height: bounds.bottomRight.y - bounds.topLeft.y,
            };
        }
        else {
            var xRange = xRangeOrBounds;
            queryBounds = {
                x: xRange.min,
                y: yRange.min,
                width: xRange.max - xRange.min,
                height: yRange.max - yRange.min,
            };
        }
        return this.entitiesInBounds(queryBounds);
    };
    /**
     * Returns the entites whose bounding boxes overlap the parameter.
     *
     * `queryBounds` are in pixel space, measured from the origin of this plot.
     */
    Plot.prototype.entitiesInBounds = function (queryBounds) {
        var _this = this;
        var found = this._getEntityStore().entitiesInBounds(queryBounds);
        if (!found) {
            return undefined;
        }
        return found.map(function (entity) { return _this._lightweightPlotEntityToPlotEntity(entity); });
    };
    /**
     * Returns the entites whose bounding boxes overlap the `queryBounds`
     * parameter on the x-axis.
     *
     * `queryBounds` are in pixel space, measured from the origin of this plot.
     */
    Plot.prototype.entitiesInXBounds = function (queryBounds) {
        var _this = this;
        var found = this._getEntityStore().entitiesInXBounds(queryBounds);
        if (!found) {
            return undefined;
        }
        return found.map(function (entity) { return _this._lightweightPlotEntityToPlotEntity(entity); });
    };
    /**
     * Returns the entites whose bounding boxes overlap the `queryBounds`
     * parameter on the y-axis.
     *
     * `queryBounds` are in pixel space, measured from the origin of this plot.
     */
    Plot.prototype.entitiesInYBounds = function (queryBounds) {
        var _this = this;
        var found = this._getEntityStore().entitiesInYBounds(queryBounds);
        if (!found) {
            return undefined;
        }
        return found.map(function (entity) { return _this._lightweightPlotEntityToPlotEntity(entity); });
    };
    Plot.prototype._uninstallScaleForKey = function (scale, key) {
        scale.offUpdate(this._renderCallback);
        scale.offUpdate(this._deferredResetEntityStore);
        scale.removeIncludedValuesProvider(this._includedValuesProvider);
    };
    Plot.prototype._installScaleForKey = function (scale, key) {
        scale.onUpdate(this._renderCallback);
        scale.onUpdate(this._deferredResetEntityStore);
        scale.addIncludedValuesProvider(this._includedValuesProvider);
    };
    Plot.prototype._propertyProjectors = function () {
        return {};
    };
    Plot._scaledAccessor = function (binding) {
        var scale = binding.scale, accessor = binding.accessor, postScale = binding.postScale;
        // if provided, apply scale
        var scaledAccesor = scale == null ? accessor :
            function (d, i, ds) { return scale.scale(accessor(d, i, ds)); };
        // if provided, apply post scale
        var postScaledAccesor = postScale == null ? scaledAccesor :
            function (d, i, ds) { return postScale(scaledAccesor(d, i, ds), d, i, ds); };
        return postScaledAccesor;
    };
    Plot.prototype._pixelPoint = function (datum, index, dataset) {
        return { x: 0, y: 0 };
    };
    Plot.prototype._animateOnNextRender = function () {
        return this._animate && this._dataChanged;
    };
    Plot.OPTIMIZE_MEMOIZE_PROJECTORS = false;
    Plot._ANIMATION_MAX_DURATION = 600;
    return Plot;
}(component_1.Component));
exports.Plot = Plot;
function computeExtent(dataset, accScaleBinding, filter) {
    var accessor = accScaleBinding.accessor;
    var scale = accScaleBinding.scale;
    if (scale == null) {
        return [];
    }
    var data = dataset.data();
    if (filter != null) {
        data = data.filter(function (d, i) { return filter(d, i, dataset); });
    }
    var appliedAccessor = function (d, i) { return accessor(d, i, dataset); };
    var mappedData = data.map(appliedAccessor);
    return scale.extentOfValues(mappedData);
}

},{"../animators":525,"../components/component":532,"../drawers/canvasDrawer":566,"../drawers/drawer":568,"../drawers/svgDrawer":573,"../memoize":584,"../utils":624,"../utils/coerceD3":620,"../utils/makeEnum":625,"./commons":592,"./deferredRenderer":593,"d3":414,"tslib":635}],598:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rectangle = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Typesettable = require("typesettable");
var Animators = require("../animators");
var Drawers = require("../drawers");
var drawer_1 = require("../drawers/drawer");
var rectangleDrawer_1 = require("../drawers/rectangleDrawer");
var Scales = require("../scales");
var Utils = require("../utils");
var plot_1 = require("./plot");
var xyPlot_1 = require("./xyPlot");
var Rectangle = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Rectangle, _super);
    /**
     * A Rectangle Plot displays rectangles based on the data.
     * The left and right edges of each rectangle can be set with x() and x2().
     *   If only x() is set the Rectangle Plot will attempt to compute the correct left and right edge positions.
     * The top and bottom edges of each rectangle can be set with y() and y2().
     *   If only y() is set the Rectangle Plot will attempt to compute the correct top and bottom edge positions.
     *
     * @constructor
     * @param {Scale.Scale} xScale
     * @param {Scale.Scale} yScale
     */
    function Rectangle() {
        var _this = _super.call(this) || this;
        _this._labelsEnabled = false;
        _this._label = null;
        _this.animator("rectangles", new Animators.Null());
        _this.addClass("rectangle-plot");
        _this.attr("fill", new Scales.Color().range()[0]);
        return _this;
    }
    Rectangle.prototype._createDrawer = function () {
        return new drawer_1.ProxyDrawer(function () { return new rectangleDrawer_1.RectangleSVGDrawer(); }, function (ctx) { return new Drawers.RectangleCanvasDrawer(ctx); });
    };
    Rectangle.prototype._generateAttrToProjector = function () {
        var _this = this;
        var attrToProjector = _super.prototype._generateAttrToProjector.call(this);
        // Copy each of the different projectors.
        var xAttr = plot_1.Plot._scaledAccessor(this.x());
        var x2Attr = attrToProjector[Rectangle._X2_KEY];
        var yAttr = plot_1.Plot._scaledAccessor(this.y());
        var y2Attr = attrToProjector[Rectangle._Y2_KEY];
        var xScale = this.x().scale;
        var yScale = this.y().scale;
        if (x2Attr != null) {
            attrToProjector["width"] = function (d, i, dataset) { return Math.abs(x2Attr(d, i, dataset) - xAttr(d, i, dataset)); };
            attrToProjector["x"] = function (d, i, dataset) { return Math.min(x2Attr(d, i, dataset), xAttr(d, i, dataset)); };
        }
        else {
            attrToProjector["width"] = function (d, i, dataset) { return _this._rectangleWidth(xScale); };
            attrToProjector["x"] = function (d, i, dataset) { return xAttr(d, i, dataset) - 0.5 * attrToProjector["width"](d, i, dataset); };
        }
        if (y2Attr != null) {
            attrToProjector["height"] = function (d, i, dataset) { return Math.abs(y2Attr(d, i, dataset) - yAttr(d, i, dataset)); };
            attrToProjector["y"] = function (d, i, dataset) {
                return Math.max(y2Attr(d, i, dataset), yAttr(d, i, dataset)) - attrToProjector["height"](d, i, dataset);
            };
        }
        else {
            attrToProjector["height"] = function (d, i, dataset) { return _this._rectangleWidth(yScale); };
            attrToProjector["y"] = function (d, i, dataset) { return yAttr(d, i, dataset) - 0.5 * attrToProjector["height"](d, i, dataset); };
        }
        // Clean up the attributes projected onto the SVG elements
        delete attrToProjector[Rectangle._X2_KEY];
        delete attrToProjector[Rectangle._Y2_KEY];
        return attrToProjector;
    };
    Rectangle.prototype._generateDrawSteps = function () {
        return [{ attrToProjector: this._getAttrToProjector(), animator: this._getAnimator("rectangles") }];
    };
    Rectangle.prototype._filterForProperty = function (property) {
        if (property === "x2") {
            return _super.prototype._filterForProperty.call(this, "x");
        }
        else if (property === "y2") {
            return _super.prototype._filterForProperty.call(this, "y");
        }
        return _super.prototype._filterForProperty.call(this, property);
    };
    Rectangle.prototype.x = function (x, xScale, postScale) {
        if (x == null) {
            return _super.prototype.x.call(this);
        }
        if (xScale == null) {
            _super.prototype.x.call(this, x);
        }
        else {
            _super.prototype.x.call(this, x, xScale, postScale);
        }
        if (xScale != null) {
            var x2Binding = this.x2();
            var x2 = x2Binding && x2Binding.accessor;
            if (x2 != null) {
                this._bindProperty(Rectangle._X2_KEY, x2, xScale, x2Binding.postScale);
            }
        }
        // The x and y scales should render in bands with no padding for category scales
        if (xScale instanceof Scales.Category) {
            xScale.innerPadding(0).outerPadding(0);
        }
        return this;
    };
    Rectangle.prototype.x2 = function (x2, postScale) {
        if (x2 == null) {
            return this._propertyBindings.get(Rectangle._X2_KEY);
        }
        var xBinding = this.x();
        var xScale = xBinding && xBinding.scale;
        this._bindProperty(Rectangle._X2_KEY, x2, xScale, postScale);
        this.render();
        return this;
    };
    Rectangle.prototype.y = function (y, yScale, postScale) {
        if (y == null) {
            return _super.prototype.y.call(this);
        }
        if (yScale == null) {
            _super.prototype.y.call(this, y);
        }
        else {
            _super.prototype.y.call(this, y, yScale, postScale);
        }
        if (yScale != null) {
            var y2Binding = this.y2();
            var y2 = y2Binding && y2Binding.accessor;
            if (y2 != null) {
                this._bindProperty(Rectangle._Y2_KEY, y2, yScale, y2Binding.postScale);
            }
        }
        // The x and y scales should render in bands with no padding for category scales
        if (yScale instanceof Scales.Category) {
            yScale.innerPadding(0).outerPadding(0);
        }
        return this;
    };
    Rectangle.prototype.y2 = function (y2, postScale) {
        if (y2 == null) {
            return this._propertyBindings.get(Rectangle._Y2_KEY);
        }
        var yBinding = this.y();
        var yScale = yBinding && yBinding.scale;
        this._bindProperty(Rectangle._Y2_KEY, y2, yScale, postScale);
        this.render();
        return this;
    };
    /**
     * Gets the PlotEntities at a particular Point.
     *
     * @param {Point} point The point to query.
     * @returns {PlotEntity[]} The PlotEntities at the particular point
     */
    Rectangle.prototype.entitiesAt = function (point) {
        var attrToProjector = this._getAttrToProjector();
        return this.entities().filter(function (entity) {
            var datum = entity.datum;
            var index = entity.index;
            var dataset = entity.dataset;
            var x = attrToProjector["x"](datum, index, dataset);
            var y = attrToProjector["y"](datum, index, dataset);
            var width = attrToProjector["width"](datum, index, dataset);
            var height = attrToProjector["height"](datum, index, dataset);
            return x <= point.x && point.x <= x + width && y <= point.y && point.y <= y + height;
        });
    };
    Rectangle.prototype._entityBounds = function (entity) {
        var datum = entity.datum, index = entity.index, dataset = entity.dataset;
        return this._entityBBox(datum, index, dataset, this._getAttrToProjector());
    };
    Rectangle.prototype._entityBBox = function (datum, index, dataset, attrToProjector) {
        return {
            x: attrToProjector["x"](datum, index, dataset),
            y: attrToProjector["y"](datum, index, dataset),
            width: attrToProjector["width"](datum, index, dataset),
            height: attrToProjector["height"](datum, index, dataset),
        };
    };
    Rectangle.prototype.label = function (label) {
        if (label == null) {
            return this._label;
        }
        this._label = label;
        this.render();
        return this;
    };
    Rectangle.prototype.labelsEnabled = function (enabled) {
        if (enabled == null) {
            return this._labelsEnabled;
        }
        else {
            this._labelsEnabled = enabled;
            this.render();
            return this;
        }
    };
    Rectangle.prototype._propertyProjectors = function () {
        var attrToProjector = _super.prototype._propertyProjectors.call(this);
        if (this.x2() != null) {
            attrToProjector["x2"] = plot_1.Plot._scaledAccessor(this.x2());
        }
        if (this.y2() != null) {
            attrToProjector["y2"] = plot_1.Plot._scaledAccessor(this.y2());
        }
        return attrToProjector;
    };
    Rectangle.prototype._pixelPoint = function (datum, index, dataset) {
        var attrToProjector = this._getAttrToProjector();
        var rectX = attrToProjector["x"](datum, index, dataset);
        var rectY = attrToProjector["y"](datum, index, dataset);
        var rectWidth = attrToProjector["width"](datum, index, dataset);
        var rectHeight = attrToProjector["height"](datum, index, dataset);
        var x = rectX + rectWidth / 2;
        var y = rectY + rectHeight / 2;
        return { x: x, y: y };
    };
    Rectangle.prototype._rectangleWidth = function (scale) {
        if (scale instanceof Scales.Category) {
            return scale.rangeBand();
        }
        else {
            var accessor_1 = scale === this.x().scale ? this.x().accessor : this.y().accessor;
            var accessorData = d3.set(Utils.Array.flatten(this.datasets().map(function (dataset) {
                return dataset.data().map(function (d, i) { return accessor_1(d, i, dataset).valueOf(); });
            }))).values().map(function (value) { return +value; });
            // Get the absolute difference between min and max
            var min = Utils.Math.min(accessorData, 0);
            var max = Utils.Math.max(accessorData, 0);
            var scaledMin = scale.scale(min);
            var scaledMax = scale.scale(max);
            return (scaledMax - scaledMin) / Math.abs(max - min);
        }
    };
    Rectangle.prototype._getDataToDraw = function () {
        var dataToDraw = new Utils.Map();
        var attrToProjector = this._getAttrToProjector();
        this.datasets().forEach(function (dataset) {
            var data = dataset.data().map(function (d, i) {
                var isValid = (Utils.Math.isValidNumber(attrToProjector["x"](d, i, dataset)) &&
                    Utils.Math.isValidNumber(attrToProjector["y"](d, i, dataset)) &&
                    Utils.Math.isValidNumber(attrToProjector["width"](d, i, dataset)) &&
                    Utils.Math.isValidNumber(attrToProjector["height"](d, i, dataset)));
                return isValid ? d : null;
            });
            dataToDraw.set(dataset, data);
        });
        return dataToDraw;
    };
    Rectangle.prototype._additionalPaint = function (time) {
        var _this = this;
        this._renderArea.selectAll(".label-area").remove();
        if (this._labelsEnabled && this.label() != null) {
            Utils.Window.setTimeout(function () { return _this._drawLabels(); }, time);
        }
    };
    Rectangle.prototype._drawLabels = function () {
        var _this = this;
        var dataToDraw = this._getDataToDraw();
        this.datasets().forEach(function (dataset, i) { return _this._drawLabel(dataToDraw, dataset, i); });
    };
    Rectangle.prototype._drawLabel = function (dataToDraw, dataset, datasetIndex) {
        var attrToProjector = this._getAttrToProjector();
        var labelArea = this._renderArea.append("g").classed("label-area", true);
        var context = new Typesettable.SvgContext(labelArea.node());
        var measurer = new Typesettable.CacheMeasurer(context);
        var writer = new Typesettable.Writer(measurer, context);
        var xRange = this.x().scale.range();
        var yRange = this.y().scale.range();
        var xMin = Math.min.apply(null, xRange);
        var xMax = Math.max.apply(null, xRange);
        var yMin = Math.min.apply(null, yRange);
        var yMax = Math.max.apply(null, yRange);
        var data = dataToDraw.get(dataset);
        var dataLength = data.length;
        for (var datumIndex = 0; datumIndex < dataLength; datumIndex++) {
            var datum = data[datumIndex];
            if (datum == null) {
                continue;
            }
            var label = "" + this.label()(datum, datumIndex, dataset);
            var measurement = measurer.measure(label);
            var x = attrToProjector["x"](datum, datumIndex, dataset);
            var y = attrToProjector["y"](datum, datumIndex, dataset);
            var width = attrToProjector["width"](datum, datumIndex, dataset);
            var height = attrToProjector["height"](datum, datumIndex, dataset);
            if (measurement.height <= height && measurement.width <= width) {
                var horizontalOffset = (width - measurement.width) / 2;
                var verticalOffset = (height - measurement.height) / 2;
                x += horizontalOffset;
                y += verticalOffset;
                var xLabelRange = { min: x, max: x + measurement.width };
                var yLabelRange = { min: y, max: y + measurement.height };
                if (xLabelRange.min < xMin || xLabelRange.max > xMax || yLabelRange.min < yMin || yLabelRange.max > yMax) {
                    continue;
                }
                if (this._overlayLabel(xLabelRange, yLabelRange, datumIndex, datasetIndex, dataToDraw)) {
                    continue;
                }
                var color = attrToProjector["fill"](datum, datumIndex, dataset);
                var dark = Utils.Color.contrast("white", color) * 1.6 < Utils.Color.contrast("black", color);
                var g = labelArea.append("g").attr("transform", "translate(" + x + "," + y + ")");
                var className = dark ? "dark-label" : "light-label";
                g.classed(className, true);
                writer.write(label, measurement.width, measurement.height, {
                    xAlign: "center",
                    yAlign: "center",
                }, g.node());
            }
        }
    };
    Rectangle.prototype._overlayLabel = function (labelXRange, labelYRange, datumIndex, datasetIndex, dataToDraw) {
        var attrToProjector = this._getAttrToProjector();
        var datasets = this.datasets();
        for (var i = datasetIndex; i < datasets.length; i++) {
            var dataset = datasets[i];
            var data = dataToDraw.get(dataset);
            var dataLen = data.length;
            for (var j = (i === datasetIndex ? datumIndex + 1 : 0); j < dataLen; j++) {
                if (Utils.DOM.intersectsBBox(labelXRange, labelYRange, this._entityBBox(data[j], j, dataset, attrToProjector))) {
                    return true;
                }
            }
        }
        return false;
    };
    Rectangle._X2_KEY = "x2";
    Rectangle._Y2_KEY = "y2";
    return Rectangle;
}(xyPlot_1.XYPlot));
exports.Rectangle = Rectangle;

},{"../animators":525,"../drawers":569,"../drawers/drawer":568,"../drawers/rectangleDrawer":571,"../scales":607,"../utils":624,"./plot":597,"./xyPlot":604,"d3":414,"tslib":635,"typesettable":640}],599:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scatter = void 0;
var tslib_1 = require("tslib");
var Typesettable = require("typesettable");
var Formatters = require("../core/formatters");
var SymbolFactories = require("../core/symbolFactories");
var drawer_1 = require("../drawers/drawer");
var symbolDrawer_1 = require("../drawers/symbolDrawer");
var Animators = require("../animators");
var label_1 = require("../components/label");
var Drawers = require("../drawers");
var Scales = require("../scales");
var Utils = require("../utils");
var Plots = require("./");
var plot_1 = require("./plot");
var xyPlot_1 = require("./xyPlot");
var Scatter = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Scatter, _super);
    /**
     * A Scatter Plot draws a symbol at each data point.
     *
     * @constructor
     */
    function Scatter() {
        var _this = _super.call(this) || this;
        _this._labelFormatter = Formatters.identity();
        _this._labelFontSize = label_1.Label._DEFAULT_FONT_SIZE_PX;
        _this._labelsEnabled = false;
        _this.addClass("scatter-plot");
        var animator = new Animators.Easing();
        animator.startDelay(5);
        animator.stepDuration(250);
        animator.maxTotalDuration(plot_1.Plot._ANIMATION_MAX_DURATION);
        _this.animator(Plots.Animator.MAIN, animator);
        _this.attr("opacity", 0.6);
        _this.attr("fill", new Scales.Color().range()[0]);
        _this.size(6);
        var circleSymbolFactory = SymbolFactories.circle();
        _this.symbol(function () { return circleSymbolFactory; });
        _this._labelConfig = new Utils.Map();
        return _this;
    }
    Scatter.prototype._buildLightweightPlotEntities = function (datasets) {
        var _this = this;
        var lightweightPlotEntities = _super.prototype._buildLightweightPlotEntities.call(this, datasets);
        return lightweightPlotEntities.map(function (lightweightPlotEntity) {
            var diameter = plot_1.Plot._scaledAccessor(_this.size())(lightweightPlotEntity.datum, lightweightPlotEntity.index, lightweightPlotEntity.dataset);
            lightweightPlotEntity.diameter = diameter;
            return lightweightPlotEntity;
        });
    };
    Scatter.prototype._createDrawer = function (dataset) {
        var _this = this;
        return new drawer_1.ProxyDrawer(function () { return new symbolDrawer_1.SymbolSVGDrawer(); }, function (ctx) {
            return new Drawers.CanvasDrawer(ctx, (0, symbolDrawer_1.makeSymbolCanvasDrawStep)(dataset, function () { return plot_1.Plot._scaledAccessor(_this.symbol()); }, function () { return plot_1.Plot._scaledAccessor(_this.size()); }));
        });
    };
    Scatter.prototype.size = function (size, scale) {
        if (size == null) {
            return this._propertyBindings.get(Scatter._SIZE_KEY);
        }
        this._bindProperty(Scatter._SIZE_KEY, size, scale);
        this.render();
        return this;
    };
    Scatter.prototype.symbol = function (symbol) {
        if (symbol == null) {
            return this._propertyBindings.get(Scatter._SYMBOL_KEY);
        }
        this._propertyBindings.set(Scatter._SYMBOL_KEY, { accessor: symbol });
        this.render();
        return this;
    };
    Scatter.prototype._generateDrawSteps = function () {
        var drawSteps = [];
        if (this._animateOnNextRender()) {
            var attrToProjector = this._getAttrToProjector();
            var symbolProjector_1 = plot_1.Plot._scaledAccessor(this.symbol());
            attrToProjector["d"] = function (datum, index, dataset) { return symbolProjector_1(datum, index, dataset)(0)(null); };
            drawSteps.push({ attrToProjector: attrToProjector, animator: this._getAnimator(Plots.Animator.RESET) });
        }
        drawSteps.push({
            attrToProjector: this._getAttrToProjector(),
            animator: this._getAnimator(Plots.Animator.MAIN),
        });
        return drawSteps;
    };
    Scatter.prototype._propertyProjectors = function () {
        var propertyToProjectors = _super.prototype._propertyProjectors.call(this);
        var xProjector = plot_1.Plot._scaledAccessor(this.x());
        var yProjector = plot_1.Plot._scaledAccessor(this.y());
        propertyToProjectors["x"] = xProjector;
        propertyToProjectors["y"] = yProjector;
        propertyToProjectors["transform"] = function (datum, index, dataset) {
            return "translate(" + xProjector(datum, index, dataset) + "," + yProjector(datum, index, dataset) + ")";
        };
        propertyToProjectors["d"] = this._constructSymbolGenerator();
        return propertyToProjectors;
    };
    Scatter.prototype._constructSymbolGenerator = function () {
        var symbolProjector = plot_1.Plot._scaledAccessor(this.symbol());
        var sizeProjector = plot_1.Plot._scaledAccessor(this.size());
        return function (datum, index, dataset) {
            return symbolProjector(datum, index, dataset)(sizeProjector(datum, index, dataset))(null);
        };
    };
    Scatter.prototype._entityBounds = function (entity) {
        return {
            x: entity.position.x - entity.diameter / 2,
            y: entity.position.y - entity.diameter / 2,
            width: entity.diameter,
            height: entity.diameter,
        };
    };
    Scatter.prototype._entityVisibleOnPlot = function (entity, bounds) {
        var xRange = { min: bounds.topLeft.x, max: bounds.bottomRight.x };
        var yRange = { min: bounds.topLeft.y, max: bounds.bottomRight.y };
        var translatedBbox = this._entityBounds(entity);
        return Utils.DOM.intersectsBBox(xRange, yRange, translatedBbox);
    };
    /**
     * Gets the Entities at a particular Point.
     *
     * @param {Point} p
     * @returns {PlotEntity[]}
     */
    Scatter.prototype.entitiesAt = function (p) {
        var xProjector = plot_1.Plot._scaledAccessor(this.x());
        var yProjector = plot_1.Plot._scaledAccessor(this.y());
        var sizeProjector = plot_1.Plot._scaledAccessor(this.size());
        return this.entities().filter(function (entity) {
            var datum = entity.datum;
            var index = entity.index;
            var dataset = entity.dataset;
            var x = xProjector(datum, index, dataset);
            var y = yProjector(datum, index, dataset);
            var size = sizeProjector(datum, index, dataset);
            return x - size / 2 <= p.x && p.x <= x + size / 2 && y - size / 2 <= p.y && p.y <= y + size / 2;
        });
    };
    Scatter.prototype.labelsEnabled = function (enabled) {
        if (enabled == null) {
            return this._labelsEnabled;
        }
        else {
            this._labelsEnabled = enabled;
            this._clearAttrToProjectorCache();
            this.render();
            return this;
        }
    };
    Scatter.prototype.labelFontSize = function (fontSize) {
        var _this = this;
        if (fontSize == null) {
            return this._labelFontSize;
        }
        else {
            this.invalidateCache();
            this._labelFontSize = fontSize;
            this._labelConfig.forEach(function (_a) {
                var labelArea = _a.labelArea;
                labelArea.attr("class", null)
                    .classed(Scatter._LABEL_AREA_CLASS, true)
                    .classed("label-" + _this._labelFontSize, true);
            });
            return this.render();
        }
    };
    Scatter.prototype.invalidateCache = function () {
        var _this = this;
        _super.prototype.invalidateCache.call(this);
        this.datasets().forEach(function (dataset) {
            var labelConfig = _this._labelConfig.get(dataset);
            if (labelConfig != null) {
                labelConfig.measurer.reset();
            }
        });
    };
    Scatter.prototype._createNodesForDataset = function (dataset) {
        var drawer = _super.prototype._createNodesForDataset.call(this, dataset);
        var labelArea = this._renderArea.append("g")
            .classed(Scatter._LABEL_AREA_CLASS, true)
            .classed("label-" + this._labelFontSize, true);
        var context = new Typesettable.SvgContext(labelArea.node());
        var measurer = new Typesettable.CacheMeasurer(context);
        var writer = new Typesettable.Writer(measurer, context);
        this._labelConfig.set(dataset, { labelArea: labelArea, measurer: measurer, writer: writer });
        return drawer;
    };
    Scatter.prototype._removeDatasetNodes = function (dataset) {
        _super.prototype._removeDatasetNodes.call(this, dataset);
        var labelConfig = this._labelConfig.get(dataset);
        if (labelConfig != null) {
            labelConfig.labelArea.remove();
            this._labelConfig.delete(dataset);
        }
    };
    Scatter.prototype._additionalPaint = function (time) {
        var _this = this;
        this.datasets().forEach(function (dataset) { return _this._labelConfig.get(dataset).labelArea.selectAll("g").remove(); });
        if (this._labelsEnabled) {
            Utils.Window.setTimeout(function () { return _this._drawLabels(); }, time);
        }
    };
    Scatter.prototype._drawLabels = function () {
        var _this = this;
        var dataToDraw = this._getDataToDraw();
        var attrToProjector = this._getAttrToProjector();
        this.datasets().forEach(function (dataset) {
            var data = dataToDraw.get(dataset);
            var dataLen = data.length;
            for (var index = 0; index < dataLen; index++) {
                var datum = data[index];
                if (datum == null) {
                    continue;
                }
                _this._drawLabel(datum, index, dataset, attrToProjector);
            }
        });
    };
    Scatter.prototype._drawLabel = function (datum, index, dataset, attrToProjector) {
        if (datum.label == null) {
            return;
        }
        var _a = this._labelConfig.get(dataset), labelArea = _a.labelArea, measurer = _a.measurer, writer = _a.writer;
        var scatterCoordinates = { x: attrToProjector["x"](datum, index, dataset), y: attrToProjector["y"](datum, index, dataset) };
        var sizeProjector = plot_1.Plot._scaledAccessor(this.size());
        var diameter = sizeProjector(datum, index, dataset);
        var label = this._labelFormatter(datum.label, datum, index, dataset);
        var measurement = measurer.measure(label);
        var _b = this._calculateLabelProperties(scatterCoordinates, diameter, measurement), containerDimensions = _b.containerDimensions, labelContainerOrigin = _b.labelContainerOrigin, labelOrigin = _b.labelOrigin, alignment = _b.alignment;
        var labelContainer = this._createLabelContainer(labelArea, labelContainerOrigin, labelOrigin, measurement);
        var writeOptions = { xAlign: alignment.x, yAlign: alignment.y };
        writer.write(label, containerDimensions.width, containerDimensions.height, writeOptions, labelContainer.node());
    };
    Scatter.prototype._calculateLabelProperties = function (pointCoordinates, diameter, measurement) {
        // If diameter is smaller than font size, put label above
        var labelShift = diameter < measurement.height ? diameter / 2 + Scatter._LABEL_MARGIN_FROM_BUBBLE : 0;
        return {
            containerDimensions: {
                width: measurement.width,
                height: measurement.height,
            },
            labelContainerOrigin: {
                x: pointCoordinates.x - measurement.width / 2,
                y: pointCoordinates.y - measurement.height / 2 + labelShift,
            },
            labelOrigin: {
                x: pointCoordinates.x,
                y: pointCoordinates.y,
            },
            alignment: {
                x: "center",
                y: "center",
            },
        };
    };
    Scatter.prototype._createLabelContainer = function (labelArea, labelContainerOrigin, labelOrigin, measurement) {
        var labelContainer = labelArea.append("g")
            .attr("transform", "translate(" + labelContainerOrigin.x + ", " + labelContainerOrigin.y + ")");
        labelContainer.classed("on-bar-label", true);
        return labelContainer;
    };
    Scatter._SIZE_KEY = "size";
    Scatter._SYMBOL_KEY = "symbol";
    // label stuff
    Scatter._LABEL_AREA_CLASS = "scatter-label-text-area";
    Scatter._LABEL_MARGIN_FROM_BUBBLE = 15;
    return Scatter;
}(xyPlot_1.XYPlot));
exports.Scatter = Scatter;

},{"../animators":525,"../components/label":541,"../core/formatters":551,"../core/symbolFactories":555,"../drawers":569,"../drawers/drawer":568,"../drawers/symbolDrawer":574,"../scales":607,"../utils":624,"./":594,"./plot":597,"./xyPlot":604,"tslib":635,"typesettable":640}],600:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Segment = void 0;
var tslib_1 = require("tslib");
var Animators = require("../animators");
var drawer_1 = require("../drawers/drawer");
var segmentDrawer_1 = require("../drawers/segmentDrawer");
var Scales = require("../scales");
var windowUtils_1 = require("../utils/windowUtils");
var plot_1 = require("./plot");
var xyPlot_1 = require("./xyPlot");
var Segment = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Segment, _super);
    /**
     * A Segment Plot displays line segments based on the data.
     *
     * @constructor
     */
    function Segment() {
        var _this = _super.call(this) || this;
        _this.addClass("segment-plot");
        _this.attr("stroke", new Scales.Color().range()[0]);
        _this.attr("stroke-width", "2px");
        return _this;
    }
    Segment.prototype._createDrawer = function () {
        return new drawer_1.ProxyDrawer(function () { return new segmentDrawer_1.SegmentSVGDrawer(); }, function () {
            (0, windowUtils_1.warn)("canvas renderer is not supported on Segment Plot!");
            return null;
        });
    };
    Segment.prototype._generateDrawSteps = function () {
        return [{ attrToProjector: this._getAttrToProjector(), animator: new Animators.Null() }];
    };
    Segment.prototype._filterForProperty = function (property) {
        if (property === "x2") {
            return _super.prototype._filterForProperty.call(this, "x");
        }
        else if (property === "y2") {
            return _super.prototype._filterForProperty.call(this, "y");
        }
        return _super.prototype._filterForProperty.call(this, property);
    };
    Segment.prototype.x = function (x, xScale) {
        if (x == null) {
            return _super.prototype.x.call(this);
        }
        if (xScale == null) {
            _super.prototype.x.call(this, x);
        }
        else {
            _super.prototype.x.call(this, x, xScale);
            var x2Binding = this.x2();
            var x2 = x2Binding && x2Binding.accessor;
            if (x2 != null) {
                this._bindProperty(Segment._X2_KEY, x2, xScale);
            }
        }
        return this;
    };
    Segment.prototype.x2 = function (x2) {
        if (x2 == null) {
            return this._propertyBindings.get(Segment._X2_KEY);
        }
        var xBinding = this.x();
        var xScale = xBinding && xBinding.scale;
        this._bindProperty(Segment._X2_KEY, x2, xScale);
        this.render();
        return this;
    };
    Segment.prototype.y = function (y, yScale) {
        if (y == null) {
            return _super.prototype.y.call(this);
        }
        if (yScale == null) {
            _super.prototype.y.call(this, y);
        }
        else {
            _super.prototype.y.call(this, y, yScale);
            var y2Binding = this.y2();
            var y2 = y2Binding && y2Binding.accessor;
            if (y2 != null) {
                this._bindProperty(Segment._Y2_KEY, y2, yScale);
            }
        }
        return this;
    };
    Segment.prototype.y2 = function (y2) {
        if (y2 == null) {
            return this._propertyBindings.get(Segment._Y2_KEY);
        }
        var yBinding = this.y();
        var yScale = yBinding && yBinding.scale;
        this._bindProperty(Segment._Y2_KEY, y2, yScale);
        this.render();
        return this;
    };
    Segment.prototype._propertyProjectors = function () {
        var attrToProjector = _super.prototype._propertyProjectors.call(this);
        attrToProjector["x1"] = plot_1.Plot._scaledAccessor(this.x());
        attrToProjector["x2"] = this.x2() == null ? plot_1.Plot._scaledAccessor(this.x()) : plot_1.Plot._scaledAccessor(this.x2());
        attrToProjector["y1"] = plot_1.Plot._scaledAccessor(this.y());
        attrToProjector["y2"] = this.y2() == null ? plot_1.Plot._scaledAccessor(this.y()) : plot_1.Plot._scaledAccessor(this.y2());
        return attrToProjector;
    };
    Segment.prototype.entitiesAt = function (point) {
        var entity = this.entityNearest(point);
        if (entity != null) {
            return [entity];
        }
        else {
            return [];
        }
    };
    Segment.prototype.entitiesIn = function (xRangeOrBounds, yRange) {
        var dataXRange;
        var dataYRange;
        if (yRange == null) {
            var bounds = xRangeOrBounds;
            dataXRange = { min: bounds.topLeft.x, max: bounds.bottomRight.x };
            dataYRange = { min: bounds.topLeft.y, max: bounds.bottomRight.y };
        }
        else {
            dataXRange = xRangeOrBounds;
            dataYRange = yRange;
        }
        return this._entitiesIntersecting(dataXRange, dataYRange);
    };
    Segment.prototype._entitiesIntersecting = function (xRange, yRange) {
        var intersected = [];
        var attrToProjector = this._getAttrToProjector();
        var entities = this.entities();
        var entitiesLen = entities.length;
        for (var i = 0; i < entitiesLen; i++) {
            var entity = entities[i];
            if (this._lineIntersectsBox(entity, xRange, yRange, attrToProjector)) {
                intersected.push(entity);
            }
        }
        return intersected;
    };
    Segment.prototype._lineIntersectsBox = function (entity, xRange, yRange, attrToProjector) {
        var _this = this;
        var x1 = attrToProjector["x1"](entity.datum, entity.index, entity.dataset);
        var x2 = attrToProjector["x2"](entity.datum, entity.index, entity.dataset);
        var y1 = attrToProjector["y1"](entity.datum, entity.index, entity.dataset);
        var y2 = attrToProjector["y2"](entity.datum, entity.index, entity.dataset);
        // check if any of end points of the segment is inside the box
        if ((xRange.min <= x1 && x1 <= xRange.max && yRange.min <= y1 && y1 <= yRange.max) ||
            (xRange.min <= x2 && x2 <= xRange.max && yRange.min <= y2 && y2 <= yRange.max)) {
            return true;
        }
        var startPoint = { x: x1, y: y1 };
        var endPoint = { x: x2, y: y2 };
        var corners = [
            { x: xRange.min, y: yRange.min },
            { x: xRange.min, y: yRange.max },
            { x: xRange.max, y: yRange.max },
            { x: xRange.max, y: yRange.min },
        ];
        var intersections = corners.filter(function (point, index) {
            if (index !== 0) {
                // return true if border formed by conecting current corner and previous corner intersects with the segment
                return _this._lineIntersectsSegment(startPoint, endPoint, point, corners[index - 1]) &&
                    _this._lineIntersectsSegment(point, corners[index - 1], startPoint, endPoint);
            }
            return false;
        });
        return intersections.length > 0;
    };
    Segment.prototype._lineIntersectsSegment = function (point1, point2, point3, point4) {
        // tslint:disable-next-line:no-shadowed-variable
        var calcOrientation = function (point1, point2, point) {
            return (point2.x - point1.x) * (point.y - point2.y) - (point2.y - point1.y) * (point.x - point2.x);
        };
        // point3 and point4 are on different sides of line formed by point1 and point2
        return calcOrientation(point1, point2, point3) * calcOrientation(point1, point2, point4) < 0;
    };
    Segment._X2_KEY = "x2";
    Segment._Y2_KEY = "y2";
    return Segment;
}(xyPlot_1.XYPlot));
exports.Segment = Segment;

},{"../animators":525,"../drawers/drawer":568,"../drawers/segmentDrawer":572,"../scales":607,"../utils/windowUtils":634,"./plot":597,"./xyPlot":604,"tslib":635}],601:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackedArea = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Animators = require("../animators");
var index_1 = require("../memoize/index");
var Utils = require("../utils");
var areaPlot_1 = require("./areaPlot");
var plot_1 = require("./plot");
var StackedArea = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(StackedArea, _super);
    /**
     * @constructor
     */
    function StackedArea() {
        var _this = _super.call(this) || this;
        _this._stackingResult = (0, index_1.memThunk)(function () { return _this.datasets(); }, function () { return _this.x().accessor; }, function () { return _this.y().accessor; }, function () { return _this._stackingOrder; }, function (datasets, keyAccessor, valueAccessor, stackingOrder) {
            return Utils.Stacking.stack(datasets, keyAccessor, valueAccessor, stackingOrder);
        });
        _this._stackedExtent = (0, index_1.memThunk)(_this._stackingResult, function () { return _this.x().accessor; }, function () { return _this._filterForProperty("y"); }, function (stackingResult, keyAccessor, filter) {
            return Utils.Stacking.stackedExtent(stackingResult, keyAccessor, filter);
        });
        _this._baselineValue = 0;
        _this._stackingOrder = "bottomup";
        _this.addClass("stacked-area-plot");
        _this._baselineValueProvider = function () { return [_this._baselineValue]; };
        _this.croppedRenderingEnabled(false);
        return _this;
    }
    StackedArea.prototype.croppedRenderingEnabled = function (croppedRendering) {
        if (croppedRendering == null) {
            return _super.prototype.croppedRenderingEnabled.call(this);
        }
        if (croppedRendering) {
            // HACKHACK #3032: cropped rendering doesn't currently work correctly on StackedArea
            Utils.Window.warn("Warning: Stacked Area Plot does not support cropped rendering.");
            return this;
        }
        return _super.prototype.croppedRenderingEnabled.call(this, croppedRendering);
    };
    StackedArea.prototype._getAnimator = function (key) {
        return new Animators.Null();
    };
    StackedArea.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._baseline = this._renderArea.append("line").classed("baseline", true);
    };
    StackedArea.prototype.x = function (x, xScale) {
        if (x == null) {
            return _super.prototype.x.call(this);
        }
        if (xScale == null) {
            _super.prototype.x.call(this, x);
        }
        else {
            _super.prototype.x.call(this, x, xScale);
        }
        this._checkSameDomain();
        return this;
    };
    StackedArea.prototype.y = function (y, yScale) {
        if (y == null) {
            return _super.prototype.y.call(this);
        }
        if (yScale == null) {
            _super.prototype.y.call(this, y);
        }
        else {
            _super.prototype.y.call(this, y, yScale);
        }
        this._checkSameDomain();
        return this;
    };
    /**
     * Gets the offset of the y value corresponding to an x value of a given dataset. This allows other plots to plot
     * points corresponding to their stacked value in the graph.
     * @param dataset The dataset from which to retrieve the y value offset
     * @param x The x value corresponding to the y-value of interest.
     */
    StackedArea.prototype.yOffset = function (dataset, x) {
        var stackingResult = this._stackingResult();
        if (stackingResult == null) {
            return undefined;
        }
        var datasetStackingResult = stackingResult.get(dataset);
        if (datasetStackingResult == null) {
            return undefined;
        }
        var result = datasetStackingResult.get(String(x));
        if (result == null) {
            return undefined;
        }
        return result.offset;
    };
    StackedArea.prototype.stackingOrder = function (stackingOrder) {
        if (stackingOrder == null) {
            return this._stackingOrder;
        }
        this._stackingOrder = stackingOrder;
        this._onDatasetUpdate();
        return this;
    };
    StackedArea.prototype.downsamplingEnabled = function (downsampling) {
        if (downsampling == null) {
            return _super.prototype.downsamplingEnabled.call(this);
        }
        Utils.Window.warn("Warning: Stacked Area Plot does not support downsampling");
        return this;
    };
    StackedArea.prototype._additionalPaint = function () {
        var scaledBaseline = this.y().scale.scale(this._baselineValue);
        var baselineAttr = {
            x1: 0,
            y1: scaledBaseline,
            x2: this.width(),
            y2: scaledBaseline,
        };
        this._getAnimator("baseline").animate(this._baseline, baselineAttr);
    };
    StackedArea.prototype._updateYScale = function () {
        var yBinding = this.y();
        var scale = (yBinding && yBinding.scale);
        if (scale == null) {
            return;
        }
        scale.addPaddingExceptionsProvider(this._baselineValueProvider);
        scale.addIncludedValuesProvider(this._baselineValueProvider);
    };
    StackedArea.prototype._onDatasetUpdate = function () {
        this._checkSameDomain();
        _super.prototype._onDatasetUpdate.call(this);
        return this;
    };
    StackedArea.prototype.getExtentsForProperty = function (attr) {
        var primaryAttr = "y";
        if (attr === primaryAttr) {
            return [this._stackedExtent()];
        }
        else {
            return _super.prototype.getExtentsForProperty.call(this, attr);
        }
    };
    StackedArea.prototype._checkSameDomain = function () {
        if (!this._projectorsReady()) {
            return;
        }
        var datasets = this.datasets();
        var keyAccessor = this.x().accessor;
        var keySets = datasets.map(function (dataset) {
            return d3.set(dataset.data().map(function (datum, i) { return Utils.Stacking.normalizeKey(keyAccessor(datum, i, dataset)); })).values();
        });
        var domainKeys = StackedArea._domainKeys(datasets, keyAccessor);
        if (keySets.some(function (keySet) { return keySet.length !== domainKeys.length; })) {
            Utils.Window.warn("the domains across the datasets are not the same. Plot may produce unintended behavior.");
        }
    };
    /**
     * Given an array of Datasets and the accessor function for the key, computes the
     * set reunion (no duplicates) of the domain of each Dataset. The keys are stringified
     * before being returned.
     *
     * @param {Dataset[]} datasets The Datasets for which we extract the domain keys
     * @param {Accessor<any>} keyAccessor The accessor for the key of the data
     * @return {string[]} An array of stringified keys
     */
    StackedArea._domainKeys = function (datasets, keyAccessor) {
        var domainKeys = d3.set();
        datasets.forEach(function (dataset) {
            var data = dataset.data();
            var dataLen = data.length;
            for (var index = 0; index < dataLen; index++) {
                var datum = data[index];
                domainKeys.add(keyAccessor(datum, index, dataset));
            }
        });
        return domainKeys.values();
    };
    StackedArea.prototype._coordinateProjectors = function () {
        var _this = this;
        var xProjector = plot_1.Plot._scaledAccessor(this.x());
        var yAccessor = this.y().accessor;
        var xAccessor = this.x().accessor;
        var normalizedXAccessor = function (datum, index, dataset) {
            return Utils.Stacking.normalizeKey(xAccessor(datum, index, dataset));
        };
        var stackingResult = this._stackingResult();
        var stackYProjector = function (d, i, dataset) {
            var y = +yAccessor(d, i, dataset);
            var offset = stackingResult.get(dataset).get(normalizedXAccessor(d, i, dataset)).offset;
            return _this.y().scale.scale(y + offset);
        };
        var stackY0Projector = function (d, i, dataset) {
            var offset = stackingResult.get(dataset).get(normalizedXAccessor(d, i, dataset)).offset;
            return _this.y().scale.scale(offset);
        };
        return [
            xProjector,
            stackYProjector,
            stackY0Projector,
        ];
    };
    StackedArea.prototype._propertyProjectors = function () {
        var propertyToProjectors = _super.prototype._propertyProjectors.call(this);
        var _a = this._coordinateProjectors(), xProjector = _a[0], stackYProjector = _a[1], stackY0Projector = _a[2];
        propertyToProjectors["d"] = this._constructAreaProjector(xProjector, stackYProjector, stackY0Projector);
        return propertyToProjectors;
    };
    StackedArea.prototype._pixelPoint = function (datum, index, dataset) {
        var pixelPoint = _super.prototype._pixelPoint.call(this, datum, index, dataset);
        var xValue = this.x().accessor(datum, index, dataset);
        var yValue = this.y().accessor(datum, index, dataset);
        var scaledYValue = this.y().scale.scale(+yValue + this._stackingResult().get(dataset).get(Utils.Stacking.normalizeKey(xValue)).offset);
        return { x: pixelPoint.x, y: scaledYValue };
    };
    return StackedArea;
}(areaPlot_1.Area));
exports.StackedArea = StackedArea;

},{"../animators":525,"../memoize/index":584,"../utils":624,"./areaPlot":589,"./plot":597,"d3":414,"tslib":635}],602:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackedBar = void 0;
var tslib_1 = require("tslib");
var Typesettable = require("typesettable");
var formatters_1 = require("../core/formatters");
var memoize_1 = require("../memoize");
var Utils = require("../utils");
var barPlot_1 = require("./barPlot");
var plot_1 = require("./plot");
var StackedBar = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(StackedBar, _super);
    /**
     * A StackedBar Plot stacks bars across Datasets based on the primary value of the bars.
     *   On a vertical StackedBar Plot, the bars with the same X value are stacked.
     *   On a horizontal StackedBar Plot, the bars with the same Y value are stacked.
     *
     * @constructor
     * @param {Scale} xScale
     * @param {Scale} yScale
     * @param {string} [orientation="vertical"] One of "vertical"/"horizontal".
     */
    function StackedBar(orientation) {
        if (orientation === void 0) { orientation = "vertical"; }
        var _this = _super.call(this, orientation) || this;
        _this._extremaFormatter = (0, formatters_1.identity)();
        _this._stackingResult = (0, memoize_1.memThunk)(function () { return _this.datasets(); }, function () { return _this.position().accessor; }, function () { return _this.length().accessor; }, function () { return _this._stackingOrder; }, function (datasets, positionAccessor, lengthAccessor, stackingOrder) {
            return Utils.Stacking.stack(datasets, positionAccessor, lengthAccessor, stackingOrder);
        });
        _this._stackedExtent = (0, memoize_1.memThunk)(_this._stackingResult, function () { return _this.position().accessor; }, function () { return _this._filterForProperty(_this._isVertical ? "y" : "x"); }, function (stackingResult, positionAccessor, filter) {
            return Utils.Stacking.stackedExtent(stackingResult, positionAccessor, filter);
        });
        _this.addClass("stacked-bar-plot");
        _this._stackingOrder = "bottomup";
        return _this;
    }
    StackedBar.prototype.stackingOrder = function (stackingOrder) {
        if (stackingOrder == null) {
            return this._stackingOrder;
        }
        this._stackingOrder = stackingOrder;
        this._onDatasetUpdate();
        return this;
    };
    StackedBar.prototype.extremaFormatter = function (formatter) {
        if (arguments.length === 0) {
            return this._extremaFormatter;
        }
        else {
            this._extremaFormatter = formatter;
            this.render();
            return this;
        }
    };
    StackedBar.prototype.labelFontSize = function (fontSize) {
        if (fontSize == null) {
            return _super.prototype.labelFontSize.call(this);
        }
        else {
            if (this._labelArea != null) {
                // clearing to remove outdated font-size classes
                this._labelArea.attr("class", null)
                    .classed(barPlot_1.Bar._LABEL_AREA_CLASS, true)
                    .classed("label-" + this._labelFontSize, true);
            }
            _super.prototype.labelFontSize.call(this, fontSize);
            return this;
        }
    };
    StackedBar.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._labelArea = this._renderArea
            .append("g")
            .classed(barPlot_1.Bar._LABEL_AREA_CLASS, true)
            .classed("label-" + this._labelFontSize, true);
        var context = new Typesettable.SvgContext(this._labelArea.node());
        this._measurer = new Typesettable.CacheMeasurer(context);
        this._writer = new Typesettable.Writer(this._measurer, context);
    };
    StackedBar.prototype._drawLabels = function () {
        var _this = this;
        _super.prototype._drawLabels.call(this);
        // remove all current labels before redrawing
        this._labelArea.selectAll("g").remove();
        var baselineValue = +this.baselineValue();
        var positionScale = this.position().scale;
        var lengthScale = this.length().scale;
        var _a = Utils.Stacking.stackedExtents(this._stackingResult()), maximumExtents = _a.maximumExtents, minimumExtents = _a.minimumExtents;
        var anyTooWide = [];
        /**
         * Try drawing the text at the center of the bounds. This method does not draw
         * the text if the text would overflow outside of the plot.
         *
         * @param text
         * @param bounds
         * @returns {boolean}
         */
        var maybeDrawLabel = function (text, bounds, barThickness) {
            var _a = bounds.topLeft, x = _a.x, y = _a.y;
            var width = bounds.bottomRight.x - bounds.topLeft.x;
            var height = bounds.bottomRight.y - bounds.topLeft.y;
            var textTooLong = _this._isVertical
                ? width > barThickness
                : height > barThickness;
            if (!textTooLong) {
                var labelContainer = _this._labelArea.append("g").attr("transform", "translate(" + x + ", " + y + ")");
                labelContainer.classed("stacked-bar-label", true);
                var writeOptions = {
                    xAlign: "center",
                    yAlign: "center",
                };
                _this._writer.write(text, width, height, writeOptions, labelContainer.node());
            }
            return textTooLong;
        };
        var drawLabelsForExtents = function (stacks, computeLabelTopLeft) {
            var attrToProjector = _this._generateAttrToProjector();
            var plotWidth = _this.width();
            var plotHeight = _this.height();
            stacks.forEach(function (stack) {
                if (stack.extent !== baselineValue) {
                    // only draw sums for values not at the baseline
                    var text = _this.extremaFormatter()(stack.extent);
                    var textDimensions = _this._measurer.measure(text);
                    var stackedDatum = stack.stackedDatum;
                    var originalDatum = stackedDatum.originalDatum, originalIndex = stackedDatum.originalIndex, originalDataset = stackedDatum.originalDataset;
                    // only consider stack extents that are on the screen
                    if (!_this._isDatumOnScreen(attrToProjector, plotWidth, plotHeight, originalDatum, originalIndex, originalDataset)) {
                        return;
                    }
                    var barThickness = plot_1.Plot._scaledAccessor(_this.attr(barPlot_1.Bar._BAR_THICKNESS_KEY))(originalDatum, originalIndex, originalDataset);
                    /*
                     * The stackEdge is aligned at the edge of the stack in the length dimension,
                     * and in the center of the stack in the thickness dimension.
                     */
                    var stackEdgeLength = lengthScale.scale(stack.extent);
                    var stackCenterPosition = _this._getPositionAttr(positionScale.scale(stack.axisValue), barThickness) + barThickness / 2;
                    var stackEdge = _this._isVertical
                        ? {
                            x: stackCenterPosition,
                            y: stackEdgeLength,
                        }
                        : {
                            x: stackEdgeLength,
                            y: stackCenterPosition,
                        };
                    var topLeft = computeLabelTopLeft(stackEdge, textDimensions, barThickness);
                    var isTooWide = maybeDrawLabel(text, {
                        topLeft: topLeft,
                        bottomRight: {
                            x: topLeft.x + textDimensions.width,
                            y: topLeft.y + textDimensions.height,
                        },
                    }, barThickness);
                    anyTooWide.push(isTooWide);
                }
            });
        };
        drawLabelsForExtents(maximumExtents, function (stackEdge, measurement, thickness) {
            var primaryTextMeasurement = _this._isVertical ? measurement.width : measurement.height;
            var secondaryTextMeasurement = _this._isVertical ? measurement.height : measurement.width;
            return {
                x: _this._isVertical
                    ? stackEdge.x - primaryTextMeasurement / 2
                    : stackEdge.x + StackedBar._EXTREMA_LABEL_MARGIN_FROM_BAR,
                y: _this._isVertical
                    ? stackEdge.y - secondaryTextMeasurement
                    : stackEdge.y - primaryTextMeasurement / 2,
            };
        });
        drawLabelsForExtents(minimumExtents, function (stackEdge, measurement, thickness) {
            var primaryTextMeasurement = _this._isVertical ? measurement.width : measurement.height;
            var secondaryTextMeasurement = _this._isVertical ? measurement.height : measurement.width;
            return {
                x: _this._isVertical
                    ? stackEdge.x - primaryTextMeasurement / 2
                    : stackEdge.x - secondaryTextMeasurement,
                y: _this._isVertical
                    ? stackEdge.y + StackedBar._EXTREMA_LABEL_MARGIN_FROM_BAR
                    : stackEdge.y - primaryTextMeasurement / 2,
            };
        });
        if (anyTooWide.some(function (d) { return d; })) {
            this._labelArea.selectAll("g").remove();
        }
    };
    StackedBar.prototype._generateAttrToProjector = function () {
        var _this = this;
        var attrToProjector = _super.prototype._generateAttrToProjector.call(this);
        var valueAttr = this._isVertical ? "y" : "x";
        var lengthScale = this.length().scale;
        var lengthAccessor = this.length().accessor;
        var positionAccessor = this.position().accessor;
        var normalizedPositionAccessor = function (datum, index, dataset) {
            return Utils.Stacking.normalizeKey(positionAccessor(datum, index, dataset));
        };
        var stackingResult = this._stackingResult();
        var getStart = function (d, i, dataset) {
            return lengthScale.scale(stackingResult.get(dataset).get(normalizedPositionAccessor(d, i, dataset)).offset);
        };
        var getEnd = function (d, i, dataset) {
            return lengthScale.scale(+lengthAccessor(d, i, dataset) +
                stackingResult.get(dataset).get(normalizedPositionAccessor(d, i, dataset)).offset);
        };
        var heightF = function (d, i, dataset) {
            return Math.abs(getEnd(d, i, dataset) - getStart(d, i, dataset));
        };
        attrToProjector[this._isVertical ? "height" : "width"] = heightF;
        var attrFunction = function (d, i, dataset) {
            return +lengthAccessor(d, i, dataset) < 0 ? getStart(d, i, dataset) : getEnd(d, i, dataset);
        };
        attrToProjector[valueAttr] = function (d, i, dataset) {
            return _this._isVertical ? attrFunction(d, i, dataset) : attrFunction(d, i, dataset) - heightF(d, i, dataset);
        };
        return attrToProjector;
    };
    StackedBar.prototype.getExtentsForProperty = function (attr) {
        var primaryAttr = this._isVertical ? "y" : "x";
        if (attr === primaryAttr) {
            return [this._stackedExtent()];
        }
        else {
            return _super.prototype.getExtentsForProperty.call(this, attr);
        }
    };
    StackedBar.prototype.invalidateCache = function () {
        _super.prototype.invalidateCache.call(this);
        if (this._measurer != null) {
            this._measurer.reset();
        }
    };
    StackedBar._EXTREMA_LABEL_MARGIN_FROM_BAR = 5;
    return StackedBar;
}(barPlot_1.Bar));
exports.StackedBar = StackedBar;

},{"../core/formatters":551,"../memoize":584,"../utils":624,"./barPlot":590,"./plot":597,"tslib":635,"typesettable":640}],603:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Waterfall = void 0;
var tslib_1 = require("tslib");
var Utils = require("../utils");
var barPlot_1 = require("./barPlot");
var plot_1 = require("./plot");
var Waterfall = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Waterfall, _super);
    function Waterfall() {
        var _this = _super.call(this) || this;
        _this._connectorsEnabled = false;
        _this.addClass("waterfall-plot");
        return _this;
    }
    Waterfall.prototype.connectorsEnabled = function (enabled) {
        if (enabled == null) {
            return this._connectorsEnabled;
        }
        this._connectorsEnabled = enabled;
        return this;
    };
    Waterfall.prototype.total = function (total) {
        if (total == null) {
            return this._propertyBindings.get(Waterfall._TOTAL_KEY);
        }
        this._bindProperty(Waterfall._TOTAL_KEY, total, null);
        return this;
    };
    Waterfall.prototype._additionalPaint = function (time) {
        var _this = this;
        this._connectorArea.selectAll("line").remove();
        if (this._connectorsEnabled) {
            Utils.Window.setTimeout(function () { return _this._drawConnectors(); }, time);
        }
    };
    Waterfall.prototype._createNodesForDataset = function (dataset) {
        var drawer = _super.prototype._createNodesForDataset.call(this, dataset);
        this._connectorArea = this._renderArea.append("g").classed(Waterfall._CONNECTOR_AREA_CLASS, true);
        return drawer;
    };
    Waterfall.prototype.getExtentsForProperty = function (attr) {
        var primaryAttr = "y";
        if (attr === primaryAttr) {
            return [this._extent];
        }
        else {
            return _super.prototype.getExtentsForProperty.call(this, attr);
        }
    };
    Waterfall.prototype._generateAttrToProjector = function () {
        var _this = this;
        var attrToProjector = _super.prototype._generateAttrToProjector.call(this);
        var yScale = this.y().scale;
        var totalAccessor = plot_1.Plot._scaledAccessor(this.total());
        var yAttr = this.attr("y");
        if (yAttr == null) {
            attrToProjector["y"] = function (d, i, dataset) {
                var currentValue = _this.y().accessor(d, i, dataset);
                var isTotal = totalAccessor(d, i, dataset);
                if (isTotal) {
                    return Math.min(yScale.scale(currentValue), yScale.scale(0));
                }
                else {
                    var currentSubtotal = _this._subtotals[i];
                    if (i === 0) {
                        if (currentValue < 0) {
                            return yScale.scale(currentSubtotal - currentValue);
                        }
                        else {
                            return yScale.scale(currentSubtotal);
                        }
                    }
                    var priorSubtotal = _this._subtotals[i - 1];
                    if (currentSubtotal > priorSubtotal) {
                        return yScale.scale(currentSubtotal);
                    }
                    else {
                        return yScale.scale(priorSubtotal);
                    }
                }
            };
        }
        var heightAttr = this.attr("height");
        if (heightAttr == null) {
            attrToProjector["height"] = function (d, i, dataset) {
                var isTotal = totalAccessor(d, i, dataset);
                var currentValue = _this.y().accessor(d, i, dataset);
                if (isTotal) {
                    return Math.abs(yScale.scale(currentValue) - yScale.scale(0));
                }
                else {
                    var currentSubtotal = _this._subtotals[i];
                    if (i === 0) {
                        return Math.abs(yScale.scale(currentSubtotal) - yScale.scale(currentSubtotal - currentValue));
                    }
                    else {
                        var priorSubtotal = _this._subtotals[i - 1];
                        return Math.abs(yScale.scale(currentSubtotal) - yScale.scale(priorSubtotal));
                    }
                }
            };
        }
        attrToProjector["class"] = function (d, i, dataset) {
            var baseClass = "";
            if (_this.attr("class") != null) {
                baseClass = _this.attr("class").accessor(d, i, dataset) + " ";
            }
            var isTotal = totalAccessor(d, i, dataset);
            if (isTotal) {
                return baseClass + Waterfall._BAR_TOTAL_CLASS;
            }
            else {
                var delta = _this.y().accessor(d, i, dataset);
                return baseClass + (delta > 0 ? Waterfall._BAR_GROWTH_CLASS : Waterfall._BAR_DECLINE_CLASS);
            }
        };
        return attrToProjector;
    };
    Waterfall.prototype._onDatasetUpdate = function () {
        this._updateSubtotals();
        _super.prototype._onDatasetUpdate.call(this);
        return this;
    };
    Waterfall.prototype._calculateSubtotalsAndExtent = function (dataset) {
        var min = Number.MAX_VALUE;
        var max = Number.MIN_VALUE;
        var total = 0;
        var hasStarted = false;
        var data = dataset.data();
        var dataLen = data.length;
        for (var index = 0; index < dataLen; index++) {
            var datum = data[index];
            var currentValue = this.y().accessor(datum, index, dataset);
            var isTotal = this.total().accessor(datum, index, dataset);
            if (!isTotal || index === 0) {
                total += currentValue;
            }
            this._subtotals.push(total);
            if (total < min) {
                min = total;
            }
            if (total > max) {
                max = total;
            }
            if (isTotal) {
                if (currentValue < min) {
                    min = currentValue;
                }
                if (currentValue > max) {
                    max = currentValue;
                }
            }
            if (!hasStarted && isTotal) {
                var startTotal = currentValue - total;
                for (var i = 0; i < this._subtotals.length; i++) {
                    this._subtotals[i] += startTotal;
                }
                hasStarted = true;
                total += startTotal;
                min += startTotal;
                max += startTotal;
            }
        }
        this._extent = [min, max];
    };
    Waterfall.prototype._drawConnectors = function () {
        var attrToProjector = this._getAttrToProjector();
        var dataset = this.datasets()[0];
        for (var datumIndex = 1; datumIndex < dataset.data().length; datumIndex++) {
            var prevIndex = datumIndex - 1;
            var datum = dataset.data()[datumIndex];
            var prevDatum = dataset.data()[prevIndex];
            var x = attrToProjector["x"](prevDatum, prevIndex, dataset);
            var x2 = attrToProjector["x"](datum, datumIndex, dataset) + attrToProjector["width"](datum, datumIndex, dataset);
            var y = attrToProjector["y"](datum, datumIndex, dataset);
            if ((this._subtotals[datumIndex] > 0 && this._subtotals[datumIndex] > this._subtotals[prevIndex]) ||
                (this._subtotals[datumIndex] < 0 && this._subtotals[datumIndex] >= this._subtotals[prevIndex])) {
                y = attrToProjector["y"](datum, datumIndex, dataset) + attrToProjector["height"](datum, datumIndex, dataset);
            }
            this._connectorArea.append("line").classed(Waterfall._CONNECTOR_CLASS, true)
                .attr("x1", x).attr("x2", x2).attr("y1", y).attr("y2", y);
        }
    };
    Waterfall.prototype._updateSubtotals = function () {
        var datasets = this.datasets();
        if (datasets.length > 0) {
            var dataset = datasets[datasets.length - 1];
            this._subtotals = new Array();
            this._calculateSubtotalsAndExtent(dataset);
        }
    };
    Waterfall._BAR_DECLINE_CLASS = "waterfall-decline";
    Waterfall._BAR_GROWTH_CLASS = "waterfall-growth";
    Waterfall._BAR_TOTAL_CLASS = "waterfall-total";
    Waterfall._CONNECTOR_CLASS = "connector";
    Waterfall._CONNECTOR_AREA_CLASS = "connector-area";
    Waterfall._TOTAL_KEY = "total";
    return Waterfall;
}(barPlot_1.Bar));
exports.Waterfall = Waterfall;

},{"../utils":624,"./barPlot":590,"./plot":597,"tslib":635}],604:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XYPlot = void 0;
var tslib_1 = require("tslib");
var Scales = require("../scales");
var Utils = require("../utils");
var deferredRenderer_1 = require("./deferredRenderer");
var plot_1 = require("./plot");
var XYPlot = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(XYPlot, _super);
    /**
     * An XYPlot is a Plot that displays data along two primary directions, X and Y.
     *
     * @constructor
     * @param {Scale} xScale The x scale to use.
     * @param {Scale} yScale The y scale to use.
     */
    function XYPlot() {
        var _this = _super.call(this) || this;
        _this._autoAdjustXScaleDomain = false;
        _this._autoAdjustYScaleDomain = false;
        _this._deferredRendering = false;
        _this._applyDeferredRenderingTransform = function (tx, ty, sx, sy) {
            if (!_this._isAnchored) {
                return;
            }
            if (_this._renderArea != null) {
                _this._renderArea.attr("transform", "translate(" + tx + ", " + ty + ") scale(" + sx + ", " + sy + ")");
            }
            if (_this._canvas != null) {
                _this._canvas.style("transform", "translate(" + tx + "px, " + ty + "px) scale(" + sx + ", " + sy + ")");
            }
        };
        _this.addClass("xy-plot");
        _this._adjustYDomainOnChangeFromXCallback = function (scale) { return _this._adjustYDomainOnChangeFromX(); };
        _this._adjustXDomainOnChangeFromYCallback = function (scale) { return _this._adjustXDomainOnChangeFromY(); };
        _this._renderCallback = function () {
            if (_this.deferredRendering()) {
                var scaleX = _this.x() && _this.x().scale;
                var scaleY = _this.y() && _this.y().scale;
                _this._deferredRenderer.updateDomains(scaleX, scaleY);
            }
            else {
                _this.render();
            }
        };
        _this._deferredRenderer = new deferredRenderer_1.DeferredRenderer(function () { return _this.render(); }, _this._applyDeferredRenderingTransform);
        return _this;
    }
    XYPlot.prototype.render = function () {
        if (this.deferredRendering()) {
            this._deferredRenderer.resetTransforms();
        }
        return _super.prototype.render.call(this);
    };
    XYPlot.prototype.deferredRendering = function (deferredRendering) {
        if (deferredRendering == null) {
            return this._deferredRendering;
        }
        if (deferredRendering) {
            var scaleX = this.x() && this.x().scale;
            var scaleY = this.y() && this.y().scale;
            this._deferredRenderer.setDomains(scaleX, scaleY);
        }
        this._deferredRendering = deferredRendering;
        return this;
    };
    XYPlot.prototype.x = function (x, xScale, postScale) {
        if (x == null) {
            return this._propertyBindings.get(XYPlot._X_KEY);
        }
        this._bindProperty(XYPlot._X_KEY, x, xScale, postScale);
        var width = this.width();
        if (xScale != null && width != null) {
            xScale.range([0, width]);
        }
        if (this._autoAdjustYScaleDomain) {
            this._updateYExtentsAndAutodomain();
        }
        this.render();
        return this;
    };
    XYPlot.prototype.y = function (y, yScale, postScale) {
        if (y == null) {
            return this._propertyBindings.get(XYPlot._Y_KEY);
        }
        this._bindProperty(XYPlot._Y_KEY, y, yScale, postScale);
        var height = this.height();
        if (yScale != null && height != null) {
            if (yScale instanceof Scales.Category) {
                yScale.range([0, height]);
            }
            else {
                yScale.range([height, 0]);
            }
        }
        if (this._autoAdjustXScaleDomain) {
            this._updateXExtentsAndAutodomain();
        }
        this.render();
        return this;
    };
    XYPlot.prototype._filterForProperty = function (property) {
        if (property === "x" && this._autoAdjustXScaleDomain) {
            return this._makeFilterByProperty("y");
        }
        else if ((property === "y" || property === "y0") && this._autoAdjustYScaleDomain) {
            return this._makeFilterByProperty("x");
        }
        return null;
    };
    XYPlot.prototype._makeFilterByProperty = function (property) {
        var binding = this._propertyBindings.get(property);
        if (binding != null) {
            var accessor_1 = binding.accessor;
            var scale_1 = binding.scale;
            if (scale_1 != null) {
                return function (datum, index, dataset) {
                    var range = scale_1.range();
                    return Utils.Math.inRange(scale_1.scale(accessor_1(datum, index, dataset)), range[0], range[1]);
                };
            }
        }
        return null;
    };
    XYPlot.prototype._uninstallScaleForKey = function (scale, key) {
        _super.prototype._uninstallScaleForKey.call(this, scale, key);
        var adjustCallback = key === XYPlot._X_KEY ? this._adjustYDomainOnChangeFromXCallback
            : this._adjustXDomainOnChangeFromYCallback;
        scale.offUpdate(adjustCallback);
    };
    XYPlot.prototype._installScaleForKey = function (scale, key) {
        _super.prototype._installScaleForKey.call(this, scale, key);
        var adjustCallback = key === XYPlot._X_KEY ? this._adjustYDomainOnChangeFromXCallback
            : this._adjustXDomainOnChangeFromYCallback;
        scale.onUpdate(adjustCallback);
    };
    XYPlot.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.x().scale) {
            this.x().scale.offUpdate(this._adjustYDomainOnChangeFromXCallback);
        }
        if (this.y().scale) {
            this.y().scale.offUpdate(this._adjustXDomainOnChangeFromYCallback);
        }
        return this;
    };
    XYPlot.prototype.autorangeMode = function (autorangeMode) {
        if (autorangeMode == null) {
            if (this._autoAdjustXScaleDomain) {
                return "x";
            }
            if (this._autoAdjustYScaleDomain) {
                return "y";
            }
            return "none";
        }
        switch (autorangeMode) {
            case "x":
                this._autoAdjustXScaleDomain = true;
                this._autoAdjustYScaleDomain = false;
                this._adjustXDomainOnChangeFromY();
                break;
            case "y":
                this._autoAdjustXScaleDomain = false;
                this._autoAdjustYScaleDomain = true;
                this._adjustYDomainOnChangeFromX();
                break;
            case "none":
                this._autoAdjustXScaleDomain = false;
                this._autoAdjustYScaleDomain = false;
                break;
            default:
                throw new Error("Invalid scale name '" + autorangeMode + "', must be 'x', 'y' or 'none'");
        }
        return this;
    };
    XYPlot.prototype.computeLayout = function (origin, availableWidth, availableHeight) {
        _super.prototype.computeLayout.call(this, origin, availableWidth, availableHeight);
        var xBinding = this.x();
        var xScale = xBinding && xBinding.scale;
        if (xScale != null) {
            xScale.range([0, this.width()]);
        }
        var yBinding = this.y();
        var yScale = yBinding && yBinding.scale;
        if (yScale != null) {
            if (yScale instanceof Scales.Category) {
                yScale.range([0, this.height()]);
            }
            else {
                yScale.range([this.height(), 0]);
            }
        }
        return this;
    };
    XYPlot.prototype._updateXExtentsAndAutodomain = function () {
        var xScale = this.x().scale;
        if (xScale != null) {
            xScale.autoDomain();
        }
    };
    XYPlot.prototype._updateYExtentsAndAutodomain = function () {
        var yScale = this.y().scale;
        if (yScale != null) {
            yScale.autoDomain();
        }
    };
    /**
     * Adjusts the domains of both X and Y scales to show all data.
     * This call does not override the autorange() behavior.
     *
     * @returns {XYPlot} The calling XYPlot.
     */
    XYPlot.prototype.showAllData = function () {
        this._updateXExtentsAndAutodomain();
        this._updateYExtentsAndAutodomain();
        return this;
    };
    XYPlot.prototype._adjustYDomainOnChangeFromX = function () {
        if (!this._projectorsReady()) {
            return;
        }
        if (this._autoAdjustYScaleDomain) {
            this._updateYExtentsAndAutodomain();
        }
    };
    XYPlot.prototype._adjustXDomainOnChangeFromY = function () {
        if (!this._projectorsReady()) {
            return;
        }
        if (this._autoAdjustXScaleDomain) {
            this._updateXExtentsAndAutodomain();
        }
    };
    XYPlot.prototype._projectorsReady = function () {
        var xBinding = this.x();
        var yBinding = this.y();
        return xBinding != null &&
            xBinding.accessor != null &&
            yBinding != null &&
            yBinding.accessor != null;
    };
    XYPlot.prototype._pixelPoint = function (datum, index, dataset) {
        var xProjector = plot_1.Plot._scaledAccessor(this.x());
        var yProjector = plot_1.Plot._scaledAccessor(this.y());
        return { x: xProjector(datum, index, dataset), y: yProjector(datum, index, dataset) };
    };
    XYPlot.prototype._getDataToDraw = function () {
        var _this = this;
        var dataToDraw = _super.prototype._getDataToDraw.call(this);
        var definedAttr = this.attr("defined");
        var definedFunction = function (d, i, dataset) {
            var positionX = plot_1.Plot._scaledAccessor(_this.x())(d, i, dataset);
            var positionY = plot_1.Plot._scaledAccessor(_this.y())(d, i, dataset);
            if (definedAttr && definedAttr.accessor(d, i, dataset) === false) {
                return false;
            }
            return Utils.Math.isValidNumber(positionX) &&
                Utils.Math.isValidNumber(positionY);
        };
        this.datasets().forEach(function (dataset) {
            dataToDraw.set(dataset, dataToDraw.get(dataset).filter(function (d, i) { return definedFunction(d, i, dataset); }));
        });
        return dataToDraw;
    };
    XYPlot._X_KEY = "x";
    XYPlot._Y_KEY = "y";
    return XYPlot;
}(plot_1.Plot));
exports.XYPlot = XYPlot;

},{"../scales":607,"../utils":624,"./deferredRenderer":593,"./plot":597,"tslib":635}],605:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Category = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var panZoomConstraints_1 = require("../interactions/panZoomConstraints");
var Utils = require("../utils");
var scale_1 = require("./scale");
var TRANSFORMATION_SPACE = [0, 1];
var Category = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Category, _super);
    /**
     * A Category Scale maps strings to numbers.
     *
     * @constructor
     */
    function Category() {
        var _this = _super.call(this) || this;
        _this._range = [0, 1];
        _this._d3Scale = d3.scaleBand();
        _this._d3Scale.range(TRANSFORMATION_SPACE);
        _this._d3TransformationScale = d3.scaleLinear();
        _this._d3TransformationScale.domain(TRANSFORMATION_SPACE);
        var d3InnerPadding = 0.3;
        _this._innerPadding = Category._convertToPlottableInnerPadding(d3InnerPadding);
        _this._outerPadding = Category._convertToPlottableOuterPadding(0.5, d3InnerPadding);
        return _this;
    }
    /**
     * Return a clone of this category scale that holds the same pan/zoom, padding, domain and range, but
     * without any included values providers.
     */
    Category.prototype.cloneWithoutProviders = function () {
        var scale = new Category()
            .domain(this.domain())
            .range(this.range())
            .innerPadding(this.innerPadding())
            .outerPadding(this.outerPadding());
        scale._d3TransformationScale.domain(this._d3TransformationScale.domain());
        return scale;
    };
    Category.prototype.extentOfValues = function (values) {
        return Utils.Array.uniq(values);
    };
    Category.prototype._getExtent = function () {
        return Utils.Array.uniq(this._getAllIncludedValues());
    };
    Category.prototype.domain = function (values) {
        return _super.prototype.domain.call(this, values);
    };
    /**
     * Returns domain values that lie inside the given range.
     * @param range
     * @returns {string[]}
     */
    Category.prototype.invertRange = function (range) {
        var _this = this;
        if (range === void 0) { range = this.range(); }
        var rangeBand = this._d3Scale.bandwidth();
        var domainStartNormalized = this.invertedTransformation(range[0]);
        var domainEndNormalized = this.invertedTransformation(range[1]);
        var domain = this._d3Scale.domain();
        // map ["a", "b", "c"] to the normalized center position (e.g. [0.25, .5, 0.75]). We add
        // half the rangeBand to consider the center of the bars
        var normalizedDomain = domain.map(function (d) { return _this._d3Scale(d) + rangeBand / 2; });
        var domainStart = d3.bisect(normalizedDomain, domainStartNormalized);
        var domainEnd = d3.bisect(normalizedDomain, domainEndNormalized);
        return domain.slice(domainStart, domainEnd);
    };
    Category.prototype.range = function (values) {
        return _super.prototype.range.call(this, values);
    };
    Category._convertToPlottableInnerPadding = function (d3InnerPadding) {
        return 1 / (1 - d3InnerPadding) - 1;
    };
    Category._convertToPlottableOuterPadding = function (d3OuterPadding, d3InnerPadding) {
        return d3OuterPadding / (1 - d3InnerPadding);
    };
    Category.prototype._setBands = function () {
        var d3InnerPadding = 1 - 1 / (1 + this.innerPadding());
        var d3OuterPadding = this.outerPadding() / (1 + this.innerPadding());
        this._d3Scale.paddingInner(d3InnerPadding);
        this._d3Scale.paddingOuter(d3OuterPadding);
    };
    /**
     * Returns the width of the range band.
     *
     * @returns {number} The range band width
     */
    Category.prototype.rangeBand = function () {
        return this._rescaleBand(this._d3Scale.bandwidth());
    };
    /**
     * Returns the step width of the scale.
     *
     * The step width is the pixel distance between adjacent values in the domain.
     *
     * @returns {number}
     */
    Category.prototype.stepWidth = function () {
        // todo consider replacing this with _d3Scale.step()
        return this._rescaleBand(this._d3Scale.bandwidth() * (1 + this.innerPadding()));
    };
    Category.prototype.ticks = function () {
        return this.domain();
    };
    Category.prototype.innerPadding = function (innerPadding) {
        if (innerPadding == null) {
            return this._innerPadding;
        }
        this._innerPadding = innerPadding;
        this.range(this.range());
        this._dispatchUpdate();
        return this;
    };
    Category.prototype.outerPadding = function (outerPadding) {
        if (outerPadding == null) {
            return this._outerPadding;
        }
        this._outerPadding = outerPadding;
        this.range(this.range());
        this._dispatchUpdate();
        return this;
    };
    Category.prototype.scale = function (value) {
        // Determine the middle of the range band for the value
        var untransformed = this._d3Scale(value) + this._d3Scale.bandwidth() / 2;
        // Convert to screen space
        return this._d3TransformationScale(untransformed);
    };
    Category.prototype.zoom = function (magnifyAmount, centerValue) {
        var _this = this;
        var magnifyTransform = function (rangeValue) {
            return _this._d3TransformationScale.invert((0, panZoomConstraints_1.zoomOut)(rangeValue, magnifyAmount, centerValue));
        };
        this._d3TransformationScale.domain(this._d3TransformationScale.range().map(magnifyTransform));
        this._dispatchUpdate();
    };
    Category.prototype.pan = function (translateAmount) {
        var _this = this;
        var translateTransform = function (rangeValue) {
            return _this._d3TransformationScale.invert(rangeValue + translateAmount);
        };
        this._d3TransformationScale.domain(this._d3TransformationScale.range().map(translateTransform));
        this._dispatchUpdate();
    };
    Category.prototype.scaleTransformation = function (value) {
        return this._d3TransformationScale(value);
    };
    Category.prototype.invertedTransformation = function (value) {
        return this._d3TransformationScale.invert(value);
    };
    Category.prototype.getTransformationExtent = function () {
        return TRANSFORMATION_SPACE;
    };
    Category.prototype.getTransformationDomain = function () {
        return this._d3TransformationScale.domain();
    };
    Category.prototype.setTransformationDomain = function (domain) {
        this._d3TransformationScale.domain(domain);
        this._dispatchUpdate();
    };
    Category.prototype._getDomain = function () {
        return this._backingScaleDomain();
    };
    Category.prototype._backingScaleDomain = function (values) {
        if (values == null) {
            return this._d3Scale.domain();
        }
        else {
            this._d3Scale.domain(values);
            this._setBands();
            return this;
        }
    };
    Category.prototype._getRange = function () {
        return this._range;
    };
    Category.prototype._setRange = function (values) {
        this._range = values;
        this._d3TransformationScale.range(values);
        this._setBands();
    };
    /**
     * Converts a width or height in *Transformation Space* into *Screen Space*.
     */
    Category.prototype._rescaleBand = function (band) {
        return Math.abs(this._d3TransformationScale(band) - this._d3TransformationScale(0));
    };
    return Category;
}(scale_1.Scale));
exports.Category = Category;

},{"../interactions/panZoomConstraints":581,"../utils":624,"./scale":613,"d3":414,"tslib":635}],606:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Color = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Utils = require("../utils");
var scale_1 = require("./scale");
/**
 * Workaround for bad d3 behavior.
 *
 * d3's color scales, which are oridinal scales, have side-effects when invoked.
 * When you call the `scale(value)` as a function, it will implicitly add new
 * values to the domain.
 *
 * These side-effects cause us to rely on looking up the current scale state
 * with the `.domain()` and `.range()` methods. However, these methods have poor
 * performance implications since they will always slice their internal values
 * before returning. Inside the inner render loop of color scatter plot points,
 * these slices add up.
 */
var ImplicitSeriesTracker = /** @class */ (function () {
    function ImplicitSeriesTracker() {
        this.count = 0;
        this.tracker = {};
    }
    ImplicitSeriesTracker.prototype.getIndex = function (value) {
        if (this.tracker[value] != null) {
            return this.tracker[value];
        }
        else {
            var idx = this.count;
            this.tracker[value] = idx;
            this.count += 1;
            return idx;
        }
    };
    ImplicitSeriesTracker.prototype.clear = function () {
        this.count = 0;
        this.tracker = {};
    };
    return ImplicitSeriesTracker;
}());
var Color = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Color, _super);
    /**
     * A Color Scale maps string values to color hex values expressed as a string.
     *
     * @constructor
     * @param {string} [scaleType] One of "Category10"/"Category20"/"Category20b"/"Category20c".
     *   (see https://github.com/mbostock/d3/wiki/Ordinal-Scales#categorical-colors)
     *   If not supplied, reads the colors defined using CSS -- see plottable.css.
     */
    function Color(scaleType) {
        var _this = _super.call(this) || this;
        // Cache the number of range value to avoid calling `scale.range().length`
        _this._rangeLength = 1;
        _this._tracker = new ImplicitSeriesTracker();
        var scale;
        switch (scaleType) {
            case null:
            case undefined:
                if (Color._plottableColorCache == null) {
                    Color._plottableColorCache = Color._getPlottableColors();
                }
                scale = d3.scaleOrdinal().range(Color._plottableColorCache);
                break;
            case "Category10":
            case "category10":
            case "10":
                scale = d3.scaleOrdinal(d3.schemeCategory10);
                break;
            case "Category20":
            case "category20":
            case "20":
                scale = d3.scaleOrdinal(d3.schemeCategory20);
                break;
            case "Category20b":
            case "category20b":
            case "20b":
                scale = d3.scaleOrdinal(d3.schemeCategory20b);
                break;
            case "Category20c":
            case "category20c":
            case "20c":
                scale = d3.scaleOrdinal(d3.schemeCategory20c);
                break;
            default:
                throw new Error("Unsupported ColorScale type");
        }
        _this._d3Scale = scale;
        _this._rangeLength = _this._d3Scale.range().length;
        return _this;
    }
    Color.prototype.extentOfValues = function (values) {
        return Utils.Array.uniq(values);
    };
    // Duplicated from OrdinalScale._getExtent - should be removed in #388
    Color.prototype._getExtent = function () {
        return Utils.Array.uniq(this._getAllIncludedValues());
    };
    Color.invalidateColorCache = function () {
        Color._plottableColorCache = null;
    };
    Color._getPlottableColors = function () {
        var plottableDefaultColors = [];
        var colorTester = d3.select("body").append("plottable-color-tester");
        var defaultColorHex = Utils.Color.colorTest(colorTester, "");
        var i = 0;
        var colorHex = Utils.Color.colorTest(colorTester, "plottable-colors-0");
        while (colorHex != null && i < this._MAXIMUM_COLORS_FROM_CSS) {
            if (colorHex === defaultColorHex && colorHex === plottableDefaultColors[plottableDefaultColors.length - 1]) {
                break;
            }
            plottableDefaultColors.push(colorHex);
            i++;
            colorHex = Utils.Color.colorTest(colorTester, "plottable-colors-" + i);
        }
        colorTester.remove();
        return plottableDefaultColors;
    };
    /**
     * Returns the color-string corresponding to a given string.
     *
     * If there are not enough colors in the range(), a lightened version of an
     * existing color will be used.
     *
     * @param {string} value
     * @returns {string}
     */
    Color.prototype.scale = function (value) {
        var color = this._d3Scale(value);
        var index = this._tracker.getIndex(value);
        var numLooped = Math.floor(index / this._rangeLength);
        if (numLooped === 0) {
            return color;
        }
        var modifyFactor = Math.log(numLooped * Color._LOOP_LIGHTEN_FACTOR + 1);
        return Utils.Color.lightenColor(color, modifyFactor);
    };
    Color.prototype._getDomain = function () {
        return this._backingScaleDomain();
    };
    Color.prototype._backingScaleDomain = function (values) {
        if (values == null) {
            return this._d3Scale.domain();
        }
        else {
            this._d3Scale.domain(values);
            this._tracker.clear();
            return this;
        }
    };
    Color.prototype._getRange = function () {
        return this._d3Scale.range();
    };
    Color.prototype._setRange = function (values) {
        this._d3Scale.range(values);
        this._rangeLength = values.length;
    };
    Color._LOOP_LIGHTEN_FACTOR = 1.6;
    // The maximum number of colors we are getting from CSS stylesheets
    Color._MAXIMUM_COLORS_FROM_CSS = 256;
    return Color;
}(scale_1.Scale));
exports.Color = Color;

},{"../utils":624,"./scale":613,"d3":414,"tslib":635}],607:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTransformable = exports.TickGenerators = void 0;
var tslib_1 = require("tslib");
var TickGenerators = require("./tickGenerators");
exports.TickGenerators = TickGenerators;
(0, tslib_1.__exportStar)(require("./categoryScale"), exports);
(0, tslib_1.__exportStar)(require("./colorScale"), exports);
(0, tslib_1.__exportStar)(require("./interpolatedColorScale"), exports);
(0, tslib_1.__exportStar)(require("./linearScale"), exports);
(0, tslib_1.__exportStar)(require("./logScale"), exports);
(0, tslib_1.__exportStar)(require("./modifiedLogScale"), exports);
(0, tslib_1.__exportStar)(require("./timeScale"), exports);
// ---------------------------------------------------------
var categoryScale_1 = require("./categoryScale");
var quantitativeScale_1 = require("./quantitativeScale");
/**
 * Type guarded function to check if the scale implements the
 * `TransformableScale` interface. Unfortunately, there is no way to do
 * runtime interface typechecking, so we have to explicitly list all classes
 * that implement the interface.
 */
function isTransformable(scale) {
    return (scale instanceof quantitativeScale_1.QuantitativeScale ||
        scale instanceof categoryScale_1.Category);
}
exports.isTransformable = isTransformable;

},{"./categoryScale":605,"./colorScale":606,"./interpolatedColorScale":608,"./linearScale":609,"./logScale":610,"./modifiedLogScale":611,"./quantitativeScale":612,"./tickGenerators":614,"./timeScale":615,"tslib":635}],608:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterpolatedColor = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Utils = require("../utils");
var scale_1 = require("./scale");
var InterpolatedColor = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(InterpolatedColor, _super);
    /**
     * An InterpolatedColor Scale maps numbers to color hex values, expressed as strings.
     *
     * @param {string} [scaleType="linear"] One of "linear"/"log"/"sqrt"/"pow".
     */
    function InterpolatedColor(scaleType) {
        if (scaleType === void 0) { scaleType = "linear"; }
        var _this = _super.call(this) || this;
        switch (scaleType) {
            case "linear":
                _this._colorScale = d3.scaleLinear();
                break;
            case "log":
                _this._colorScale = d3.scaleLog();
                break;
            case "sqrt":
                _this._colorScale = d3.scaleSqrt();
                break;
            case "pow":
                _this._colorScale = d3.scalePow();
                break;
        }
        if (_this._colorScale == null) {
            throw new Error("unknown QuantitativeScale scale type " + scaleType);
        }
        _this.range(InterpolatedColor.REDS);
        return _this;
    }
    InterpolatedColor.prototype.extentOfValues = function (values) {
        var extent = d3.extent(values);
        if (extent[0] == null || extent[1] == null) {
            return [];
        }
        else {
            return extent;
        }
    };
    /**
     * Generates the converted QuantitativeScale.
     */
    InterpolatedColor.prototype._d3InterpolatedScale = function () {
        return this._colorScale.range([0, 1]).interpolate(this._interpolateColors());
    };
    /**
     * Generates the d3 interpolator for colors.
     */
    InterpolatedColor.prototype._interpolateColors = function () {
        var colors = this._colorRange;
        if (colors.length < 2) {
            throw new Error("Color scale arrays must have at least two elements.");
        }
        return function (a, b) {
            return function (t) {
                // Clamp t parameter to [0,1]
                t = Math.max(0, Math.min(1, t));
                // Determine indices for colors
                var tScaled = t * (colors.length - 1);
                var i0 = Math.floor(tScaled);
                var i1 = Math.ceil(tScaled);
                var frac = (tScaled - i0);
                // Interpolate in the L*a*b color space
                return d3.interpolateLab(colors[i0], colors[i1])(frac);
            };
        };
    };
    InterpolatedColor.prototype._resetScale = function () {
        this._d3Scale = this._d3InterpolatedScale();
        this.autoDomainIfAutomaticMode();
        this._dispatchUpdate();
    };
    InterpolatedColor.prototype.autoDomain = function () {
        // InterpolatedColorScales do not pad
        var includedValues = this._getAllIncludedValues();
        if (includedValues.length > 0) {
            this._setDomain([Utils.Math.min(includedValues, 0), Utils.Math.max(includedValues, 0)]);
        }
        return this;
    };
    InterpolatedColor.prototype.scale = function (value) {
        return this._d3Scale(value);
    };
    InterpolatedColor.prototype._getDomain = function () {
        return this._backingScaleDomain();
    };
    InterpolatedColor.prototype._backingScaleDomain = function (values) {
        if (values == null) {
            return this._d3Scale.domain();
        }
        else {
            this._d3Scale.domain(values);
            return this;
        }
    };
    InterpolatedColor.prototype._getRange = function () {
        return this._colorRange;
    };
    InterpolatedColor.prototype._setRange = function (range) {
        this._colorRange = range;
        this._resetScale();
    };
    InterpolatedColor.REDS = [
        "#FFFFFF",
        "#FFF6E1",
        "#FEF4C0",
        "#FED976",
        "#FEB24C",
        "#FD8D3C",
        "#FC4E2A",
        "#E31A1C",
        "#B10026", // red
    ];
    InterpolatedColor.BLUES = [
        "#FFFFFF",
        "#CCFFFF",
        "#A5FFFD",
        "#85F7FB",
        "#6ED3EF",
        "#55A7E0",
        "#417FD0",
        "#2545D3",
        "#0B02E1", // blue
    ];
    InterpolatedColor.POSNEG = [
        "#0B02E1",
        "#2545D3",
        "#417FD0",
        "#55A7E0",
        "#6ED3EF",
        "#85F7FB",
        "#A5FFFD",
        "#CCFFFF",
        "#FFFFFF",
        "#FFF6E1",
        "#FEF4C0",
        "#FED976",
        "#FEB24C",
        "#FD8D3C",
        "#FC4E2A",
        "#E31A1C",
        "#B10026", // red
    ];
    return InterpolatedColor;
}(scale_1.Scale));
exports.InterpolatedColor = InterpolatedColor;

},{"../utils":624,"./scale":613,"d3":414,"tslib":635}],609:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Linear = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var quantitativeScale_1 = require("./quantitativeScale");
var Linear = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Linear, _super);
    /**
     * @constructor
     */
    function Linear() {
        var _this = _super.call(this) || this;
        _this._d3Scale = d3.scaleLinear();
        return _this;
    }
    Linear.prototype._defaultExtent = function () {
        return [0, 1];
    };
    Linear.prototype._expandSingleValueDomain = function (singleValueDomain) {
        if (singleValueDomain[0] === singleValueDomain[1]) {
            return [singleValueDomain[0] - 1, singleValueDomain[1] + 1];
        }
        return singleValueDomain;
    };
    Linear.prototype.scale = function (value) {
        return this._d3Scale(value);
    };
    Linear.prototype.scaleTransformation = function (value) {
        return this.scale(value);
    };
    Linear.prototype.invertedTransformation = function (value) {
        return this.invert(value);
    };
    Linear.prototype.getTransformationExtent = function () {
        return this._getUnboundedExtent(true);
    };
    Linear.prototype.getTransformationDomain = function () {
        return this.domain();
    };
    Linear.prototype.setTransformationDomain = function (domain) {
        this.domain(domain);
    };
    Linear.prototype._getDomain = function () {
        return this._backingScaleDomain();
    };
    Linear.prototype._backingScaleDomain = function (values) {
        if (values == null) {
            return this._d3Scale.domain();
        }
        else {
            this._d3Scale.domain(values);
            return this;
        }
    };
    Linear.prototype._getRange = function () {
        return this._d3Scale.range();
    };
    Linear.prototype._setRange = function (values) {
        this._d3Scale.range(values);
    };
    Linear.prototype.invert = function (value) {
        return this._d3Scale.invert(value);
    };
    Linear.prototype.defaultTicks = function () {
        return this._d3Scale.ticks(Linear._DEFAULT_NUM_TICKS);
    };
    Linear.prototype._niceDomain = function (domain, count) {
        return this._d3Scale.copy().domain(domain).nice(count).domain();
    };
    return Linear;
}(quantitativeScale_1.QuantitativeScale));
exports.Linear = Linear;

},{"./quantitativeScale":612,"d3":414,"tslib":635}],610:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Log = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var quantitativeScale_1 = require("./quantitativeScale");
var Log = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Log, _super);
    /**
     * @constructor
     */
    function Log(base) {
        if (base === void 0) { base = 10; }
        var _this = _super.call(this) || this;
        _this._d3Scale = d3.scaleLog().base(base);
        _this._setDomain(_this._defaultExtent());
        return _this;
    }
    Log.prototype._defaultExtent = function () {
        return [1, this._d3Scale.base()];
    };
    Log.prototype._expandSingleValueDomain = function (singleValueDomain) {
        if (singleValueDomain[0] === singleValueDomain[1]) {
            return [singleValueDomain[0] / this._d3Scale.base(),
                singleValueDomain[1] * this._d3Scale.base()];
        }
        return singleValueDomain;
    };
    Log.prototype.scale = function (value) {
        return this._d3Scale(value);
    };
    Log.prototype.scaleTransformation = function (value) {
        return this.scale(value);
    };
    Log.prototype.invertedTransformation = function (value) {
        return this.invert(value);
    };
    Log.prototype.getTransformationExtent = function () {
        return this._getUnboundedExtent(true);
    };
    Log.prototype.getTransformationDomain = function () {
        return this.domain();
    };
    Log.prototype.setTransformationDomain = function (domain) {
        this.domain(domain);
    };
    Log.prototype._getDomain = function () {
        return this._backingScaleDomain();
    };
    Log.prototype._backingScaleDomain = function (values) {
        if (values == null) {
            return this._d3Scale.domain();
        }
        else {
            this._d3Scale.domain(values);
            return this;
        }
    };
    Log.prototype._getRange = function () {
        return this._d3Scale.range();
    };
    Log.prototype._setRange = function (values) {
        this._d3Scale.range(values);
    };
    Log.prototype.invert = function (value) {
        return this._d3Scale.invert(value);
    };
    Log.prototype.defaultTicks = function () {
        return this._d3Scale.ticks(Log._DEFAULT_NUM_TICKS);
    };
    Log.prototype._niceDomain = function (domain, count) {
        return this._d3Scale.copy().domain(domain).nice().domain();
    };
    return Log;
}(quantitativeScale_1.QuantitativeScale));
exports.Log = Log;

},{"./quantitativeScale":612,"d3":414,"tslib":635}],611:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModifiedLog = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var Utils = require("../utils");
var Scales = require("./");
var quantitativeScale_1 = require("./quantitativeScale");
var ModifiedLog = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ModifiedLog, _super);
    /**
     * A ModifiedLog Scale acts as a regular log scale for large numbers.
     * As it approaches 0, it gradually becomes linear.
     * Consequently, a ModifiedLog Scale can process 0 and negative numbers.
     *
     * For x >= base, scale(x) = log(x).
     *
     * For 0 < x < base, scale(x) will become more and more
     * linear as it approaches 0.
     *
     * At x == 0, scale(x) == 0.
     *
     * For negative values, scale(-x) = -scale(x).
     *
     * The range and domain for the scale should also be set, using the
     * range() and domain() accessors, respectively.
     *
     * For `range`, provide a two-element array giving the minimum and
     * maximum of values produced when scaling.
     *
     * For `domain` provide a two-element array giving the minimum and
     * maximum of the values that will be scaled.
     *
     * @constructor
     * @param {number} [base=10]
     *        The base of the log. Must be > 1.
     *
     */
    function ModifiedLog(base) {
        if (base === void 0) { base = 10; }
        var _this = _super.call(this) || this;
        _this._logTickGenerator = function (scale) {
            // Say your domain is [-100, 100] and your pivot is 10.
            // then we're going to draw negative log ticks from -100 to -10,
            // linear ticks from -10 to 10, and positive log ticks from 10 to 100.
            var middle = function (x, y, z) { return [x, y, z].sort(function (a, b) { return a - b; })[1]; };
            var min = Utils.Math.min(_this._untransformedDomain, 0);
            var max = Utils.Math.max(_this._untransformedDomain, 0);
            var negativeLower = min;
            var negativeUpper = middle(min, max, -_this._pivot);
            var positiveLower = middle(min, max, _this._pivot);
            var positiveUpper = max;
            var negativeLogTicks = _this._logTicks(-negativeUpper, -negativeLower).map(function (x) { return -x; }).reverse();
            var positiveLogTicks = _this._logTicks(positiveLower, positiveUpper);
            var linearMin = Math.max(min, -_this._pivot);
            var linearMax = Math.min(max, _this._pivot);
            var linearTicks = d3.scaleLinear().domain([linearMin, linearMax]).ticks(_this._howManyTicks(linearMin, linearMax));
            var ticks = negativeLogTicks.concat(linearTicks).concat(positiveLogTicks);
            // If you only have 1 tick, you can't tell how big the scale is.
            if (ticks.length <= 1) {
                ticks = d3.scaleLinear().domain([min, max]).ticks(Scales.ModifiedLog._DEFAULT_NUM_TICKS);
            }
            return ticks;
        };
        _this._d3Scale = d3.scaleLinear();
        _this._base = base;
        _this._pivot = _this._base;
        _this._setDomain(_this._defaultExtent());
        _this.tickGenerator(_this._logTickGenerator);
        if (base <= 1) {
            throw new Error("ModifiedLogScale: The base must be > 1");
        }
        return _this;
    }
    /**
     * Returns an adjusted log10 value for graphing purposes.  The first
     * adjustment is that negative values are changed to positive during
     * the calculations, and then the answer is negated at the end.  The
     * second is that, for values less than 10, an increasingly large
     * (0 to 1) scaling factor is added such that at 0 the value is
     * adjusted to 1, resulting in a returned result of 0.
     */
    ModifiedLog.prototype._adjustedLog = function (x) {
        var negationFactor = x < 0 ? -1 : 1;
        x *= negationFactor;
        if (x < this._pivot) {
            x += (this._pivot - x) / this._pivot;
        }
        x = Math.log(x) / Math.log(this._base);
        x *= negationFactor;
        return x;
    };
    ModifiedLog.prototype._invertedAdjustedLog = function (x) {
        var negationFactor = x < 0 ? -1 : 1;
        x *= negationFactor;
        x = Math.pow(this._base, x);
        if (x < this._pivot) {
            x = (this._pivot * (x - 1)) / (this._pivot - 1);
        }
        x *= negationFactor;
        return x;
    };
    ModifiedLog.prototype.scale = function (x) {
        return this._d3Scale(this._adjustedLog(x));
    };
    ModifiedLog.prototype.invert = function (x) {
        return this._invertedAdjustedLog(this._d3Scale.invert(x));
    };
    ModifiedLog.prototype.scaleTransformation = function (value) {
        return this.scale(value);
    };
    ModifiedLog.prototype.invertedTransformation = function (value) {
        return this.invert(value);
    };
    ModifiedLog.prototype.getTransformationExtent = function () {
        return this._getUnboundedExtent(true);
    };
    ModifiedLog.prototype.getTransformationDomain = function () {
        return this.domain();
    };
    ModifiedLog.prototype.setTransformationDomain = function (domain) {
        this.domain(domain);
    };
    ModifiedLog.prototype._getDomain = function () {
        return this._untransformedDomain;
    };
    ModifiedLog.prototype._setDomain = function (values) {
        this._untransformedDomain = values;
        var transformedDomain = [this._adjustedLog(values[0]), this._adjustedLog(values[1])];
        _super.prototype._setDomain.call(this, transformedDomain);
    };
    ModifiedLog.prototype._backingScaleDomain = function (values) {
        if (values == null) {
            return this._d3Scale.domain();
        }
        else {
            this._d3Scale.domain(values);
            return this;
        }
    };
    /**
     * Return an appropriate number of ticks from lower to upper.
     *
     * This will first try to fit as many powers of this.base as it can from
     * lower to upper.
     *
     * If it still has ticks after that, it will generate ticks in "clusters",
     * e.g. [20, 30, ... 90, 100] would be a cluster, [200, 300, ... 900, 1000]
     * would be another cluster.
     *
     * This function will generate clusters as large as it can while not
     * drastically exceeding its number of ticks.
     */
    ModifiedLog.prototype._logTicks = function (lower, upper) {
        var _this = this;
        var nTicks = this._howManyTicks(lower, upper);
        if (nTicks === 0) {
            return [];
        }
        var startLogged = Math.floor(Math.log(lower) / Math.log(this._base));
        var endLogged = Math.ceil(Math.log(upper) / Math.log(this._base));
        var bases = d3.range(endLogged, startLogged, -Math.ceil((endLogged - startLogged) / nTicks));
        var multiples = d3.range(this._base, 1, -(this._base - 1)).map(Math.floor);
        var uniqMultiples = Utils.Array.uniq(multiples);
        var clusters = bases.map(function (b) { return uniqMultiples.map(function (x) { return Math.pow(_this._base, b - 1) * x; }); });
        var flattened = Utils.Array.flatten(clusters);
        var filtered = flattened.filter(function (x) { return lower <= x && x <= upper; });
        var sorted = filtered.sort(function (x, y) { return x - y; });
        return sorted;
    };
    /**
     * How many ticks does the range [lower, upper] deserve?
     *
     * e.g. if your domain was [10, 1000] and I asked _howManyTicks(10, 100),
     * I would get 1/2 of the ticks. The range 10, 100 takes up 1/2 of the
     * distance when plotted.
     */
    ModifiedLog.prototype._howManyTicks = function (lower, upper) {
        var adjustedMin = this._adjustedLog(Utils.Math.min(this._untransformedDomain, 0));
        var adjustedMax = this._adjustedLog(Utils.Math.max(this._untransformedDomain, 0));
        var adjustedLower = this._adjustedLog(lower);
        var adjustedUpper = this._adjustedLog(upper);
        var proportion = (adjustedUpper - adjustedLower) / (adjustedMax - adjustedMin);
        var ticks = Math.ceil(proportion * Scales.ModifiedLog._DEFAULT_NUM_TICKS);
        return ticks;
    };
    ModifiedLog.prototype._niceDomain = function (domain, count) {
        return domain;
    };
    ModifiedLog.prototype._defaultExtent = function () {
        return [0, this._base];
    };
    ModifiedLog.prototype._expandSingleValueDomain = function (singleValueDomain) {
        if (singleValueDomain[0] === singleValueDomain[1]) {
            var singleValue = singleValueDomain[0];
            if (singleValue > 0) {
                return [singleValue / this._base, singleValue * this._base];
            }
            else if (singleValue === 0) {
                return [-this._base, this._base];
            }
            else {
                return [singleValue * this._base, singleValue / this._base];
            }
        }
        return singleValueDomain;
    };
    ModifiedLog.prototype._getRange = function () {
        return this._d3Scale.range();
    };
    ModifiedLog.prototype._setRange = function (values) {
        this._d3Scale.range(values);
    };
    ModifiedLog.prototype.defaultTicks = function () {
        return this._d3Scale.ticks(Scales.ModifiedLog._DEFAULT_NUM_TICKS);
    };
    return ModifiedLog;
}(quantitativeScale_1.QuantitativeScale));
exports.ModifiedLog = ModifiedLog;

},{"../utils":624,"./":607,"./quantitativeScale":612,"d3":414,"tslib":635}],612:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuantitativeScale = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var panZoomConstraints_1 = require("../interactions/panZoomConstraints");
var Utils = require("../utils");
var scale_1 = require("./scale");
var QuantitativeScale = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(QuantitativeScale, _super);
    /**
     * A QuantitativeScale is a Scale that maps number-like values to numbers.
     * It is invertible and continuous.
     *
     * @constructor
     */
    function QuantitativeScale() {
        var _this = _super.call(this) || this;
        _this._tickGenerator = function (scale) { return scale.defaultTicks(); };
        _this._padProportion = 0.05;
        _this._snappingDomainEnabled = true;
        _this._paddingExceptionsProviders = new Utils.Set();
        return _this;
    }
    QuantitativeScale.prototype.autoDomain = function () {
        this._domainMin = null;
        this._domainMax = null;
        _super.prototype.autoDomain.call(this);
        return this;
    };
    QuantitativeScale.prototype.autoDomainIfAutomaticMode = function () {
        if (this._domainMin != null && this._domainMax != null) {
            this._setDomain([this._domainMin, this._domainMax]);
            return;
        }
        var computedExtent = this._getExtent();
        if (this._domainMin != null) {
            var maxValue = computedExtent[1];
            if (this._domainMin >= maxValue) {
                maxValue = this._expandSingleValueDomain([this._domainMin, this._domainMin])[1];
            }
            this._setDomain([this._domainMin, maxValue]);
            return;
        }
        if (this._domainMax != null) {
            var minValue = computedExtent[0];
            if (this._domainMax <= minValue) {
                minValue = this._expandSingleValueDomain([this._domainMax, this._domainMax])[0];
            }
            this._setDomain([minValue, this._domainMax]);
            return;
        }
        _super.prototype.autoDomainIfAutomaticMode.call(this);
    };
    QuantitativeScale.prototype._getUnboundedExtent = function (ignoreAttachState) {
        if (ignoreAttachState === void 0) { ignoreAttachState = false; }
        var includedValues = this._getAllIncludedValues(ignoreAttachState);
        var extent = this._defaultExtent();
        if (includedValues.length !== 0) {
            var combinedExtent = [
                Utils.Math.min(includedValues, extent[0]),
                Utils.Math.max(includedValues, extent[1]),
            ];
            extent = this._padDomain(combinedExtent);
        }
        return extent;
    };
    QuantitativeScale.prototype._getExtent = function () {
        var extent = this._getUnboundedExtent();
        if (this._domainMin != null) {
            extent[0] = this._domainMin;
        }
        if (this._domainMax != null) {
            extent[1] = this._domainMax;
        }
        return extent;
    };
    /**
     * Adds a padding exception provider.
     * If one end of the domain is set to an excepted value as a result of autoDomain()-ing,
     * that end of the domain will not be padded.
     *
     * @param {Scales.PaddingExceptionProvider<D>} provider The provider function.
     * @returns {QuantitativeScale} The calling QuantitativeScale.
     */
    QuantitativeScale.prototype.addPaddingExceptionsProvider = function (provider) {
        this._paddingExceptionsProviders.add(provider);
        this.autoDomainIfAutomaticMode();
        return this;
    };
    /**
     * Removes the padding exception provider.
     *
     * @param {Scales.PaddingExceptionProvider<D>} provider The provider function.
     * @returns {QuantitativeScale} The calling QuantitativeScale.
     */
    QuantitativeScale.prototype.removePaddingExceptionsProvider = function (provider) {
        this._paddingExceptionsProviders.delete(provider);
        this.autoDomainIfAutomaticMode();
        return this;
    };
    QuantitativeScale.prototype.padProportion = function (padProportion) {
        if (padProportion == null) {
            return this._padProportion;
        }
        if (padProportion < 0) {
            throw new Error("padProportion must be non-negative");
        }
        this._padProportion = padProportion;
        this.autoDomainIfAutomaticMode();
        return this;
    };
    QuantitativeScale.prototype._padDomain = function (domain) {
        var _this = this;
        if (domain[0].valueOf() === domain[1].valueOf()) {
            return this._expandSingleValueDomain(domain);
        }
        if (this._padProportion === 0) {
            return domain;
        }
        var p = this._padProportion / 2;
        var min = domain[0];
        var max = domain[1];
        var minExistsInExceptions = false;
        var maxExistsInExceptions = false;
        this._paddingExceptionsProviders.forEach(function (provider) {
            var values = provider(_this);
            values.forEach(function (value) {
                if (value.valueOf() === min.valueOf()) {
                    minExistsInExceptions = true;
                }
                if (value.valueOf() === max.valueOf()) {
                    maxExistsInExceptions = true;
                }
            });
        });
        var originalDomain = this._backingScaleDomain();
        this._backingScaleDomain(domain);
        var newMin = minExistsInExceptions ? min : this.invert(this.scale(min) - (this.scale(max) - this.scale(min)) * p);
        var newMax = maxExistsInExceptions ? max : this.invert(this.scale(max) + (this.scale(max) - this.scale(min)) * p);
        this._backingScaleDomain(originalDomain);
        if (this._snappingDomainEnabled) {
            return this._niceDomain([newMin, newMax]);
        }
        return ([newMin, newMax]);
    };
    QuantitativeScale.prototype.snappingDomainEnabled = function (snappingDomainEnabled) {
        if (snappingDomainEnabled == null) {
            return this._snappingDomainEnabled;
        }
        this._snappingDomainEnabled = snappingDomainEnabled;
        this.autoDomainIfAutomaticMode();
        return this;
    };
    QuantitativeScale.prototype._expandSingleValueDomain = function (singleValueDomain) {
        return singleValueDomain;
    };
    /**
     * Computes the domain value corresponding to a supplied range value.
     *
     * @param {number} value: A value from the Scale's range.
     * @returns {D} The domain value corresponding to the supplied range value.
     */
    QuantitativeScale.prototype.invert = function (value) {
        throw new Error("Subclasses should override invert");
    };
    QuantitativeScale.prototype.domain = function (values) {
        if (values != null) {
            this._domainMin = values[0];
            this._domainMax = values[1];
        }
        return _super.prototype.domain.call(this, values);
    };
    QuantitativeScale.prototype.domainMin = function (domainMin) {
        if (domainMin == null) {
            return this.domain()[0];
        }
        this._domainMin = domainMin;
        this.autoDomainIfAutomaticMode();
        return this;
    };
    QuantitativeScale.prototype.domainMax = function (domainMax) {
        if (domainMax == null) {
            return this.domain()[1];
        }
        this._domainMax = domainMax;
        this.autoDomainIfAutomaticMode();
        return this;
    };
    QuantitativeScale.prototype.extentOfValues = function (values) {
        // HACKHACK: TS1.4 doesn't consider numbers to be Number-like (valueOf() returning number), so D can't be typed correctly
        var extent = d3.extent(values.filter(function (value) { return Utils.Math.isValidNumber(+value); }));
        if (extent[0] == null || extent[1] == null) {
            return [];
        }
        else {
            return extent;
        }
    };
    QuantitativeScale.prototype.zoom = function (magnifyAmount, centerValue) {
        var _this = this;
        var magnifyTransform = function (rangeValue) { return _this.invert((0, panZoomConstraints_1.zoomOut)(rangeValue, magnifyAmount, centerValue)); };
        this.domain(this.range().map(magnifyTransform));
    };
    QuantitativeScale.prototype.pan = function (translateAmount) {
        var _this = this;
        var translateTransform = function (rangeValue) { return _this.invert(rangeValue + translateAmount); };
        this.domain(this.range().map(translateTransform));
    };
    QuantitativeScale.prototype.scaleTransformation = function (value) {
        throw new Error("Subclasses should override scaleTransformation");
    };
    QuantitativeScale.prototype.invertedTransformation = function (value) {
        throw new Error("Subclasses should override invertedTransformation");
    };
    QuantitativeScale.prototype.getTransformationExtent = function () {
        throw new Error("Subclasses should override getTransformationExtent");
    };
    QuantitativeScale.prototype.getTransformationDomain = function () {
        throw new Error("Subclasses should override getTransformationDomain");
    };
    QuantitativeScale.prototype.setTransformationDomain = function (domain) {
        throw new Error("Subclasses should override setTransformationDomain");
    };
    QuantitativeScale.prototype._setDomain = function (values) {
        var isNaNOrInfinity = function (x) { return Utils.Math.isNaN(x) || x === Infinity || x === -Infinity; };
        if (isNaNOrInfinity(values[0]) || isNaNOrInfinity(values[1])) {
            Utils.Window.warn("Warning: QuantitativeScales cannot take NaN or Infinity as a domain value. Ignoring.");
            return;
        }
        _super.prototype._setDomain.call(this, values);
    };
    /**
     * Gets the array of tick values generated by the default algorithm.
     */
    QuantitativeScale.prototype.defaultTicks = function () {
        throw new Error("Subclasses should override _getDefaultTicks");
    };
    /**
     * Gets an array of tick values spanning the domain.
     *
     * @returns {D[]}
     */
    QuantitativeScale.prototype.ticks = function () {
        return this._tickGenerator(this);
    };
    /**
     * Given a domain, expands its domain onto "nice" values, e.g. whole
     * numbers.
     */
    QuantitativeScale.prototype._niceDomain = function (domain, count) {
        throw new Error("Subclasses should override _niceDomain");
    };
    QuantitativeScale.prototype._defaultExtent = function () {
        throw new Error("Subclasses should override _defaultExtent");
    };
    QuantitativeScale.prototype.tickGenerator = function (generator) {
        if (generator == null) {
            return this._tickGenerator;
        }
        else {
            this._tickGenerator = generator;
            return this;
        }
    };
    QuantitativeScale._DEFAULT_NUM_TICKS = 10;
    return QuantitativeScale;
}(scale_1.Scale));
exports.QuantitativeScale = QuantitativeScale;

},{"../interactions/panZoomConstraints":581,"../utils":624,"./scale":613,"d3":414,"tslib":635}],613:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scale = void 0;
var Utils = require("../utils");
var Scale = /** @class */ (function () {
    /**
     * A Scale is a function (in the mathematical sense) that maps values from a domain to a range.
     *
     * @constructor
     */
    function Scale() {
        this._autoDomainAutomatically = true;
        this._domainModificationInProgress = false;
        this._updateId = 0;
        this._callbacks = new Utils.CallbackSet();
        this._includedValuesProviders = new Utils.Set();
    }
    /**
     * Given an array of potential domain values, computes the extent of those values.
     *
     * @param {D[]} values
     * @returns {D[]} The extent of the input values.
     */
    Scale.prototype.extentOfValues = function (values) {
        return []; // this should be overwritten
    };
    Scale.prototype._getAllIncludedValues = function (ignoreAttachState) {
        var _this = this;
        if (ignoreAttachState === void 0) { ignoreAttachState = false; }
        var providerArray = [];
        this._includedValuesProviders.forEach(function (provider) {
            var extents = provider(_this, ignoreAttachState);
            providerArray = providerArray.concat(extents);
        });
        return providerArray;
    };
    Scale.prototype._getExtent = function () {
        return []; // this should be overwritten
    };
    /**
     * Adds a callback to be called when the Scale updates.
     *
     * @param {ScaleCallback} callback.
     * @returns {Scale} The calling Scale.
     */
    Scale.prototype.onUpdate = function (callback) {
        this._callbacks.add(callback);
        return this;
    };
    /**
     * Removes a callback that would be called when the Scale updates.
     *
     * @param {ScaleCallback} callback.
     * @returns {Scale} The calling Scale.
     */
    Scale.prototype.offUpdate = function (callback) {
        this._callbacks.delete(callback);
        return this;
    };
    Scale.prototype._dispatchUpdate = function () {
        this._updateId++;
        this._callbacks.callCallbacks(this);
    };
    /**
     * Sets the Scale's domain so that it spans the Extents of all its ExtentsProviders.
     *
     * @returns {Scale} The calling Scale.
     */
    Scale.prototype.autoDomain = function () {
        this._autoDomainAutomatically = true;
        this._setDomain(this._getExtent());
        return this;
    };
    /**
     * Triggers `.autoDomain()` if the domain is not explicitly set.
     */
    Scale.prototype.autoDomainIfAutomaticMode = function () {
        if (this._autoDomainAutomatically) {
            this.autoDomain();
        }
    };
    /**
     * Computes the range value corresponding to a given domain value.
     *
     * @param {D} value
     * @returns {R} The range value corresponding to the supplied domain value.
     */
    Scale.prototype.scale = function (value) {
        throw new Error("Subclasses should override scale");
    };
    /**
     * Gets an array of tick values spanning the domain.
     *
     * @returns {D[]}
     */
    Scale.prototype.ticks = function () {
        return this.domain();
    };
    Scale.prototype.domain = function (values) {
        if (values == null) {
            return this._getDomain();
        }
        else {
            this._autoDomainAutomatically = false;
            this._setDomain(values);
            return this;
        }
    };
    Scale.prototype._getDomain = function () {
        throw new Error("Subclasses should override _getDomain");
    };
    Scale.prototype._setDomain = function (values) {
        if (!this._domainModificationInProgress) {
            this._domainModificationInProgress = true;
            this._backingScaleDomain(values);
            this._dispatchUpdate();
            this._domainModificationInProgress = false;
        }
    };
    Scale.prototype._backingScaleDomain = function (values) {
        throw new Error("Subclasses should override _backingDomain");
    };
    Scale.prototype.range = function (values) {
        if (values == null) {
            return this._getRange();
        }
        else {
            this._setRange(values);
            return this;
        }
    };
    Scale.prototype._getRange = function () {
        throw new Error("Subclasses should override _getRange");
    };
    Scale.prototype._setRange = function (values) {
        throw new Error("Subclasses should override _setRange");
    };
    /**
     * Adds an IncludedValuesProvider to the Scale.
     *
     * @param {Scales.IncludedValuesProvider} provider
     * @returns {Scale} The calling Scale.
     */
    Scale.prototype.addIncludedValuesProvider = function (provider) {
        this._includedValuesProviders.add(provider);
        this.autoDomainIfAutomaticMode();
        return this;
    };
    /**
     * Removes the IncludedValuesProvider from the Scale.
     *
     * @param {Scales.IncludedValuesProvider} provider
     * @returns {Scale} The calling Scale.
     */
    Scale.prototype.removeIncludedValuesProvider = function (provider) {
        this._includedValuesProviders.delete(provider);
        this.autoDomainIfAutomaticMode();
        return this;
    };
    Scale.prototype.updateId = function () {
        return this._updateId;
    };
    return Scale;
}());
exports.Scale = Scale;

},{"../utils":624}],614:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.integerTickGenerator = exports.intervalTickGenerator = void 0;
var Utils = require("../utils");
/**
 * Creates a TickGenerator using the specified interval.
 *
 * Generates ticks at multiples of the interval while also including the domain boundaries.
 *
 * @param {number} interval
 * @returns {TickGenerator}
 */
function intervalTickGenerator(interval) {
    if (interval <= 0) {
        throw new Error("interval must be positive number");
    }
    return function (s) {
        var domain = s.domain();
        var low = Math.min(domain[0], domain[1]);
        var high = Math.max(domain[0], domain[1]);
        var firstTick = Math.ceil(low / interval) * interval;
        var numTicks = Math.floor((high - firstTick) / interval) + 1;
        var lowTicks = low % interval === 0 ? [] : [low];
        var middleTicks = Utils.Math.range(0, numTicks).map(function (t) { return firstTick + t * interval; });
        var highTicks = high % interval === 0 ? [] : [high];
        return lowTicks.concat(middleTicks).concat(highTicks);
    };
}
exports.intervalTickGenerator = intervalTickGenerator;
/**
 * Creates a TickGenerator returns only integer tick values.
 *
 * @returns {TickGenerator}
 */
function integerTickGenerator() {
    return function (s) {
        var defaultTicks = s.defaultTicks();
        return defaultTicks.filter(function (tick, i) { return (tick % 1 === 0) || (i === 0) || (i === defaultTicks.length - 1); });
    };
}
exports.integerTickGenerator = integerTickGenerator;

},{"../utils":624}],615:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Time = void 0;
var tslib_1 = require("tslib");
var d3 = require("d3");
var timeAxis_1 = require("../axes/timeAxis");
var quantitativeScale_1 = require("./quantitativeScale");
var Time = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Time, _super);
    /**
     * A Time Scale maps Date objects to numbers.
     *
     * @constructor
     */
    function Time() {
        var _this = _super.call(this) || this;
        _this._d3Scale = d3.scaleTime();
        _this.autoDomain();
        return _this;
    }
    /**
     * Returns an array of ticks values separated by the specified interval.
     *
     * @param {string} interval A string specifying the interval unit.
     * @param {number?} [step] The number of multiples of the interval between consecutive ticks.
     * @return {Date[]}
     */
    Time.prototype.tickInterval = function (interval, step, useUTC) {
        if (step === void 0) { step = 1; }
        if (useUTC === void 0) { useUTC = false; }
        // temporarily creats a time scale from our linear scale into a time scale so we can get access to its api
        var tempScale = d3.scaleTime();
        var d3Interval = Time.timeIntervalToD3Time(interval, useUTC).every(step);
        tempScale.domain(this.domain());
        tempScale.range(this.range());
        return tempScale.ticks(d3Interval);
    };
    Time.prototype._setDomain = function (values) {
        if (values[1] < values[0]) {
            throw new Error("Scale.Time domain values must be in chronological order");
        }
        return _super.prototype._setDomain.call(this, values);
    };
    Time.prototype._defaultExtent = function () {
        return [new Date("1970-01-01"), new Date("1970-01-02")];
    };
    Time.prototype._expandSingleValueDomain = function (singleValueDomain) {
        var startTime = singleValueDomain[0].getTime();
        var endTime = singleValueDomain[1].getTime();
        if (startTime === endTime) {
            var startDate = new Date(startTime);
            startDate.setDate(startDate.getDate() - 1);
            var endDate = new Date(endTime);
            endDate.setDate(endDate.getDate() + 1);
            return [startDate, endDate];
        }
        return singleValueDomain;
    };
    Time.prototype.scale = function (value) {
        return this._d3Scale(value);
    };
    Time.prototype.scaleTransformation = function (value) {
        return this.scale(new Date(value));
    };
    Time.prototype.invertedTransformation = function (value) {
        return this.invert(value).getTime();
    };
    Time.prototype.getTransformationExtent = function () {
        var extent = this._getUnboundedExtent(true);
        return [extent[0].valueOf(), extent[1].valueOf()];
    };
    Time.prototype.getTransformationDomain = function () {
        var dates = this.domain();
        return [dates[0].valueOf(), dates[1].valueOf()];
    };
    Time.prototype.setTransformationDomain = function (_a) {
        var domainMin = _a[0], domainMax = _a[1];
        this.domain([new Date(domainMin), new Date(domainMax)]);
    };
    Time.prototype._getDomain = function () {
        return this._backingScaleDomain();
    };
    Time.prototype._backingScaleDomain = function (values) {
        if (values == null) {
            return this._d3Scale.domain();
        }
        else {
            this._d3Scale.domain(values);
            return this;
        }
    };
    Time.prototype._getRange = function () {
        return this._d3Scale.range();
    };
    Time.prototype._setRange = function (values) {
        this._d3Scale.range(values);
    };
    Time.prototype.invert = function (value) {
        return this._d3Scale.invert(value);
    };
    Time.prototype.defaultTicks = function () {
        return this._d3Scale.ticks(Time._DEFAULT_NUM_TICKS);
    };
    Time.prototype._niceDomain = function (domain) {
        return this._d3Scale.copy().domain(domain).nice().domain();
    };
    /**
     * Transforms the Plottable TimeInterval string into a d3 time interval equivalent.
     * If the provided TimeInterval is incorrect, the default is d3.timeYear
     */
    Time.timeIntervalToD3Time = function (timeInterval, useUTC) {
        switch (timeInterval) {
            case timeAxis_1.TimeInterval.second:
                return useUTC ? d3.utcSecond : d3.timeSecond;
            case timeAxis_1.TimeInterval.minute:
                return useUTC ? d3.utcMinute : d3.timeMinute;
            case timeAxis_1.TimeInterval.hour:
                return useUTC ? d3.utcHour : d3.timeHour;
            case timeAxis_1.TimeInterval.day:
                return useUTC ? d3.utcDay : d3.timeDay;
            case timeAxis_1.TimeInterval.week:
                return useUTC ? d3.utcWeek : d3.timeWeek;
            case timeAxis_1.TimeInterval.month:
                return useUTC ? d3.utcMonth : d3.timeMonth;
            case timeAxis_1.TimeInterval.year:
                return useUTC ? d3.utcYear : d3.timeYear;
            default:
                throw Error("TimeInterval specified does not exist: " + timeInterval);
        }
    };
    return Time;
}(quantitativeScale_1.QuantitativeScale));
exports.Time = Time;

},{"../axes/timeAxis":531,"./quantitativeScale":612,"d3":414,"tslib":635}],616:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 *
 * @fileoverview manually add d3-selection-multi to d3 default bundle. Most of this code is
 * copied from d3-selection-multi@1.0.0.
 * See https://github.com/d3/d3-selection-multi/issues/11 for why we have to do this
 */
Object.defineProperty(exports, "__esModule", { value: true });
var d3 = require("d3");
var d3Selection = d3;
var d3Transition = d3;
function attrsFunction(selection, map) {
    return selection.each(function () {
        var x = map.apply(this, arguments), s = d3Selection.select(this);
        for (var name_1 in x)
            s.attr(name_1, x[name_1]);
    });
}
function attrsObject(selection, map) {
    for (var name_2 in map)
        selection.attr(name_2, map[name_2]);
    return selection;
}
function selection_attrs(map) {
    return (typeof map === "function" ? attrsFunction : attrsObject)(this, map);
}
function stylesFunction(selection, map, priority) {
    return selection.each(function () {
        var x = map.apply(this, arguments), s = d3Selection.select(this);
        for (var name_3 in x)
            s.style(name_3, x[name_3], priority);
    });
}
function stylesObject(selection, map, priority) {
    for (var name_4 in map)
        selection.style(name_4, map[name_4], priority);
    return selection;
}
function selection_styles(map, priority) {
    return (typeof map === "function" ? stylesFunction : stylesObject)(this, map, priority == null ? "" : priority);
}
function propertiesFunction(selection, map) {
    return selection.each(function () {
        var x = map.apply(this, arguments), s = d3Selection.select(this);
        for (var name_5 in x)
            s.property(name_5, x[name_5]);
    });
}
function propertiesObject(selection, map) {
    for (var name_6 in map)
        selection.property(name_6, map[name_6]);
    return selection;
}
function selection_properties(map) {
    return (typeof map === "function" ? propertiesFunction : propertiesObject)(this, map);
}
function attrsFunction$1(transition, map) {
    return transition.each(function () {
        var x = map.apply(this, arguments), t = d3Selection.select(this).transition(transition);
        for (var name_7 in x)
            t.attr(name_7, x[name_7]);
    });
}
function attrsObject$1(transition, map) {
    for (var name_8 in map)
        transition.attr(name_8, map[name_8]);
    return transition;
}
function transition_attrs(map) {
    return (typeof map === "function" ? attrsFunction$1 : attrsObject$1)(this, map);
}
function stylesFunction$1(transition, map, priority) {
    return transition.each(function () {
        var x = map.apply(this, arguments), t = d3Selection.select(this).transition(transition);
        for (var name_9 in x)
            t.style(name_9, x[name_9], priority);
    });
}
function stylesObject$1(transition, map, priority) {
    for (var name_10 in map)
        transition.style(name_10, map[name_10], priority);
    return transition;
}
function transition_styles(map, priority) {
    return (typeof map === "function" ? stylesFunction$1 : stylesObject$1)(this, map, priority == null ? "" : priority);
}
d3Selection.selection.prototype.attrs = selection_attrs;
d3Selection.selection.prototype.styles = selection_styles;
d3Selection.selection.prototype.properties = selection_properties;
d3Transition.transition.prototype.attrs = transition_attrs;
d3Transition.transition.prototype.styles = transition_styles;

},{"d3":414}],617:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFilledArray = exports.flatten = exports.uniq = exports.add = void 0;
var d3 = require("d3");
var nativeArray = window.Array;
/**
 * Takes two arrays of numbers and adds them together
 *
 * @param {number[]} aList The first array of numbers
 * @param {number[]} bList The second array of numbers
 * @return {number[]} An array of numbers where x[i] = aList[i] + bList[i]
 */
function add(aList, bList) {
    if (aList.length !== bList.length) {
        throw new Error("attempted to add arrays of unequal length");
    }
    return aList.map(function (_, i) { return aList[i] + bList[i]; });
}
exports.add = add;
/**
 * Take an array of values, and return the unique values.
 * Will work iff ∀ a, b, a.toString() == b.toString() => a == b; will break on Object inputs
 *
 * @param {T[]} values The values to find uniqueness for
 * @return {T[]} The unique values
 */
function uniq(arr) {
    var seen = d3.set();
    var result = [];
    arr.forEach(function (x) {
        if (!seen.has(String(x))) {
            seen.add(String(x));
            result.push(x);
        }
    });
    return result;
}
exports.uniq = uniq;
/**
 * @param {T[][]} a The 2D array that will have its elements joined together.
 * @return {T[]} Every array in a, concatenated together in the order they appear.
 */
function flatten(a) {
    return nativeArray.prototype.concat.apply([], a);
}
exports.flatten = flatten;
/**
 * Creates an array of length `count`, filled with value or (if value is a function), value()
 *
 * @param {T | ((index?: number) => T)} value The value to fill the array with or a value generator (called with index as arg)
 * @param {number} count The length of the array to generate
 * @return {any[]}
 */
function createFilledArray(value, count) {
    var out = [];
    for (var i = 0; i < count; i++) {
        out[i] = typeof (value) === "function" ? value(i) : value;
    }
    return out;
}
exports.createFilledArray = createFilledArray;

},{"d3":414}],618:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bucket = void 0;
/**
 * This class keeps track of bucketing state while collapsing dense line
 * geometry in a line and area plots.
 */
var Bucket = /** @class */ (function () {
    function Bucket(index, xValue, yValue) {
        this.entryIndex = index;
        this.exitIndex = index;
        this.minIndex = index;
        this.maxIndex = index;
        this.bucketValue = xValue;
        this.minValue = yValue;
        this.maxValue = yValue;
    }
    Bucket.prototype.isInBucket = function (value) {
        return value == this.bucketValue;
    };
    Bucket.prototype.addToBucket = function (value, index) {
        if (value < this.minValue) {
            this.minValue = value;
            this.minIndex = index;
        }
        if (value > this.maxValue) {
            this.maxValue = value;
            this.maxIndex = index;
        }
        this.exitIndex = index;
    };
    Bucket.prototype.getUniqueIndices = function () {
        var idxs = [this.entryIndex, this.maxIndex, this.minIndex, this.exitIndex];
        return idxs.filter(function (idx, i) { return i == 0 || idx != idxs[i - 1]; });
    };
    return Bucket;
}());
exports.Bucket = Bucket;

},{}],619:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallbackSet = void 0;
var tslib_1 = require("tslib");
var set_1 = require("./set");
/**
 * A set of callbacks which can be all invoked at once.
 * Each callback exists at most once in the set (based on reference equality).
 * All callbacks should have the same signature.
 */
var CallbackSet = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(CallbackSet, _super);
    function CallbackSet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CallbackSet.prototype.callCallbacks = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.forEach(function (callback) {
            callback.apply(_this, args);
        });
        return this;
    };
    return CallbackSet;
}(set_1.Set));
exports.CallbackSet = CallbackSet;

},{"./set":631,"tslib":635}],620:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.coerceExternalD3 = void 0;
var d3 = require("d3");
/**
 * Coerce possibly external d3 instance into our own instance of d3 so we can use d3-selection-multi.
 * See https://github.com/d3/d3-selection-multi/issues/11 for why we have to do this.
 *
 * Any public facing API that accepts a d3 selection should first pass that user-supplied selection
 * through here - this ensures all selection objects that go through the Plottable codebase are "vetted".
 */
function coerceExternalD3(externalD3Selection) {
    // if .attrs isn't defined; convert the selection
    if (externalD3Selection.attrs == null) {
        if (externalD3Selection.nodes == null) {
            // nodes isn't defined; this is probably a d3v3 selection. handle it accordingly
            var nodes_1 = [];
            externalD3Selection.each(function () {
                nodes_1.push(this);
            });
            return d3.selectAll(nodes_1);
        }
        else {
            return d3.selectAll(externalD3Selection.nodes());
        }
    }
    else {
        return externalD3Selection;
    }
}
exports.coerceExternalD3 = coerceExternalD3;

},{"d3":414}],621:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.colorTest = exports.lightenColor = exports.contrast = void 0;
var d3 = require("d3");
var nativeMath = window.Math;
/**
 * Return contrast ratio between two colors
 * Based on implementation from chroma.js by Gregor Aisch (gka) (licensed under BSD)
 * chroma.js may be found here: https://github.com/gka/chroma.js
 * License may be found here: https://github.com/gka/chroma.js/blob/master/LICENSE
 * see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
 */
function contrast(a, b) {
    var l1 = luminance(a) + 0.05;
    var l2 = luminance(b) + 0.05;
    return l1 > l2 ? l1 / l2 : l2 / l1;
}
exports.contrast = contrast;
/**
 * Returns a brighter copy of this color. Each channel is multiplied by 0.7 ^ -factor.
 * Channel values are capped at the maximum value of 255, and the minimum value of 30.
 */
function lightenColor(color, factor) {
    var brightened = d3.color(color).brighter(factor);
    return brightened.rgb().toString();
}
exports.lightenColor = lightenColor;
/**
 * Gets the Hex Code of the color resulting by applying the className CSS class to the
 * colorTester selection. Returns null if the tester is transparent.
 *
 * @param {d3.Selection<void>} colorTester The d3 selection to apply the CSS class to
 * @param {string} className The name of the class to be applied
 * @return {string} The hex code of the computed color
 */
function colorTest(colorTester, className) {
    colorTester.classed(className, true);
    // Use regex to get the text inside the rgb parentheses
    var colorStyle = colorTester.style("background-color");
    if (colorStyle === "transparent") {
        return null;
    }
    var match = /\((.+)\)/.exec(colorStyle);
    if (!match) {
        return null;
    }
    var rgb = match[1]
        .split(",")
        .map(function (colorValue) {
        var colorNumber = +colorValue;
        var hexValue = colorNumber.toString(16);
        return colorNumber < 16 ? "0" + hexValue : hexValue;
    });
    if (rgb.length === 4 && rgb[3] === "00") {
        return null;
    }
    var hexCode = "#" + rgb.join("");
    colorTester.classed(className, false);
    return hexCode;
}
exports.colorTest = colorTest;
/**
 * Return relative luminance (defined here: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)
 * Based on implementation from chroma.js by Gregor Aisch (gka) (licensed under BSD)
 * chroma.js may be found here: https://github.com/gka/chroma.js
 * License may be found here: https://github.com/gka/chroma.js/blob/master/LICENSE
 */
function luminance(color) {
    var rgb = d3.rgb(color);
    var lum = function (x) {
        x = x / 255;
        return x <= 0.03928 ? x / 12.92 : nativeMath.pow((x + 0.055) / 1.055, 2.4);
    };
    var r = lum(rgb.r);
    var g = lum(rgb.g);
    var b = lum(rgb.b);
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

},{"d3":414}],622:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getElementTransform = exports.getHtmlElementAncestors = exports.intersectsBBox = exports.clientRectInside = exports.expandRect = exports.clientRectsOverlap = exports.getScaleValues = exports.getRotate = exports.getTranslateValues = exports.elementHeight = exports.elementWidth = exports.requestAnimationFramePolyfill = exports.SCREEN_REFRESH_RATE_MILLISECONDS = exports.entityBounds = exports.elementBBox = exports.contains = void 0;
var d3 = require("d3");
var nativeMath = window.Math;
/**
 * Returns whether the child is in fact a child of the parent
 */
function contains(parent, child) {
    var maybeParent = child;
    while (maybeParent != null && maybeParent !== parent) {
        maybeParent = maybeParent.parentNode;
    }
    return maybeParent === parent;
}
exports.contains = contains;
/**
 * Gets the bounding box of an element.
 * @param {d3.Selection} element
 * @returns {SVGRed} The bounding box.
 */
function elementBBox(element) {
    var bbox;
    // HACKHACK: Firefox won't correctly measure nodes with style "display: none" or their descendents (FF Bug 612118).
    try {
        bbox = element.node().getBBox();
    }
    catch (err) {
        bbox = { x: 0, y: 0, width: 0, height: 0 };
    }
    return bbox;
}
exports.elementBBox = elementBBox;
function entityBounds(element) {
    if (element instanceof SVGElement) {
        return elementBBox(d3.select(element));
    }
    else if (element instanceof HTMLElement) {
        var rect = element.getBoundingClientRect();
        return { x: rect.left, y: rect.top, width: rect.width, height: rect.height };
    }
    else {
        return { x: 0, y: 0, width: 0, height: 0 };
    }
}
exports.entityBounds = entityBounds;
/**
 * Screen refresh rate which is assumed to be 60fps
 */
exports.SCREEN_REFRESH_RATE_MILLISECONDS = 1000 / 60;
/**
 * Polyfill for `window.requestAnimationFrame`.
 * If the function exists, then we use the function directly.
 * Otherwise, we set a timeout on `SCREEN_REFRESH_RATE_MILLISECONDS` and then perform the function.
 *
 * @param {() => void} callback The callback to call in the next animation frame
 */
function requestAnimationFramePolyfill(callback) {
    if (window.requestAnimationFrame != null) {
        window.requestAnimationFrame(callback);
    }
    else {
        setTimeout(callback, exports.SCREEN_REFRESH_RATE_MILLISECONDS);
    }
}
exports.requestAnimationFramePolyfill = requestAnimationFramePolyfill;
/**
 * Calculates the width of the element.
 * The width includes the padding and the border on the element's left and right sides.
 *
 * @param {Element} element The element to query
 * @returns {number} The width of the element.
 */
function elementWidth(elementOrSelection) {
    var element = elementOrSelection instanceof d3.selection
        ? elementOrSelection.node()
        : elementOrSelection;
    var style = window.getComputedStyle(element);
    return _parseStyleValue(style, "width")
        + _parseStyleValue(style, "padding-left")
        + _parseStyleValue(style, "padding-right")
        + _parseStyleValue(style, "border-left-width")
        + _parseStyleValue(style, "border-right-width");
}
exports.elementWidth = elementWidth;
/**
 * Calculates the height of the element.
 * The height includes the padding the and the border on the element's top and bottom sides.
 *
 * @param {Element} element The element to query
 * @returns {number} The height of the element
 */
function elementHeight(elementOrSelection) {
    var element = elementOrSelection instanceof d3.selection
        ? elementOrSelection.node()
        : elementOrSelection;
    var style = window.getComputedStyle(element);
    return _parseStyleValue(style, "height")
        + _parseStyleValue(style, "padding-top")
        + _parseStyleValue(style, "padding-bottom")
        + _parseStyleValue(style, "border-top-width")
        + _parseStyleValue(style, "border-bottom-width");
}
exports.elementHeight = elementHeight;
// taken from the BNF at https://www.w3.org/TR/SVG/coords.html
var WSP = "\\s";
var NUMBER = "(?:[-+]?[0-9]*\\.?[0-9]+)";
var COMMA_WSP = "(?:(?:" + WSP + "+,?" + WSP + "*)|(?:," + WSP + "*))";
var TRANSLATE_REGEX = new RegExp("translate" + WSP + "*\\(" + WSP + "*(" + NUMBER + ")(?:" + COMMA_WSP + "(" + NUMBER + "))?" + WSP + "*\\)");
var ROTATE_REGEX = new RegExp("rotate" + WSP + "*\\(" + WSP + "*(" + NUMBER + ")" + WSP + "*\\)");
var SCALE_REGEX = new RegExp("scale" + WSP + "*\\(" + WSP + "*(" + NUMBER + ")(?:" + COMMA_WSP + "(" + NUMBER + "))?" + WSP + "*\\)");
/**
 * Accepts selections whose .transform contain a "translate(a, b)" and extracts the a and b
 */
function getTranslateValues(el) {
    var match = TRANSLATE_REGEX.exec(el.attr("transform"));
    if (match != null) {
        var translateX = match[1], _a = match[2], translateY = _a === void 0 ? 0 : _a;
        return [+translateX, +translateY];
    }
    else {
        return [0, 0];
    }
}
exports.getTranslateValues = getTranslateValues;
/**
 * Accepts selections whose .transform contain a "rotate(angle)" and returns the angle
 */
function getRotate(el) {
    var match = ROTATE_REGEX.exec(el.attr("transform"));
    if (match != null) {
        var rotation = match[1];
        return +rotation;
    }
    else {
        return 0;
    }
}
exports.getRotate = getRotate;
function getScaleValues(el) {
    var match = SCALE_REGEX.exec(el.attr("transform"));
    if (match != null) {
        var scaleX = match[1], scaleY = match[2];
        return [+scaleX, scaleY == null ? +scaleX : +scaleY];
    }
    else {
        return [0, 0];
    }
}
exports.getScaleValues = getScaleValues;
/**
 * Checks if the first ClientRect overlaps the second.
 *
 * @param {ClientRect} clientRectA The first ClientRect
 * @param {ClientRect} clientRectB The second ClientRect
 * @returns {boolean} If the ClientRects overlap each other.
 */
function clientRectsOverlap(clientRectA, clientRectB) {
    if (nativeMath.floor(clientRectA.right) <= nativeMath.ceil(clientRectB.left)) {
        return false;
    }
    if (nativeMath.ceil(clientRectA.left) >= nativeMath.floor(clientRectB.right)) {
        return false;
    }
    if (nativeMath.floor(clientRectA.bottom) <= nativeMath.ceil(clientRectB.top)) {
        return false;
    }
    if (nativeMath.ceil(clientRectA.top) >= nativeMath.floor(clientRectB.bottom)) {
        return false;
    }
    return true;
}
exports.clientRectsOverlap = clientRectsOverlap;
/**
 * Return a new ClientRect that is the old ClientRect expanded by amount in all directions.
 * @param rect
 * @param amount
 */
function expandRect(rect, amount) {
    return {
        left: rect.left - amount,
        top: rect.top - amount,
        right: rect.right + amount,
        bottom: rect.bottom + amount,
        width: rect.width + amount * 2,
        height: rect.height + amount * 2,
    };
}
exports.expandRect = expandRect;
/**
 * Returns true if and only if innerClientRect is inside outerClientRect.
 *
 * @param {ClientRect} innerClientRect The first ClientRect
 * @param {ClientRect} outerClientRect The second ClientRect
 * @returns {boolean} If and only if the innerClientRect is inside outerClientRect.
 */
function clientRectInside(innerClientRect, outerClientRect) {
    return (nativeMath.floor(outerClientRect.left) <= nativeMath.ceil(innerClientRect.left) &&
        nativeMath.floor(outerClientRect.top) <= nativeMath.ceil(innerClientRect.top) &&
        nativeMath.floor(innerClientRect.right) <= nativeMath.ceil(outerClientRect.right) &&
        nativeMath.floor(innerClientRect.bottom) <= nativeMath.ceil(outerClientRect.bottom));
}
exports.clientRectInside = clientRectInside;
/**
 * Returns true if the supplied coordinates or Ranges intersect or are contained by bbox.
 *
 * @param {number | Range} xValOrRange The x coordinate or Range to test
 * @param {number | Range} yValOrRange The y coordinate or Range to test
 * @param {SVGRect} bbox The bbox
 * @param {number} tolerance Amount by which to expand bbox, in each dimension, before
 * testing intersection
 *
 * @returns {boolean} True if the supplied coordinates or Ranges intersect or are
 * contained by bbox, false otherwise.
 */
function intersectsBBox(xValOrRange, yValOrRange, bbox, tolerance) {
    if (tolerance === void 0) { tolerance = 0.5; }
    var xRange = _parseRange(xValOrRange);
    var yRange = _parseRange(yValOrRange);
    // SVGRects are positioned with sub-pixel accuracy (the default unit
    // for the x, y, height & width attributes), but user selections (e.g. via
    // mouse events) usually have pixel accuracy. A tolerance of half-a-pixel
    // seems appropriate.
    return bbox.x + bbox.width >= xRange.min - tolerance &&
        bbox.x <= xRange.max + tolerance &&
        bbox.y + bbox.height >= yRange.min - tolerance &&
        bbox.y <= yRange.max + tolerance;
}
exports.intersectsBBox = intersectsBBox;
/**
 * Create a Range from a number or an object with "min" and "max" defined.
 *
 * @param {any} input The object to parse
 *
 * @returns {Range} The generated Range
 */
function _parseRange(input) {
    if (typeof (input) === "number") {
        var value = input;
        return { min: value, max: value };
    }
    var range = input;
    if (range instanceof Object && "min" in range && "max" in range) {
        return range;
    }
    throw new Error("input '" + input + "' can't be parsed as an Range");
}
function _parseStyleValue(style, property) {
    var value = style.getPropertyValue(property);
    var parsedValue = parseFloat(value);
    return parsedValue || 0;
}
/**
 * Returns an array containing all ancestor `HTMLElement`s, starting at the
 * provided element and usually ending with the `<body>` element.
 */
function getHtmlElementAncestors(elem) {
    var elems = [];
    while (elem && elem instanceof HTMLElement) {
        elems.push(elem);
        elem = elem.parentElement;
    }
    return elems;
}
exports.getHtmlElementAncestors = getHtmlElementAncestors;
/**
 * Returns the `ICssTransformMatrix` of an element, if defined in its computed
 * style. Returns `null` if there is no transform on the element.
 */
function getElementTransform(elem) {
    var style = window.getComputedStyle(elem, null);
    var transform = style.getPropertyValue("-webkit-transform") ||
        style.getPropertyValue("-moz-transform") ||
        style.getPropertyValue("-ms-transform") ||
        style.getPropertyValue("-o-transform") ||
        style.getPropertyValue("transform");
    return parseTransformMatrix(transform);
}
exports.getElementTransform = getElementTransform;
var _MATRIX_REGEX = /^matrix\(([^)]+)\)$/;
var _SPLIT_REGEX = /[, ]+/;
/**
 * Attempts to parse a string such as `"matrix(1, 0, 1, 1, 100, 0)"` into an
 * array such as `[1, 0, 1, 1, 100, 0]`.
 *
 * If unable to do so, `null` is returned.
 */
function parseTransformMatrix(transform) {
    if (transform == null || transform === "none") {
        return null;
    }
    var matrixStrings = transform.match(_MATRIX_REGEX);
    if (matrixStrings == null || matrixStrings.length < 2) {
        return null;
    }
    var matrix = matrixStrings[1].split(_SPLIT_REGEX).map(function (v) { return parseFloat(v); });
    if (matrix.length != 6) {
        return null;
    }
    return matrix;
}

},{"d3":414}],623:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityStore = void 0;
var rTree_1 = require("./rTree");
/**
 * Implementation of {IEntityStore} that uses an array for easy iteration as
 * well as a quad tree for fast nearest-point queries.
 *
 * Note that if the position of your entities changes, you MUST rebuild the
 * entity store for the `entityNearest` method to work since the quadtree does
 * not know that its nodes have moved.
 */
var EntityStore = /** @class */ (function () {
    function EntityStore() {
        this._entities = [];
        this._rtree = new rTree_1.RTree();
    }
    EntityStore.prototype.addAll = function (entities, entityBoundsFactory, bounds) {
        this._entities = this._entities.concat(entities);
        // filter out of bounds entities if bounds is defined
        if (bounds !== undefined) {
            var filterBounds = rTree_1.RTreeBounds.bounds(bounds);
            for (var i = 0; i < entities.length; i++) {
                var entity = entities[i];
                var entityBounds = rTree_1.RTreeBounds.entityBounds(entityBoundsFactory(entity));
                if (rTree_1.RTreeBounds.isBoundsOverlapBounds(filterBounds, entityBounds)) {
                    this._rtree.insert(entityBounds, entity);
                }
            }
        }
        else {
            for (var i = 0; i < entities.length; i++) {
                var entity = entities[i];
                var entityBounds = rTree_1.RTreeBounds.entityBounds(entityBoundsFactory(entity));
                this._rtree.insert(entityBounds, entity);
            }
        }
    };
    EntityStore.prototype.entityNearest = function (queryPoint) {
        return this._rtree.locateNearest(queryPoint).pop();
    };
    EntityStore.prototype.entityNearestX = function (queryPoint) {
        return this._rtree.locateNearestX(queryPoint).pop();
    };
    EntityStore.prototype.entityNearestY = function (queryPoint) {
        return this._rtree.locateNearestY(queryPoint).pop();
    };
    EntityStore.prototype.entitiesInBounds = function (bounds) {
        return this._rtree.intersect(rTree_1.RTreeBounds.entityBounds(bounds));
    };
    EntityStore.prototype.entitiesInXBounds = function (bounds) {
        return this._rtree.intersectX(rTree_1.RTreeBounds.entityBounds(bounds));
    };
    EntityStore.prototype.entitiesInYBounds = function (bounds) {
        return this._rtree.intersectY(rTree_1.RTreeBounds.entityBounds(bounds));
    };
    EntityStore.prototype.entities = function () {
        return this._entities;
    };
    return EntityStore;
}());
exports.EntityStore = EntityStore;

},{"./rTree":629}],624:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Window = exports.Stacking = exports.RTree = exports.Math = exports.DOM = exports.Color = exports.Array = void 0;
var tslib_1 = require("tslib");
var Array = require("./arrayUtils");
exports.Array = Array;
var Color = require("./colorUtils");
exports.Color = Color;
var DOM = require("./domUtils");
exports.DOM = DOM;
var Math = require("./mathUtils");
exports.Math = Math;
var RTree = require("./rTree");
exports.RTree = RTree;
var Stacking = require("./stackingUtils");
exports.Stacking = Stacking;
var Window = require("./windowUtils");
exports.Window = Window;
(0, tslib_1.__exportStar)(require("./bucket"), exports);
(0, tslib_1.__exportStar)(require("./callbackSet"), exports);
(0, tslib_1.__exportStar)(require("./coerceD3"), exports);
(0, tslib_1.__exportStar)(require("./entityStore"), exports);
(0, tslib_1.__exportStar)(require("./map"), exports);
(0, tslib_1.__exportStar)(require("./objectUtils"), exports);
(0, tslib_1.__exportStar)(require("./set"), exports);
(0, tslib_1.__exportStar)(require("./transformAwareTranslator"), exports);

},{"./arrayUtils":617,"./bucket":618,"./callbackSet":619,"./coerceD3":620,"./colorUtils":621,"./domUtils":622,"./entityStore":623,"./map":626,"./mathUtils":627,"./objectUtils":628,"./rTree":629,"./set":631,"./stackingUtils":632,"./transformAwareTranslator":633,"./windowUtils":634,"tslib":635}],625:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeEnum = void 0;
function makeEnum(values) {
    return values.reduce(function (obj, v) {
        obj[v] = v;
        return obj;
    }, {});
}
exports.makeEnum = makeEnum;

},{}],626:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Map = void 0;
var Math = require("./mathUtils");
/**
 * Shim for ES6 map.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
 */
var Map = /** @class */ (function () {
    function Map() {
        if (typeof window.Map === "function") {
            this._es6Map = new window.Map();
        }
        else {
            this._keyValuePairs = [];
        }
    }
    Map.prototype.set = function (key, value) {
        if (Math.isNaN(key)) {
            throw new Error("NaN may not be used as a key to the Map");
        }
        if (this._es6Map != null) {
            this._es6Map.set(key, value);
            return this;
        }
        for (var i = 0; i < this._keyValuePairs.length; i++) {
            if (this._keyValuePairs[i].key === key) {
                this._keyValuePairs[i].value = value;
                return this;
            }
        }
        this._keyValuePairs.push({ key: key, value: value });
        return this;
    };
    Map.prototype.get = function (key) {
        if (this._es6Map != null) {
            return this._es6Map.get(key);
        }
        for (var i = 0; i < this._keyValuePairs.length; i++) {
            if (this._keyValuePairs[i].key === key) {
                return this._keyValuePairs[i].value;
            }
        }
        return undefined;
    };
    Map.prototype.has = function (key) {
        if (this._es6Map != null) {
            return this._es6Map.has(key);
        }
        for (var i = 0; i < this._keyValuePairs.length; i++) {
            if (this._keyValuePairs[i].key === key) {
                return true;
            }
        }
        return false;
    };
    Map.prototype.forEach = function (callbackFn, thisArg) {
        var _this = this;
        if (this._es6Map != null) {
            var callbackWrapper = function (value, key) { return callbackFn.call(thisArg, value, key, _this); };
            this._es6Map.forEach(callbackWrapper, thisArg);
            return;
        }
        this._keyValuePairs.forEach(function (keyValuePair) {
            callbackFn.call(thisArg, keyValuePair.value, keyValuePair.key, _this);
        });
    };
    Map.prototype.delete = function (key) {
        if (this._es6Map != null) {
            return this._es6Map.delete(key);
        }
        for (var i = 0; i < this._keyValuePairs.length; i++) {
            if (this._keyValuePairs[i].key === key) {
                this._keyValuePairs.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    return Map;
}());
exports.Map = Map;

},{"./mathUtils":627}],627:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyTransform = exports.invertMatrix = exports.multiplyTranslate = exports.premultiplyTranslate = exports.multiplyMatrix = exports.getCumulativeTransform = exports.boundsIntersects = exports.within = exports.degreesToRadians = exports.distanceSquared = exports.range = exports.isValidNumber = exports.isNaN = exports.min = exports.max = exports.clamp = exports.inRange = void 0;
var d3 = require("d3");
var domUtils_1 = require("./domUtils");
var nativeMath = window.Math;
var _IDENTITY_TRANSFORM = [1, 0, 0, 1, 0, 0];
/**
 * Checks if x is between a and b.
 *
 * @param {number} x The value to test if in range
 * @param {number} a The beginning of the (inclusive) range
 * @param {number} b The ending of the (inclusive) range
 * @return {boolean} Whether x is in [a, b]
 */
function inRange(x, a, b) {
    return (nativeMath.min(a, b) <= x && x <= nativeMath.max(a, b));
}
exports.inRange = inRange;
/**
 * Clamps x to the range [min, max].
 *
 * @param {number} x The value to be clamped.
 * @param {number} min The minimum value.
 * @param {number} max The maximum value.
 * @return {number} A clamped value in the range [min, max].
 */
function clamp(x, min, max) {
    return nativeMath.min(nativeMath.max(min, x), max);
}
exports.clamp = clamp;
function max(array, firstArg, secondArg) {
    var accessor = typeof (firstArg) === "function" ? firstArg : null;
    var defaultValue = accessor == null ? firstArg : secondArg;
    var maxValue = accessor == null ? d3.max(array) : d3.max(array, accessor);
    return maxValue !== undefined ? maxValue : defaultValue;
}
exports.max = max;
function min(array, firstArg, secondArg) {
    var accessor = typeof (firstArg) === "function" ? firstArg : null;
    var defaultValue = accessor == null ? firstArg : secondArg;
    var minValue = accessor == null ? d3.min(array) : d3.min(array, accessor);
    return minValue !== undefined ? minValue : defaultValue;
}
exports.min = min;
/**
 * Returns true **only** if x is NaN
 */
function isNaN(n) {
    return n !== n;
}
exports.isNaN = isNaN;
/**
 * Returns true if the argument is a number, which is not NaN
 * Numbers represented as strings do not pass this function
 */
function isValidNumber(n) {
    return typeof n === "number" && n - n < 1;
}
exports.isValidNumber = isValidNumber;
/**
 * Generates an array of consecutive, strictly increasing numbers
 * in the range [start, stop) separeted by step
 */
function range(start, stop, step) {
    if (step === void 0) { step = 1; }
    if (step === 0) {
        throw new Error("step cannot be 0");
    }
    var length = nativeMath.max(nativeMath.ceil((stop - start) / step), 0);
    var range = [];
    for (var i = 0; i < length; ++i) {
        range[i] = start + step * i;
    }
    return range;
}
exports.range = range;
/**
 * Returns the square of the distance between two points
 *
 * @param {Point} p1
 * @param {Point} p2
 * @return {number} dist(p1, p2)^2
 */
function distanceSquared(p1, p2) {
    return nativeMath.pow(p2.y - p1.y, 2) + nativeMath.pow(p2.x - p1.x, 2);
}
exports.distanceSquared = distanceSquared;
function degreesToRadians(degree) {
    return degree / 360 * nativeMath.PI * 2;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Returns if the point is within the bounds. Points along
 * the bounds are considered "within" as well.
 * @param {Point} p Point in considerations.
 * @param {Bounds} bounds Bounds within which to check for inclusion.
 */
function within(p, bounds) {
    return bounds.topLeft.x <= p.x
        && bounds.bottomRight.x >= p.x
        && bounds.topLeft.y <= p.y
        && bounds.bottomRight.y >= p.y;
}
exports.within = within;
/**
 * Returns whether the first bounds intersects the second bounds.
 * Pass primitive numbers directly for performance.
 *
 * Assumes width and heights are positive.
 */
function boundsIntersects(aX, aY, aWidth, aHeight, bX, bY, bWidth, bHeight) {
    return aX <= bX + bWidth &&
        bX <= aX + aWidth &&
        aY <= bY + bHeight &&
        bY <= aY + aHeight;
}
exports.boundsIntersects = boundsIntersects;
/**
 * Returns a `ICssTransformMatrix` representing the cumulative transformation of
 * the element and all its parents. This transform converts from top-level
 * clientX/clientY coordinates (such as document mouse events) to internal
 * component offsetX/offsetY coordinates.
 *
 * Use `applyTransform` to convert from client coordinates to element
 * coordinates, accounting for all CSS transforms applied to that element.
 *
 * Note that this handles css `transform` but does not handle css
 * `transform-origin` values other than default ("50% 50%").
 */
function getCumulativeTransform(element) {
    var elems = (0, domUtils_1.getHtmlElementAncestors)(element);
    var transform = _IDENTITY_TRANSFORM;
    var offsetParent = null;
    for (var _i = 0, elems_1 = elems; _i < elems_1.length; _i++) {
        var elem = elems_1[_i];
        // apply css transform from any ancestor element
        var elementTransform = (0, domUtils_1.getElementTransform)(elem);
        if (elementTransform != null) {
            var midX = elem.clientWidth / 2;
            var midY = elem.clientHeight / 2;
            transform = multiplyTranslate(transform, [midX, midY]);
            transform = multiplyMatrix(transform, invertMatrix(elementTransform));
            transform = multiplyTranslate(transform, [-midX, -midY]);
        }
        // apply scroll offsets from any ancestor element
        var offsetX = elem.scrollLeft;
        var offsetY = elem.scrollTop;
        // apply client+offset from only acenstor "offsetParent"
        if (offsetParent === null || elem === offsetParent) {
            offsetX -= elem.offsetLeft + elem.clientLeft;
            offsetY -= elem.offsetTop + elem.clientTop;
            offsetParent = elem.offsetParent;
        }
        transform = multiplyTranslate(transform, [offsetX, offsetY]);
    }
    return transform;
}
exports.getCumulativeTransform = getCumulativeTransform;
/**
 * Straightforward matrix multiplication of homogenized css transform matrices.
 */
function multiplyMatrix(a, b) {
    return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5],
    ];
}
exports.multiplyMatrix = multiplyMatrix;
/**
 * Prepends translation to transformation matrix.
 *
 * Equivalent to `multiplyMatrix([1, 0, 0, 1, ...v], b)`
 */
function premultiplyTranslate(v, b) {
    return [
        b[0], b[1], b[2], b[3],
        b[4] + v[0],
        b[5] + v[1],
    ];
}
exports.premultiplyTranslate = premultiplyTranslate;
/**
 * Appends translation to transformation matrix.
 *
 * Equivalent to `multiplyMatrix(a, [1, 0, 0, 1, ...v])`
 */
function multiplyTranslate(a, v) {
    return [
        a[0], a[1], a[2], a[3],
        a[0] * v[0] + a[2] * v[1] + a[4],
        a[1] * v[0] + a[3] * v[1] + a[5],
    ];
}
exports.multiplyTranslate = multiplyTranslate;
/**
 * Analytical inverse of a `ICssTransformMatrix` analogous to a non-singular
 * homogenous 3x3 matrix.
 *
 * http://mathworld.wolfram.com/MatrixInverse.html
 * https://stackoverflow.com/questions/2624422/efficient-4x4-matrix-inverse-affine-transform
 */
function invertMatrix(a) {
    var determinant = a[0] * a[3] - a[1] * a[2];
    if (determinant === 0) {
        throw new Error("singular matrix");
    }
    var inverseDeterminant = 1 / determinant;
    return [
        inverseDeterminant * a[3],
        inverseDeterminant * -a[1],
        inverseDeterminant * -a[2],
        inverseDeterminant * a[0],
        inverseDeterminant * (-a[3] * a[4] + a[2] * a[5]),
        inverseDeterminant * (a[1] * a[4] + -a[0] * a[5]),
    ];
}
exports.invertMatrix = invertMatrix;
/**
 * Applies the `ICssTransformMatrix` to the `Point`.
 *
 * Returns a new `Point`.
 */
function applyTransform(a, p) {
    return {
        x: a[0] * p.x + a[2] * p.y + a[4],
        y: a[1] * p.x + a[3] * p.y + a[5],
    };
}
exports.applyTransform = applyTransform;

},{"./domUtils":622,"d3":414}],628:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assign = void 0;
/**
 * Polyfill for Object.assign
 */
function assign() {
    var objs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objs[_i] = arguments[_i];
    }
    var result = {};
    for (var _a = 0, objs_1 = objs; _a < objs_1.length; _a++) {
        var obj = objs_1[_a];
        var keys = Object.keys(obj);
        for (var _b = 0, keys_1 = keys; _b < keys_1.length; _b++) {
            var key = keys_1[_b];
            result[key] = obj[key];
        }
    }
    return result;
}
exports.assign = assign;

},{}],629:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RTreeBounds = exports.RTreeNode = exports.RTree = exports.createNodeSort = exports.createMinimizingNodePredicate = exports.QueryPredicateResult = void 0;
var rTreeSplitStrategies_1 = require("./rTreeSplitStrategies");
/**
 * The maximum number of children in an r-tree node before we attempt to split.
 * This must be >= 2.
 */
var DEFAULT_MAX_NODE_CHILDREN = 5;
/**
 * There are several strategies for splitting nodes that contain overlapping
 * regions. By default we use `SplitStrategyLinear` which minimizes the change
 * in node bounding box area.
 */
var DEFAULT_SPLIT_STRATEGY = new rTreeSplitStrategies_1.SplitStrategyLinear();
/**
 * The return result of predicates used with `RTree.queryNodes`.
 *
 * The `PASS_AND_OVERWRITE` value will overwrite previous results
 * when the predicate finds a more optimal result.
 */
var QueryPredicateResult;
(function (QueryPredicateResult) {
    QueryPredicateResult[QueryPredicateResult["PASS"] = 0] = "PASS";
    QueryPredicateResult[QueryPredicateResult["FAIL"] = 1] = "FAIL";
    QueryPredicateResult[QueryPredicateResult["PASS_AND_OVERWRITE"] = 2] = "PASS_AND_OVERWRITE";
})(QueryPredicateResult = exports.QueryPredicateResult || (exports.QueryPredicateResult = {}));
/**
 * Creates a node predicate for use with `RTree.queryNodes`
 *
 * @param point - the query point
 * @param nearFn - an `IDistanceFunction` from the query point to the nearest
 * point on the node bounds
 * @param farFn - an `IDistanceFunction` from the query point to the farthest
 * point on the node bounds
 */
function createMinimizingNodePredicate(point, nearFn, farFn) {
    var nearestLeafDistance = Infinity;
    var nearestBranchDistance = Infinity;
    var farthestBranchDistance = Infinity;
    return function (node) {
        var near = nearFn(node.bounds, point);
        var far = farFn(node.bounds, point);
        // assumption: node.value indicates that parent is a leaf
        if (node.value != null) {
            if (near < nearestLeafDistance) {
                nearestLeafDistance = near;
                nearestBranchDistance = near;
                farthestBranchDistance = far;
                return QueryPredicateResult.PASS_AND_OVERWRITE;
            }
            else if (near === nearestLeafDistance) {
                return QueryPredicateResult.PASS;
            }
            else {
                return QueryPredicateResult.FAIL;
            }
        }
        else {
            if (near > farthestBranchDistance) {
                return QueryPredicateResult.FAIL;
            }
            else {
                nearestBranchDistance = Math.min(near, nearestBranchDistance);
                farthestBranchDistance = Math.max(far, farthestBranchDistance);
                return QueryPredicateResult.PASS;
            }
        }
    };
}
exports.createMinimizingNodePredicate = createMinimizingNodePredicate;
/**
 * Create a `Array.sort` function from a query point and a distance function.
 */
function createNodeSort(point, distanceFn) {
    return function (a, b) {
        return distanceFn(b.bounds, point) - distanceFn(a.bounds, point);
    };
}
exports.createNodeSort = createNodeSort;
/**
 * R-Tree is a multidimensional spatial region tree. It stores entries that have
 * arbitrarily overlapping bounding boxes and supports efficient point and
 * bounding box overlap queries.
 *
 * Average search time complexity is O(log_M(N)) where M = max children per node
 * and N is number of values stored in tree.
 *
 * It is similar in purpose to a quadtree except quadtrees can only store a
 * single point per entry. Also, the space-partitioning structure of quadtrees
 * provides guarantees that any given value has no neighbors closer than its
 * node's bounds, whereas r-trees provide no such guarantees.
 */
var RTree = /** @class */ (function () {
    function RTree(maxNodeChildren, splitStrategy) {
        if (maxNodeChildren === void 0) { maxNodeChildren = DEFAULT_MAX_NODE_CHILDREN; }
        if (splitStrategy === void 0) { splitStrategy = DEFAULT_SPLIT_STRATEGY; }
        this.maxNodeChildren = maxNodeChildren;
        this.splitStrategy = splitStrategy;
        this.root = new RTreeNode(true);
        this.size = 0;
    }
    RTree.prototype.getRoot = function () {
        return this.root;
    };
    RTree.prototype.clear = function () {
        this.root = new RTreeNode(true);
        this.size = 0;
    };
    RTree.prototype.insert = function (bounds, value) {
        var node = this.root;
        // Choose subtree until we find a leaf
        while (!node.leaf) {
            node = node.subtree(bounds);
        }
        // Insert new value node into leaf node
        var valueNode = RTreeNode.valueNode(bounds, value);
        node.insert(valueNode);
        this.size += 1;
        // While node overflows, split and walk up
        while (node.overflow(this.maxNodeChildren)) {
            node = node.split(this.splitStrategy);
            if (node.parent == null) {
                this.root = node;
            }
        }
        return valueNode;
    };
    RTree.prototype.locate = function (xy) {
        return this.query(function (b) { return b.contains(xy); });
    };
    /**
     * Returns an array of `T` values that are the "nearest" to the query point.
     *
     * Nearness is measured as the absolute distance from the query point to the
     * nearest edge of the node bounds. If the node bounds contains the query
     * point, the distance is 0.
     */
    RTree.prototype.locateNearest = function (xy) {
        var predicate = createMinimizingNodePredicate(xy, RTreeBounds.distanceSquaredToNearEdge, RTreeBounds.distanceSquaredToFarEdge);
        var nodes = this.queryNodes(predicate);
        return nodes.map(function (node) { return node.value; });
    };
    /**
     * Returns an array of `T` values that are the "nearest" to the query point.
     *
     * Nearness is measured as the 1-dimensional absolute distance from the
     * query's x point to the nearest edge of the node bounds. If the node
     * bounds contains the query point, the distance is 0.
     *
     * The results are sorted by y-coordinate nearness.
     */
    RTree.prototype.locateNearestX = function (xy) {
        var predicate = createMinimizingNodePredicate(xy, RTreeBounds.absoluteDistanceToNearEdgeX, RTreeBounds.absoluteDistanceToFarEdgeX);
        var nodes = this.queryNodes(predicate);
        nodes.sort(createNodeSort(xy, RTreeBounds.absoluteDistanceToNearEdgeY));
        return nodes.map(function (node) { return node.value; });
    };
    /**
     * Returns an array of `T` values that are the "nearest" to the query point.
     *
     * Nearness is measured as the 1-dimensional absolute distance from the
     * query's y point to the nearest edge of the node bounds. If the node
     * bounds contains the query point, the distance is 0.
     *
     * The results are sorted by x-coordinate nearness.
     */
    RTree.prototype.locateNearestY = function (xy) {
        var predicate = createMinimizingNodePredicate(xy, RTreeBounds.absoluteDistanceToNearEdgeY, RTreeBounds.absoluteDistanceToFarEdgeY);
        var nodes = this.queryNodes(predicate);
        nodes.sort(createNodeSort(xy, RTreeBounds.absoluteDistanceToNearEdgeX));
        return nodes.map(function (node) { return node.value; });
    };
    RTree.prototype.intersect = function (bounds) {
        return this.query(function (b) { return RTreeBounds.isBoundsOverlapBounds(b, bounds); });
    };
    RTree.prototype.intersectX = function (bounds) {
        return this.query(function (b) { return RTreeBounds.isBoundsOverlapX(b, bounds); });
    };
    RTree.prototype.intersectY = function (bounds) {
        return this.query(function (b) { return RTreeBounds.isBoundsOverlapY(b, bounds); });
    };
    RTree.prototype.query = function (predicate) {
        var results = [];
        if (this.root.bounds != null && !predicate(this.root.bounds)) {
            return results;
        }
        var candidates = [this.root];
        while (candidates.length > 0) {
            var candidate = candidates.shift();
            for (var i = 0; i < candidate.entries.length; i++) {
                var entry = candidate.entries[i];
                if (predicate(entry.bounds)) {
                    if (candidate.leaf) {
                        results.push(entry.value);
                    }
                    else {
                        candidates.push(entry);
                    }
                }
            }
        }
        return results;
    };
    RTree.prototype.queryNodes = function (predicate) {
        var results = [];
        if (this.root.bounds != null && predicate(this.root) === QueryPredicateResult.FAIL) {
            return results;
        }
        var candidates = [this.root];
        while (candidates.length > 0) {
            var candidate = candidates.shift();
            for (var i = 0; i < candidate.entries.length; i++) {
                var entry = candidate.entries[i];
                var p = predicate(entry);
                if (p === QueryPredicateResult.PASS_AND_OVERWRITE) {
                    results = [];
                }
                if (p === QueryPredicateResult.PASS || p === QueryPredicateResult.PASS_AND_OVERWRITE) {
                    if (candidate.leaf) {
                        results.push(entry);
                    }
                    else {
                        candidates.push(entry);
                    }
                }
            }
        }
        return results;
    };
    return RTree;
}());
exports.RTree = RTree;
var RTreeNode = /** @class */ (function () {
    function RTreeNode(leaf) {
        this.leaf = leaf;
        this.bounds = null;
        this.entries = [];
        this.parent = null;
        this.value = null;
    }
    RTreeNode.valueNode = function (bounds, value) {
        var node = new RTreeNode(true);
        node.bounds = bounds;
        node.value = value;
        return node;
    };
    /**
     * Returns `true` iff this node has more children than the `maxNodeChildren`
     * parameter.
     */
    RTreeNode.prototype.overflow = function (maxNodeChildren) {
        return this.entries.length > maxNodeChildren;
    };
    /**
     * Inserts a child node and updates the ancestry bounds.
     */
    RTreeNode.prototype.insert = function (node) {
        this.entries.push(node);
        node.parent = this;
        // Update ancestor bounds
        var ancestor = this;
        while (ancestor != null) {
            ancestor.bounds = RTreeBounds.unionAll([ancestor.bounds, node.bounds]);
            ancestor = ancestor.parent;
        }
        return this;
    };
    /**
     * Removes a child node and updates the ancestry bounds.
     *
     * If the node argument is not a child, do nothing.
     */
    RTreeNode.prototype.remove = function (node) {
        var i = this.entries.indexOf(node);
        if (i >= 0) {
            this.entries.splice(i, 1);
            // Update ancestor bounds
            var ancestor = this;
            while (ancestor != null) {
                ancestor.bounds = RTreeBounds.unionAll(ancestor.entries.map(function (e) { return e.bounds; }));
                ancestor = ancestor.parent;
            }
        }
        return this;
    };
    /**
     * Chooses an node from then entries that minimizes the area difference that
     * adding the bounds the each entry would cause.
     */
    RTreeNode.prototype.subtree = function (bounds) {
        var minDiff = Infinity;
        var minEntry = null;
        // choose entry for which the addition least increases the entry's area
        for (var i = 0; i < this.entries.length; i++) {
            var entry = this.entries[i];
            var diffArea = entry.unionAreaDifference(bounds);
            if (diffArea < minDiff || (
            // break ties to node with fewest children
            diffArea === minDiff &&
                minEntry != null &&
                entry.entries.length < minEntry.entries.length)) {
                minEntry = entry;
            }
        }
        return minEntry;
    };
    /**
     * Splits this node by creating two new nodes and dividing the this node's
     * children between them. This node is removed from its parent and the two
     * new nodes are added.
     *
     * If this node is the root, a new parent node is created.
     *
     * Returns the parent node.
     */
    RTreeNode.prototype.split = function (strategy) {
        // Remove self from parent.
        if (this.parent != null) {
            this.parent.remove(this);
        }
        // Create children from split
        var children = [
            new RTreeNode(this.leaf),
            new RTreeNode(this.leaf),
        ];
        strategy.split(this.entries, children);
        // Add new nodes to parent
        // If root, create new non-leaf node as parent.
        var parent = this.parent != null ? this.parent : new RTreeNode(false);
        parent.insert(children[0]);
        parent.insert(children[1]);
        // Always make the parent a non-leaf after split
        parent.leaf = false;
        return parent;
    };
    /**
     * Returns the difference in area that adding an entry `bounds` to the node
     * would cause.
     */
    RTreeNode.prototype.unionAreaDifference = function (bounds) {
        return Math.abs(RTreeBounds.union(this.bounds, bounds).area() - this.bounds.area());
    };
    /**
     * Returns the depth from this node to the deepest leaf descendant.
     */
    RTreeNode.prototype.maxDepth = function () {
        if (this.leaf)
            return 1;
        return 1 + this.entries.map(function (e) { return e.maxDepth(); }).reduce(function (a, b) { return Math.max(a, b); });
    };
    return RTreeNode;
}());
exports.RTreeNode = RTreeNode;
var RTreeBounds = /** @class */ (function () {
    function RTreeBounds(xl, yl, xh, yh) {
        this.xl = xl;
        this.yl = yl;
        this.xh = xh;
        this.yh = yh;
        this.width = this.xh - this.xl;
        this.height = this.yh - this.yl;
    }
    RTreeBounds.xywh = function (x, y, w, h) {
        return new RTreeBounds(x, y, x + w, y + h);
    };
    RTreeBounds.entityBounds = function (bounds) {
        return new RTreeBounds(bounds.x, bounds.y, bounds.x + bounds.width, bounds.y + bounds.height);
    };
    RTreeBounds.bounds = function (bounds) {
        return RTreeBounds.pointPair(bounds.topLeft, bounds.bottomRight);
    };
    RTreeBounds.pointPair = function (p0, p1) {
        return new RTreeBounds(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    };
    RTreeBounds.points = function (points) {
        if (points.length < 2) {
            throw new Error("need at least 2 points to create bounds");
        }
        var xs = points.map(function (p) { return p.x; });
        var ys = points.map(function (p) { return p.y; });
        return new RTreeBounds(xs.reduce(function (a, b) { return Math.min(a, b); }), ys.reduce(function (a, b) { return Math.min(a, b); }), xs.reduce(function (a, b) { return Math.max(a, b); }), ys.reduce(function (a, b) { return Math.max(a, b); }));
    };
    RTreeBounds.union = function (b0, b1) {
        return new RTreeBounds(Math.min(b0.xl, b1.xl), Math.min(b0.yl, b1.yl), Math.max(b0.xh, b1.xh), Math.max(b0.yh, b1.yh));
    };
    RTreeBounds.unionAll = function (bounds) {
        bounds = bounds.filter(function (b) { return b != null; });
        if (bounds.length === 0) {
            return null;
        }
        return bounds.reduce(function (b0, b1) { return RTreeBounds.union(b0, b1); });
    };
    /**
     * Returns true if `a` overlaps `b` in the x and y axes.
     *
     * Touching counts as overlap.
     */
    RTreeBounds.isBoundsOverlapBounds = function (a, b) {
        return RTreeBounds.isBoundsOverlapX(a, b) && RTreeBounds.isBoundsOverlapY(a, b);
    };
    /**
     * Returns true if `a` overlaps `b` in the x axis only.
     *
     * Touching counts as overlap.
     */
    RTreeBounds.isBoundsOverlapX = function (a, b) {
        return !(a.xh < b.xl) && !(a.xl > b.xh);
    };
    /**
     * Returns true if `a` overlaps `b` in the y axis only.
     *
     * Touching counts as overlap.
     */
    RTreeBounds.isBoundsOverlapY = function (a, b) {
        return !(a.yh < b.yl) && !(a.yl > b.yh);
    };
    /**
     * Returns the orthogonal absolute distance in the x-dimension from point
     * `p` to the nearest edge of `bounds`.
     *
     * If `p.x` is inside the bounds returns `0`.
     */
    RTreeBounds.absoluteDistanceToNearEdgeX = function (bounds, p) {
        var half = bounds.width / 2;
        var mid = bounds.xl + half;
        return Math.max(Math.abs(p.x - mid) - half, 0);
    };
    /**
     * Returns the orthogonal absolute distance in the y-dimension from point
     * `p` to the nearest edge of `bounds`.
     *
     * If `p.y` is inside the bounds returns `0`.
     */
    RTreeBounds.absoluteDistanceToNearEdgeY = function (bounds, p) {
        var half = bounds.height / 2;
        var mid = bounds.yl + half;
        return Math.max(Math.abs(p.y - mid) - half, 0);
    };
    /**
     * Returns the orthogonal absolute distance in the x-dimension from point
     * `p` to the farthest edge of `bounds`.
     *
     * If `p.x` is inside the bounds returns `0`.
     */
    RTreeBounds.absoluteDistanceToFarEdgeX = function (bounds, p) {
        var near = RTreeBounds.absoluteDistanceToNearEdgeX(bounds, p);
        return near === 0 ? 0 : near + bounds.width;
    };
    /**
     * Returns the orthogonal absolute distance in the y-dimension from point
     * `p` to the farthest edge of `bounds`.
     *
     * If `p.y` is inside the bounds returns `0`.
     */
    RTreeBounds.absoluteDistanceToFarEdgeY = function (bounds, p) {
        var near = RTreeBounds.absoluteDistanceToNearEdgeY(bounds, p);
        return near === 0 ? 0 : near + bounds.height;
    };
    /**
     * Returns the distance squared from `p` to the nearest edge of `bounds`. If
     * the point touches or is inside the bounds, returns `0`;
     *
     * https://gamedev.stackexchange.com/questions/44483/how-do-i-calculate-distance-between-a-point-and-an-axis-aligned-rectangle
     */
    RTreeBounds.distanceSquaredToNearEdge = function (bounds, p) {
        var dx = RTreeBounds.absoluteDistanceToNearEdgeX(bounds, p);
        var dy = RTreeBounds.absoluteDistanceToNearEdgeY(bounds, p);
        return dx * dx + dy * dy;
    };
    RTreeBounds.distanceSquaredToFarEdge = function (bounds, p) {
        var dx = RTreeBounds.absoluteDistanceToFarEdgeX(bounds, p);
        var dy = RTreeBounds.absoluteDistanceToFarEdgeY(bounds, p);
        return dx * dx + dy * dy;
    };
    RTreeBounds.prototype.area = function () {
        if (this.areaCached == null) {
            this.areaCached = (this.xh - this.xl) * (this.yh - this.yl);
        }
        return this.areaCached;
    };
    RTreeBounds.prototype.contains = function (xy) {
        return this.xl <= xy.x && this.xh >= xy.x && this.yl <= xy.y && this.yh >= xy.y;
    };
    return RTreeBounds;
}());
exports.RTreeBounds = RTreeBounds;

},{"./rTreeSplitStrategies":630}],630:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitStrategyLinear = exports.SplitStrategyTrivial = void 0;
var SplitStrategyTrivial = /** @class */ (function () {
    function SplitStrategyTrivial() {
    }
    SplitStrategyTrivial.prototype.split = function (entries, nodes) {
        // Create simple middle split
        var mid = Math.ceil(entries.length / 2);
        for (var i = 0; i < mid; i++) {
            nodes[0].insert(entries[i]);
        }
        for (var i = mid; i < entries.length; i++) {
            nodes[1].insert(entries[i]);
        }
    };
    return SplitStrategyTrivial;
}());
exports.SplitStrategyTrivial = SplitStrategyTrivial;
// Linear split method adapted from https://github.com/imbcmdth/RTree/blob/master/src/rtree.js
var SplitStrategyLinear = /** @class */ (function () {
    function SplitStrategyLinear() {
    }
    SplitStrategyLinear.prototype.split = function (entries, nodes) {
        // copy entries before we mutate it
        entries = entries.slice();
        this.chooseFirstSplit(entries, nodes);
        while (entries.length > 0) {
            this.addNext(entries, nodes);
        }
    };
    /**
     * Choose the two farthest-apart entries to begin the split.
     */
    SplitStrategyLinear.prototype.chooseFirstSplit = function (entries, nodes) {
        // Determine entry indices that have min/max x/y coordinates
        var minXH = 0;
        var minYH = 0;
        var maxXL = entries.length - 1;
        var maxYL = entries.length - 1;
        for (var i = 1; i < entries.length - 1; i++) {
            var entry = entries[i];
            if (entry.bounds.xl > entries[maxXL].bounds.xl) {
                maxXL = i;
            }
            else if (entry.bounds.xh < entries[minXH].bounds.xh) {
                minXH = i;
            }
            if (entry.bounds.yl > entries[maxYL].bounds.yl) {
                maxYL = i;
            }
            else if (entry.bounds.yh < entries[minYH].bounds.yh) {
                minYH = i;
            }
        }
        // Choose to split x or y based on greatest difference
        var dx = Math.abs(entries[minXH].bounds.xh - entries[maxXL].bounds.xl);
        var dy = Math.abs(entries[minYH].bounds.yh - entries[maxYL].bounds.yl);
        var _a = dx > dy ? [minXH, maxXL] : [minYH, maxYL], i0 = _a[0], i1 = _a[1];
        // if no detectable split, just use first/last entries
        if (i0 === i1) {
            i0 = 0;
            i1 = entries.length - 1;
        }
        // Split off nodes. We splice with the max index first to make sure we
        // don't change the index of the second splice call
        nodes[0].insert(entries.splice(Math.max(i0, i1), 1)[0]);
        nodes[1].insert(entries.splice(Math.min(i0, i1), 1)[0]);
    };
    /**
     * Split the next entry. Choose the entry that expands its parent node's
     * area the least.
     */
    SplitStrategyLinear.prototype.addNext = function (entries, nodes) {
        var index = null;
        var minDiff = null;
        var minDiffNode = null;
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            var areaDiff0 = nodes[0].unionAreaDifference(entry.bounds);
            var areaDiff1 = nodes[1].unionAreaDifference(entry.bounds);
            if (areaDiff0 < minDiff || index == null) {
                index = i;
                minDiff = areaDiff0;
                minDiffNode = nodes[0];
            }
            if (areaDiff1 < minDiff) {
                index = i;
                minDiff = areaDiff1;
                minDiffNode = nodes[1];
            }
        }
        minDiffNode.insert(entries.splice(index, 1)[0]);
    };
    return SplitStrategyLinear;
}());
exports.SplitStrategyLinear = SplitStrategyLinear;

},{}],631:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Set = void 0;
/**
 * Shim for ES6 set.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 */
var Set = /** @class */ (function () {
    function Set() {
        if (typeof window.Set === "function") {
            this._es6Set = new window.Set();
        }
        else {
            this._values = [];
        }
        this.size = 0;
    }
    Set.prototype.add = function (value) {
        if (this._es6Set != null) {
            this._es6Set.add(value);
            this.size = this._es6Set.size;
            return this;
        }
        if (!this.has(value)) {
            this._values.push(value);
            this.size = this._values.length;
        }
        return this;
    };
    Set.prototype.delete = function (value) {
        if (this._es6Set != null) {
            var deleted = this._es6Set.delete(value);
            this.size = this._es6Set.size;
            return deleted;
        }
        var index = this._values.indexOf(value);
        if (index !== -1) {
            this._values.splice(index, 1);
            this.size = this._values.length;
            return true;
        }
        return false;
    };
    Set.prototype.has = function (value) {
        if (this._es6Set != null) {
            return this._es6Set.has(value);
        }
        return this._values.indexOf(value) !== -1;
    };
    Set.prototype.forEach = function (callback, thisArg) {
        var _this = this;
        if (this._es6Set != null) {
            var callbackWrapper = function (value, value2) { return callback.call(thisArg, value, value2, _this); };
            this._es6Set.forEach(callbackWrapper, thisArg);
            return;
        }
        this._values.forEach(function (value) {
            callback.call(thisArg, value, value, _this);
        });
    };
    return Set;
}());
exports.Set = Set;

},{}],632:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeKey = exports.stackedExtent = exports.stackedExtents = exports.stack = exports.IStackingOrder = void 0;
var d3 = require("d3");
var memoize_1 = require("lodash-es/memoize");
var Utils = require("./");
var makeEnum_1 = require("./makeEnum");
/**
 * Option type for stacking direction. By default, stacked bar and area charts
 * put the first data series at the bottom of the axis ("bottomup"), but this
 * can be reversed with the "topdown" option, which produces a stacking order
 * that matches the order of series in the legend.
 */
exports.IStackingOrder = (0, makeEnum_1.makeEnum)(["topdown", "bottomup"]);
var nativeMath = window.Math;
/**
 * Computes the StackingResult (value and offset) for each data point in each Dataset.
 *
 * @param {Dataset[]} datasets The Datasets to be stacked on top of each other in the order of stacking
 * @param {Accessor<any>} keyAccessor Accessor for the key of the data
 * @param {Accessor<number>} valueAccessor Accessor for the value of the data
 * @param {IStackingOrder} stackingOrder The order of stacking (default "bottomup")
 * @return {StackingResult} value and offset for each datapoint in each Dataset
 */
function stack(datasets, keyAccessor, valueAccessor, stackingOrder) {
    if (stackingOrder === void 0) { stackingOrder = "bottomup"; }
    var positiveOffsets = d3.map();
    var negativeOffsets = d3.map();
    var datasetToKeyToStackedDatum = new Utils.Map();
    if (stackingOrder === "topdown") {
        datasets = datasets.slice();
        datasets.reverse();
    }
    for (var _i = 0, datasets_1 = datasets; _i < datasets_1.length; _i++) {
        var dataset = datasets_1[_i];
        var keyToStackedDatum = new Utils.Map();
        var data = dataset.data();
        var dataLen = data.length;
        for (var index = 0; index < dataLen; index++) {
            var datum = data[index];
            var accessedKey = keyAccessor(datum, index, dataset);
            var key = (0, exports.normalizeKey)(accessedKey);
            var value = +valueAccessor(datum, index, dataset);
            var offset = void 0;
            var offsetMap = (value >= 0) ? positiveOffsets : negativeOffsets;
            if (offsetMap.has(key)) {
                offset = offsetMap.get(key);
                offsetMap.set(key, offset + value);
            }
            else {
                offset = 0;
                offsetMap.set(key, value);
            }
            keyToStackedDatum.set(key, {
                offset: offset,
                value: value,
                axisValue: accessedKey,
                originalDatum: datum,
                originalDataset: dataset,
                originalIndex: index,
            });
        }
        datasetToKeyToStackedDatum.set(dataset, keyToStackedDatum);
    }
    return datasetToKeyToStackedDatum;
}
exports.stack = stack;
/**
 * Computes the maximum and minimum extents of each stack individually.
 *
 * @param {GenericStackingResult} stackingResult The value and offset information for each datapoint in each dataset
 * @return { { maximumExtents: Utils.Map<D, number>, minimumExtents: Utils.Map<D, number> } } The maximum and minimum extents
 * of each individual stack.
 */
function stackedExtents(stackingResult) {
    var maximumExtents = new Utils.Map();
    var minimumExtents = new Utils.Map();
    stackingResult.forEach(function (stack) {
        stack.forEach(function (datum, key) {
            // correctly handle negative bar stacks
            var offsetValue = datum.offset + datum.value;
            var maximalValue = Utils.Math.max([offsetValue, datum.offset], datum.offset);
            var minimalValue = Utils.Math.min([offsetValue, datum.offset], datum.offset);
            var axisValue = datum.axisValue;
            if (!maximumExtents.has(key)) {
                maximumExtents.set(key, { extent: maximalValue, axisValue: axisValue, stackedDatum: datum });
            }
            else if (maximumExtents.get(key).extent < maximalValue) {
                maximumExtents.set(key, { extent: maximalValue, axisValue: axisValue, stackedDatum: datum });
            }
            if (!minimumExtents.has(key)) {
                minimumExtents.set(key, { extent: minimalValue, axisValue: axisValue, stackedDatum: datum });
            }
            else if (minimumExtents.get(key).extent > (minimalValue)) {
                minimumExtents.set(key, { extent: minimalValue, axisValue: axisValue, stackedDatum: datum });
            }
        });
    });
    return { maximumExtents: maximumExtents, minimumExtents: minimumExtents };
}
exports.stackedExtents = stackedExtents;
/**
 * Computes the total extent over all data points in all Datasets, taking stacking into consideration.
 *
 * @param {StackingResult} stackingResult The value and offset information for each datapoint in each dataset
 * @param {Accessor<any>} keyAccessor Accessor for the key of the data existent in the stackingResult
 * @param {Accessor<boolean>} filter A filter for data to be considered when computing the total extent
 * @return {[number, number]} The total extent
 */
function stackedExtent(stackingResult, keyAccessor, filter) {
    var extents = [];
    stackingResult.forEach(function (stackedDatumMap, dataset) {
        var data = dataset.data();
        var dataLen = data.length;
        for (var index = 0; index < dataLen; index++) {
            var datum = data[index];
            if (filter != null && !filter(datum, index, dataset)) {
                continue;
            }
            var stackedDatum = stackedDatumMap.get((0, exports.normalizeKey)(keyAccessor(datum, index, dataset)));
            extents.push(stackedDatum.value + stackedDatum.offset);
        }
    });
    var maxStackExtent = Utils.Math.max(extents, 0);
    var minStackExtent = Utils.Math.min(extents, 0);
    return [nativeMath.min(minStackExtent, 0), nativeMath.max(0, maxStackExtent)];
}
exports.stackedExtent = stackedExtent;
/**
 * Normalizes a key used for stacking
 *
 * @param {any} key The key to be normalized
 * @return {string} The stringified key
 */
exports.normalizeKey = (0, memoize_1.default)(function (key) {
    return String(key);
});

},{"./":624,"./makeEnum":625,"d3":414,"lodash-es/memoize":522}],633:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Translator = exports.getTranslator = void 0;
var Utils = require("../utils");
var _TRANSLATOR_KEY = "__Plottable_ClientTranslator";
/**
 * Returns a singleton-ized `Translator` instance associated with the component.
 */
function getTranslator(component) {
    var rootElement = component.root().rootElement().node();
    var translator = rootElement[_TRANSLATOR_KEY];
    if (translator == null) {
        translator = new Translator(rootElement);
        rootElement[_TRANSLATOR_KEY] = translator;
    }
    return translator;
}
exports.getTranslator = getTranslator;
/**
 * The translator implements CSS transform aware position measuring. We manually
 * compute a cumulative CSS3 of the root element ancestors up to `<body>`.
 */
var Translator = /** @class */ (function () {
    function Translator(_rootElement) {
        this._rootElement = _rootElement;
    }
    /**
     * Given `document` client coordinates, computes the position relative to the
     * `Component`'s root element, taking into account the cumulative CSS3
     * transforms of the root element ancestors up to `<body>`.
     *
     * This triggers a layout but doesn't further modify the DOM, so causes a
     * maximum of one layout per frame.
     *
     * Does not support `transform-origin` CSS property other than the default.
     */
    Translator.prototype.computePosition = function (clientX, clientY) {
        var clientPosition = {
            x: clientX,
            y: clientY,
        };
        var transform = Utils.Math.getCumulativeTransform(this._rootElement);
        if (transform == null) {
            return clientPosition;
        }
        var transformed = Utils.Math.applyTransform(transform, clientPosition);
        return transformed;
    };
    /**
     * Is the event's target part of the given component's DOM tree?
     */
    Translator.isEventInside = function (component, e) {
        return Utils.DOM.contains(component.root().rootElement().node(), e.target);
    };
    return Translator;
}());
exports.Translator = Translator;

},{"../utils":624}],634:[function(require,module,exports){
"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.deprecated = exports.debounce = exports.setTimeout = exports.warn = void 0;
var Configs = require("../core/config");
/**
 * Print a warning message to the console, if it is available.
 *
 * @param {string} The warnings to print
 */
function warn(warning) {
    if (!Configs.SHOW_WARNINGS) {
        return;
    }
    // tslint:disable-next-line:no-console
    console.warn(warning);
}
exports.warn = warn;
/**
 * Is like setTimeout, but activates synchronously if time=0
 * We special case 0 because of an observed issue where calling setTimeout causes visible flickering.
 * We believe this is because when requestAnimationFrame calls into the paint function, as soon as that function finishes
 * evaluating, the results are painted to the screen. As a result, if we want something to occur immediately but call setTimeout
 * with time=0, then it is pushed to the call stack and rendered in the next frame, so the component that was rendered via
 * setTimeout appears out-of-sync with the rest of the plot.
 */
function setTimeout(f, time) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    if (time === 0) {
        f(args);
        return -1;
    }
    else {
        return window.setTimeout(f, time, args);
    }
}
exports.setTimeout = setTimeout;
/**
 * Debounces the supplied callback and returns a function with the same
 * arguments.
 *
 * The callback is schedule for invocation every time the returned function is
 * invoked. If the returned function is called within the debounce time, the
 * previously scheduled call is canceled and the callback is schedule again.
 *
 * If debounced, the callback will be called with the most recent arguments.
 *
 * @param {number} msec - the debounce time in milliseconds
 * @param {T} callback - the callback invoked after the debounce time
 * @param {any} context  - the `this` argument used to invoke the callback
 */
function debounce(msec, callback, context) {
    var timeoutToken = null;
    var args = [];
    var deferredCallback = function () {
        callback.apply(context, args);
    };
    // coerce to T
    return function () {
        args = Array.prototype.slice.call(arguments);
        clearTimeout(timeoutToken);
        timeoutToken = setTimeout(deferredCallback, msec);
    };
}
exports.debounce = debounce;
/**
 * Sends a deprecation warning to the console. The warning includes the name of the deprecated method,
 * version number of the deprecation, and an optional message.
 *
 * To be used in the first line of a deprecated method.
 *
 * @param {string} callingMethod The name of the method being deprecated
 * @param {string} version The version when the tagged method became obsolete
 * @param {string?} message Optional message to be shown with the warning
 */
function deprecated(callingMethod, version, message) {
    if (message === void 0) { message = ""; }
    warn("Method " + callingMethod + " has been deprecated in version " + version +
        ". Please refer to the release notes. " + message);
}
exports.deprecated = deprecated;

},{"../core/config":549}],635:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__assign = void 0;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncValues = __asyncValues;
exports.__await = __await;
exports.__awaiter = __awaiter;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = void 0;
exports.__decorate = __decorate;
exports.__exportStar = __exportStar;
exports.__extends = __extends;
exports.__generator = __generator;
exports.__importDefault = __importDefault;
exports.__importStar = __importStar;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__metadata = __metadata;
exports.__param = __param;
exports.__read = __read;
exports.__rest = __rest;
exports.__spread = __spread;
exports.__spreadArray = __spreadArray;
exports.__spreadArrays = __spreadArrays;
exports.__values = __values;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

exports.__assign = __assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};

exports.__createBinding = __createBinding;

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
/** @deprecated */


function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}
/** @deprecated */


function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

},{}],636:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var writers_1 = require("../writers");
var DEFAULT_FILL_COLOR = "#444";
/**
 * A typesetter context for HTML5 Canvas.
 *
 * Due to the Canvas API, you must explicitly define the line height, and any
 * styling for the font must also be explicitly defined in the optional
 * `ICanvasFontStyle` object.
 */
var CanvasContext = (function () {
    function CanvasContext(ctx, lineHeight, style) {
        if (lineHeight === void 0) { lineHeight = 10; }
        if (style === void 0) { style = {}; }
        var _this = this;
        this.ctx = ctx;
        this.lineHeight = lineHeight;
        this.style = style;
        this.createRuler = function () {
            return function (text) {
                _this.ctx.font = _this.style.font;
                var width = _this.ctx.measureText(text).width;
                return { width: width, height: _this.lineHeight };
            };
        };
        this.createPen = function (_text, transform, ctx) {
            if (ctx == null) {
                ctx = _this.ctx;
            }
            ctx.save();
            ctx.translate(transform.translate[0], transform.translate[1]);
            ctx.rotate(transform.rotate * Math.PI / 180.0);
            return _this.createCanvasPen(ctx);
        };
        if (this.style.fill === undefined) {
            this.style.fill = DEFAULT_FILL_COLOR;
        }
    }
    CanvasContext.prototype.createCanvasPen = function (ctx) {
        var _this = this;
        return {
            destroy: function () {
                ctx.restore();
            },
            write: function (line, width, xAlign, xOffset, yOffset) {
                xOffset += width * writers_1.Writer.XOffsetFactor[xAlign];
                ctx.textAlign = xAlign;
                if (_this.style.font != null) {
                    ctx.font = _this.style.font;
                }
                if (_this.style.fill != null) {
                    ctx.fillStyle = _this.style.fill;
                    ctx.fillText(line, xOffset, yOffset);
                }
                if (_this.style.stroke != null) {
                    ctx.strokeStyle = _this.style.fill;
                    ctx.strokeText(line, xOffset, yOffset);
                }
            },
        };
    };
    return CanvasContext;
}());
exports.CanvasContext = CanvasContext;

},{"../writers":656}],637:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var HtmlUtils = (function () {
    function HtmlUtils() {
    }
    /**
     * Appends an HTML element with the specified tag name to the provided element.
     * The variadic classnames are added to the new element.
     *
     * Returns the new element.
     */
    HtmlUtils.append = function (element, tagName) {
        var classNames = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            classNames[_i - 2] = arguments[_i];
        }
        var child = HtmlUtils.create.apply(HtmlUtils, [tagName].concat(classNames));
        element.appendChild(child);
        return child;
    };
    /**
     * Creates and returns a new HTMLElement with the attached classnames.
     */
    HtmlUtils.create = function (tagName) {
        var classNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            classNames[_i - 1] = arguments[_i];
        }
        var element = document.createElement(tagName);
        HtmlUtils.addClasses.apply(HtmlUtils, [element].concat(classNames));
        return element;
    };
    /**
     * Adds the variadic classnames to the Element
     */
    HtmlUtils.addClasses = function (element) {
        var classNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            classNames[_i - 1] = arguments[_i];
        }
        classNames = classNames.filter(function (c) { return c != null; });
        if (element.classList != null) {
            classNames.forEach(function (className) {
                element.classList.add(className);
            });
        }
        else {
            // IE 11 does not support classList
            element.setAttribute("class", classNames.join(" "));
        }
    };
    /**
     * Returns the width/height of HTMLElement's bounding box
     */
    HtmlUtils.getDimensions = function (element) {
        // using feature detection, safely return the bounding box dimensions of the
        // provided html element
        if (element.getBoundingClientRect) {
            try {
                var _a = element.getBoundingClientRect(), width = _a.width, height = _a.height;
                // copy to prevent NoModificationAllowedError
                return { width: width, height: height };
            }
            catch (err) {
                // swallow any errors that occur (Firefox Linux)
            }
        }
        // if can't get valid bbox, return 0,0
        return { height: 0, width: 0 };
    };
    return HtmlUtils;
}());
exports.HtmlUtils = HtmlUtils;
/**
 * A typesetter context for HTML.
 */
var HtmlContext = (function () {
    /**
     * @param element - The CSS font styles applied to `element` will determine the
     * size of text measurements. Also the default text block container.
     * @param className - added to new text blocks
     * @param addTitle - enable title attribute to be added to new text blocks.
     */
    function HtmlContext(element, className, addTitle) {
        if (addTitle === void 0) { addTitle = false; }
        var _this = this;
        this.element = element;
        this.className = className;
        this.addTitle = addTitle;
        this.createRuler = function () {
            return function (text) {
                var textElement = HtmlUtils.append(_this.element, "span", "text-tmp", _this.className);
                textElement.textContent = text;
                var dimensions = HtmlUtils.getDimensions(textElement);
                _this.element.removeChild(textElement); // element.remove() doesn't work in IE11
                return dimensions;
            };
        };
        this.createPen = function (text, transform, element) {
            if (element == null) {
                element = _this.element;
            }
            var textBlock = HtmlUtils.append(element, "div", "text-block", _this.className);
            textBlock.style.position = "relative";
            textBlock.style.transform =
                "translate(0, -1em) " +
                    ("translate(" + transform.translate[0] + "px, " + transform.translate[1] + "px) ") +
                    ("rotate(" + transform.rotate + "deg)");
            // This awkward transform origin matches the SVG origin
            textBlock.style.transformOrigin = "0 1.2em";
            // attach optional title
            if (_this.addTitle) {
                textBlock.setAttribute("title", text);
            }
            return _this.createHtmlLinePen(textBlock);
        };
    }
    HtmlContext.prototype.setAddTitle = function (addTitle) {
        this.addTitle = addTitle;
    };
    HtmlContext.prototype.createHtmlLinePen = function (textBlock) {
        return {
            write: function (line, width, xAlign, xOffset, yOffset) {
                var textLine = HtmlUtils.append(textBlock, "div", "text-line");
                textLine.textContent = line;
                textLine.style.width = width + "px";
                textLine.style.textAlign = xAlign;
                textLine.style.position = "absolute";
                textLine.style.whiteSpace = "nowrap";
                textLine.style.top = yOffset + "px";
                textLine.style.left = xOffset + "px";
            },
        };
    };
    return HtmlContext;
}());
exports.HtmlContext = HtmlContext;

},{}],638:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./svg"));
__export(require("./canvas"));
__export(require("./html"));

},{"./canvas":636,"./html":637,"./svg":639}],639:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var writers_1 = require("../writers");
var html_1 = require("./html");
var SvgUtils = (function () {
    function SvgUtils() {
    }
    /**
     * Appends an SVG element with the specified tag name to the provided element.
     * The variadic classnames are added to the new element.
     *
     * Returns the new element.
     */
    SvgUtils.append = function (element, tagName) {
        var classNames = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            classNames[_i - 2] = arguments[_i];
        }
        var child = SvgUtils.create.apply(SvgUtils, [tagName].concat(classNames));
        element.appendChild(child);
        return child;
    };
    /**
     * Creates and returns a new SVGElement with the attached classnames.
     */
    SvgUtils.create = function (tagName) {
        var classNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            classNames[_i - 1] = arguments[_i];
        }
        var element = document.createElementNS(SvgUtils.SVG_NS, tagName);
        html_1.HtmlUtils.addClasses.apply(html_1.HtmlUtils, [element].concat(classNames));
        return element;
    };
    /**
     * Returns the width/height of svg element's bounding box
     */
    SvgUtils.getDimensions = function (element) {
        // using feature detection, safely return the bounding box dimensions of the
        // provided svg element
        if (element.getBBox) {
            try {
                var _a = element.getBBox(), width = _a.width, height = _a.height;
                // copy to prevent NoModificationAllowedError
                return { width: width, height: height };
            }
            catch (err) {
                // swallow any errors that occur (Firefox Linux)
            }
        }
        // if can't get valid bbox, return 0,0
        return { height: 0, width: 0 };
    };
    return SvgUtils;
}());
SvgUtils.SVG_NS = "http://www.w3.org/2000/svg";
exports.SvgUtils = SvgUtils;
/**
 * A typesetter context for SVG.
 *
 * @param element - The CSS font styles applied to `element` will determine the
 * size of text measurements. Also the default text block container.
 * @param className - added to new text blocks
 * @param addTitleElement - enable title tags to be added to new text blocks.
 */
var SvgContext = (function () {
    function SvgContext(element, className, addTitleElement) {
        if (addTitleElement === void 0) { addTitleElement = false; }
        var _this = this;
        this.element = element;
        this.className = className;
        this.addTitleElement = addTitleElement;
        this.createRuler = function () {
            var _a = _this.getTextElements(_this.element), parentElement = _a.parentElement, containerElement = _a.containerElement, textElement = _a.textElement;
            return function (text) {
                parentElement.appendChild(containerElement);
                textElement.textContent = text;
                var dimensions = SvgUtils.getDimensions(textElement);
                parentElement.removeChild(containerElement); // element.remove() doesn't work in IE11
                return dimensions;
            };
        };
        this.createPen = function (text, transform, element) {
            if (element == null) {
                element = _this.element;
            }
            var textContainer = SvgUtils.append(element, "g", "text-container", _this.className);
            // attach optional title
            if (_this.addTitleElement) {
                SvgUtils.append(textContainer, "title").textContent = text;
                textContainer.setAttribute("title", text);
            }
            // create and transform text block group
            var textBlockGroup = SvgUtils.append(textContainer, "g", "text-area");
            textBlockGroup.setAttribute("transform", "translate(" + transform.translate[0] + "," + transform.translate[1] + ")" +
                ("rotate(" + transform.rotate + ")"));
            return _this.createSvgLinePen(textBlockGroup);
        };
    }
    SvgContext.prototype.setAddTitleElement = function (addTitleElement) {
        this.addTitleElement = addTitleElement;
    };
    SvgContext.prototype.createSvgLinePen = function (textBlockGroup) {
        return {
            write: function (line, width, xAlign, xOffset, yOffset) {
                xOffset += width * writers_1.Writer.XOffsetFactor[xAlign];
                var element = SvgUtils.append(textBlockGroup, "text", "text-line");
                element.textContent = line;
                element.setAttribute("text-anchor", SvgContext.AnchorMap[xAlign]);
                element.setAttribute("transform", "translate(" + xOffset + "," + yOffset + ")");
                element.setAttribute("y", "-0.25em");
            },
        };
    };
    SvgContext.prototype.getTextElements = function (element) {
        // if element is already a text element, return it
        if (element.tagName === "text") {
            var parentElement = element.parentElement;
            if (parentElement == null) {
                parentElement = element.parentNode;
            }
            // must be removed from parent since we re-add it on every measurement
            parentElement.removeChild(element);
            return {
                containerElement: element,
                parentElement: parentElement,
                textElement: element,
            };
        }
        // if element has a text element descendent, select it and return it
        var selected = element.querySelector("text");
        if (selected != null) {
            var parentElement = selected.parentElement;
            if (parentElement == null) {
                parentElement = selected.parentNode;
            }
            // must be removed from parent since we re-add it on every measurement
            parentElement.removeChild(selected);
            return {
                containerElement: selected,
                parentElement: parentElement,
                textElement: selected,
            };
        }
        // otherwise create a new text element
        var created = SvgUtils.create("text", this.className);
        return {
            containerElement: created,
            parentElement: element,
            textElement: created,
        };
    };
    return SvgContext;
}());
SvgContext.AnchorMap = {
    center: "middle",
    left: "start",
    right: "end",
};
exports.SvgContext = SvgContext;

},{"../writers":656,"./html":637}],640:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./contexts"));
__export(require("./measurers"));
__export(require("./typesetter"));
__export(require("./utils"));
__export(require("./wrappers"));
__export(require("./writers"));

},{"./contexts":638,"./measurers":645,"./typesetter":647,"./utils":649,"./wrappers":653,"./writers":656}],641:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
;
var AbstractMeasurer = (function () {
    function AbstractMeasurer(ruler) {
        if (ruler.createRuler != null) {
            this.ruler = ruler.createRuler();
        }
        else {
            this.ruler = ruler;
        }
    }
    AbstractMeasurer.prototype.measure = function (text) {
        if (text === void 0) { text = AbstractMeasurer.HEIGHT_TEXT; }
        return this.ruler(text);
    };
    return AbstractMeasurer;
}());
/**
 * A string representing the full ascender/descender range of your text.
 *
 * Note that this is really only applicable to western alphabets. If you are
 * using a different locale language such as arabic or chinese, you may want
 * to override this.
 */
AbstractMeasurer.HEIGHT_TEXT = "bdpql";
exports.AbstractMeasurer = AbstractMeasurer;

},{}],642:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
/* istanbul ignore next */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var characterMeasurer_1 = require("./characterMeasurer");
var CacheCharacterMeasurer = (function (_super) {
    __extends(CacheCharacterMeasurer, _super);
    function CacheCharacterMeasurer(ruler, useGuards) {
        var _this = _super.call(this, ruler, useGuards) || this;
        _this.cache = new utils_1.Cache(function (c) {
            return _this._measureCharacterNotFromCache(c);
        });
        return _this;
    }
    CacheCharacterMeasurer.prototype._measureCharacterNotFromCache = function (c) {
        return _super.prototype._measureCharacter.call(this, c);
    };
    CacheCharacterMeasurer.prototype._measureCharacter = function (c) {
        return this.cache.get(c);
    };
    CacheCharacterMeasurer.prototype.reset = function () {
        this.cache.clear();
    };
    return CacheCharacterMeasurer;
}(characterMeasurer_1.CharacterMeasurer));
exports.CacheCharacterMeasurer = CacheCharacterMeasurer;

},{"../utils":649,"./characterMeasurer":644}],643:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
/* istanbul ignore next */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var abstractMeasurer_1 = require("./abstractMeasurer");
var cacheCharacterMeasurer_1 = require("./cacheCharacterMeasurer");
var CacheMeasurer = (function (_super) {
    __extends(CacheMeasurer, _super);
    function CacheMeasurer(ruler) {
        var _this = _super.call(this, ruler) || this;
        _this.dimCache = new utils_1.Cache(function (s) {
            return _this._measureNotFromCache(s);
        });
        return _this;
    }
    CacheMeasurer.prototype._measureNotFromCache = function (s) {
        return _super.prototype.measure.call(this, s);
    };
    CacheMeasurer.prototype.measure = function (s) {
        if (s === void 0) { s = abstractMeasurer_1.AbstractMeasurer.HEIGHT_TEXT; }
        return this.dimCache.get(s);
    };
    CacheMeasurer.prototype.reset = function () {
        this.dimCache.clear();
        _super.prototype.reset.call(this);
    };
    return CacheMeasurer;
}(cacheCharacterMeasurer_1.CacheCharacterMeasurer));
exports.CacheMeasurer = CacheMeasurer;

},{"../utils":649,"./abstractMeasurer":641,"./cacheCharacterMeasurer":642}],644:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
/* istanbul ignore next */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var measurer_1 = require("./measurer");
var CharacterMeasurer = (function (_super) {
    __extends(CharacterMeasurer, _super);
    function CharacterMeasurer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CharacterMeasurer.prototype._measureCharacter = function (c) {
        return _super.prototype._measureLine.call(this, c);
    };
    CharacterMeasurer.prototype._measureLine = function (line) {
        var _this = this;
        var charactersDimensions = line.split("").map(function (c) { return _this._measureCharacter(c); });
        return {
            height: charactersDimensions.reduce(function (acc, dim) { return Math.max(acc, dim.height); }, 0),
            width: charactersDimensions.reduce(function (acc, dim) { return acc + dim.width; }, 0),
        };
    };
    return CharacterMeasurer;
}(measurer_1.Measurer));
exports.CharacterMeasurer = CharacterMeasurer;

},{"./measurer":646}],645:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./abstractMeasurer"));
__export(require("./cacheCharacterMeasurer"));
__export(require("./cacheMeasurer"));
__export(require("./characterMeasurer"));
__export(require("./measurer"));

},{"./abstractMeasurer":641,"./cacheCharacterMeasurer":642,"./cacheMeasurer":643,"./characterMeasurer":644,"./measurer":646}],646:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var abstractMeasurer_1 = require("./abstractMeasurer");
var Measurer = (function (_super) {
    __extends(Measurer, _super);
    function Measurer(ruler, useGuards) {
        if (useGuards === void 0) { useGuards = false; }
        var _this = _super.call(this, ruler) || this;
        _this.useGuards = useGuards;
        return _this;
    }
    // Guards assures same line height and width of whitespaces on both ends.
    Measurer.prototype._addGuards = function (text) {
        return abstractMeasurer_1.AbstractMeasurer.HEIGHT_TEXT + text + abstractMeasurer_1.AbstractMeasurer.HEIGHT_TEXT;
    };
    Measurer.prototype._measureLine = function (line, forceGuards) {
        if (forceGuards === void 0) { forceGuards = false; }
        var useGuards = this.useGuards || forceGuards || /^[\t ]$/.test(line);
        var measuredLine = useGuards ? this._addGuards(line) : line;
        var measuredLineDimensions = _super.prototype.measure.call(this, measuredLine);
        measuredLineDimensions.width -= useGuards ? (2 * this.getGuardWidth()) : 0;
        return measuredLineDimensions;
    };
    Measurer.prototype.measure = function (text) {
        var _this = this;
        if (text === void 0) { text = abstractMeasurer_1.AbstractMeasurer.HEIGHT_TEXT; }
        if (text.trim() === "") {
            return { width: 0, height: 0 };
        }
        var linesDimensions = text.trim().split("\n").map(function (line) { return _this._measureLine(line); });
        return {
            height: linesDimensions.reduce(function (acc, dim) { return acc + dim.height; }, 0),
            width: linesDimensions.reduce(function (acc, dim) { return Math.max(acc, dim.width); }, 0),
        };
    };
    Measurer.prototype.getGuardWidth = function () {
        if (this.guardWidth == null) {
            this.guardWidth = _super.prototype.measure.call(this).width;
        }
        return this.guardWidth;
    };
    return Measurer;
}(abstractMeasurer_1.AbstractMeasurer));
exports.Measurer = Measurer;

},{"./abstractMeasurer":641}],647:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var contexts_1 = require("./contexts");
var measurers_1 = require("./measurers");
var wrappers_1 = require("./wrappers");
var writers_1 = require("./writers");
/**
 * This is a convenience interface for typesetting strings using the default
 * measurer/wrapper/writer setup.
 */
var Typesetter = (function () {
    function Typesetter(context) {
        this.context = context;
        this.measurer = new measurers_1.CacheMeasurer(this.context);
        this.wrapper = new wrappers_1.Wrapper();
        this.writer = new writers_1.Writer(this.measurer, this.context, this.wrapper);
    }
    Typesetter.svg = function (element, className, addTitleElement) {
        return new Typesetter(new contexts_1.SvgContext(element, className, addTitleElement));
    };
    Typesetter.canvas = function (ctx, lineHeight, style) {
        return new Typesetter(new contexts_1.CanvasContext(ctx, lineHeight, style));
    };
    Typesetter.html = function (element, className, addTitle) {
        return new Typesetter(new contexts_1.HtmlContext(element, className, addTitle));
    };
    /**
     * Wraps the given string into the width/height and writes it into the
     * canvas or SVG (depending on context).
     *
     * Delegates to `Writer.write` using the internal `ITypesetterContext`.
     */
    Typesetter.prototype.write = function (text, width, height, options, into) {
        this.writer.write(text, width, height, options, into);
    };
    /**
     * Clears the `Measurer`'s CacheMeasurer.
     *
     * Call this if your font style changee in SVG.
     */
    Typesetter.prototype.clearMeasurerCache = function () {
        this.measurer.reset();
    };
    return Typesetter;
}());
exports.Typesetter = Typesetter;

},{"./contexts":638,"./measurers":645,"./wrappers":653,"./writers":656}],648:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Cache = (function () {
    /**
     * @constructor
     *
     * @param {string} compute The function whose results will be cached.
     */
    function Cache(compute) {
        this.cache = {};
        this.compute = compute;
    }
    /**
     * Attempt to look up k in the cache, computing the result if it isn't
     * found.
     *
     * @param {string} k The key to look up in the cache.
     * @return {T} The value associated with k; the result of compute(k).
     */
    Cache.prototype.get = function (k) {
        if (!this.cache.hasOwnProperty(k)) {
            this.cache[k] = this.compute(k);
        }
        return this.cache[k];
    };
    /**
     * Reset the cache empty.
     *
     * @return {Cache<T>} The calling Cache.
     */
    Cache.prototype.clear = function () {
        this.cache = {};
        return this;
    };
    return Cache;
}());
exports.Cache = Cache;

},{}],649:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./cache"));
__export(require("./methods"));
__export(require("./stringMethods"));
__export(require("./tokenizer"));

},{"./cache":648,"./methods":650,"./stringMethods":651,"./tokenizer":652}],650:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Methods = (function () {
    function Methods() {
    }
    /**
     * Check if two arrays are equal by strict equality.
     */
    Methods.arrayEq = function (a, b) {
        // Technically, null and undefined are arrays too
        if (a == null || b == null) {
            return a === b;
        }
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {any} a Object to check against b for equality.
     * @param {any} b Object to check against a for equality.
     *
     * @returns {boolean} whether or not two objects share the same keys, and
     *          values associated with those keys. Values will be compared
     *          with ===.
     */
    Methods.objEq = function (a, b) {
        if (a == null || b == null) {
            return a === b;
        }
        var keysA = Object.keys(a).sort();
        var keysB = Object.keys(b).sort();
        var valuesA = keysA.map(function (k) { return a[k]; });
        var valuesB = keysB.map(function (k) { return b[k]; });
        return Methods.arrayEq(keysA, keysB) && Methods.arrayEq(valuesA, valuesB);
    };
    Methods.strictEq = function (a, b) {
        return a === b;
    };
    /**
     * Shim for _.defaults
     */
    Methods.defaults = function (target) {
        var objects = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            objects[_i - 1] = arguments[_i];
        }
        if (target == null) {
            throw new TypeError("Cannot convert undefined or null to object");
        }
        var result = Object(target);
        objects.forEach(function (obj) {
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        result[key] = obj[key];
                    }
                }
            }
        });
        return result;
    };
    return Methods;
}());
exports.Methods = Methods;

},{}],651:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var StringMethods = (function () {
    function StringMethods() {
    }
    /**
     * Treat all sequences of consecutive spaces as a single " ".
     */
    StringMethods.combineWhitespace = function (str) {
        return str.replace(/[ \t]+/g, " ");
    };
    StringMethods.isNotEmptyString = function (str) {
        return str && str.trim() !== "";
    };
    StringMethods.trimStart = function (str, splitter) {
        if (!str) {
            return str;
        }
        var chars = str.split("");
        var reduceFunction = splitter ? function (s) { return s.split(splitter).some(StringMethods.isNotEmptyString); }
            : StringMethods.isNotEmptyString;
        return chars.reduce(function (s, c) { return reduceFunction(s + c) ? s + c : s; }, "");
    };
    StringMethods.trimEnd = function (str, c) {
        if (!str) {
            return str;
        }
        var reversedChars = str.split("");
        reversedChars.reverse();
        reversedChars = StringMethods.trimStart(reversedChars.join(""), c).split("");
        reversedChars.reverse();
        return reversedChars.join("");
    };
    return StringMethods;
}());
exports.StringMethods = StringMethods;

},{}],652:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Tokenizer = (function () {
    function Tokenizer() {
        this.WordDividerRegExp = new RegExp("\\W");
        this.WhitespaceRegExp = new RegExp("\\s");
    }
    Tokenizer.prototype.tokenize = function (line) {
        var _this = this;
        return line.split("").reduce(function (tokens, c) {
            return tokens.slice(0, -1).concat(_this.shouldCreateNewToken(tokens[tokens.length - 1], c));
        }, [""]);
    };
    Tokenizer.prototype.shouldCreateNewToken = function (token, newCharacter) {
        if (!token) {
            return [newCharacter];
        }
        var lastCharacter = token[token.length - 1];
        if (this.WhitespaceRegExp.test(lastCharacter) && this.WhitespaceRegExp.test(newCharacter)) {
            return [token + newCharacter];
        }
        else if (this.WhitespaceRegExp.test(lastCharacter) || this.WhitespaceRegExp.test(newCharacter)) {
            return [token, newCharacter];
        }
        else if (!(this.WordDividerRegExp.test(lastCharacter))) {
            return [token + newCharacter];
        }
        else if (lastCharacter === newCharacter) {
            return [token + newCharacter];
        }
        else {
            return [token, newCharacter];
        }
    };
    return Tokenizer;
}());
exports.Tokenizer = Tokenizer;

},{}],653:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./singleLineWrapper"));
__export(require("./wrapper"));

},{"./singleLineWrapper":654,"./wrapper":655}],654:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wrapper_1 = require("./wrapper");
var SingleLineWrapper = (function (_super) {
    __extends(SingleLineWrapper, _super);
    function SingleLineWrapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SingleLineWrapper.prototype.wrap = function (text, measurer, width, height) {
        var _this = this;
        if (height === void 0) { height = Infinity; }
        var lines = text.split("\n");
        if (lines.length > 1) {
            throw new Error("SingleLineWrapper is designed to work only on single line");
        }
        var wrapFN = function (w) { return _super.prototype.wrap.call(_this, text, measurer, w, height); };
        var result = wrapFN(width);
        if (result.noLines < 2) {
            return result;
        }
        var left = 0;
        var right = width;
        for (var i = 0; i < SingleLineWrapper.NO_WRAP_ITERATIONS && right > left; ++i) {
            var currentWidth = (right + left) / 2;
            var currentResult = wrapFN(currentWidth);
            if (this.areSameResults(result, currentResult)) {
                right = currentWidth;
                result = currentResult;
            }
            else {
                left = currentWidth;
            }
        }
        return result;
    };
    SingleLineWrapper.prototype.areSameResults = function (one, two) {
        return one.noLines === two.noLines && one.truncatedText === two.truncatedText;
    };
    return SingleLineWrapper;
}(wrapper_1.Wrapper));
SingleLineWrapper.NO_WRAP_ITERATIONS = 5;
exports.SingleLineWrapper = SingleLineWrapper;

},{"./wrapper":655}],655:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Utils = require("../utils");
var Wrapper = (function () {
    function Wrapper() {
        this.maxLines(Infinity);
        this.textTrimming("ellipsis");
        this.allowBreakingWords(false);
        this._tokenizer = new Utils.Tokenizer();
        this._breakingCharacter = "-";
    }
    Wrapper.prototype.maxLines = function (noLines) {
        if (noLines == null) {
            return this._maxLines;
        }
        else {
            this._maxLines = noLines;
            return this;
        }
    };
    Wrapper.prototype.textTrimming = function (option) {
        if (option == null) {
            return this._textTrimming;
        }
        else {
            if (option !== "ellipsis" && option !== "none") {
                throw new Error(option + " - unsupported text trimming option.");
            }
            this._textTrimming = option;
            return this;
        }
    };
    Wrapper.prototype.allowBreakingWords = function (allow) {
        if (allow == null) {
            return this._allowBreakingWords;
        }
        else {
            this._allowBreakingWords = allow;
            return this;
        }
    };
    Wrapper.prototype.wrap = function (text, measurer, width, height) {
        var _this = this;
        if (height === void 0) { height = Infinity; }
        var initialWrappingResult = {
            noBrokeWords: 0,
            noLines: 0,
            originalText: text,
            truncatedText: "",
            wrappedText: "",
        };
        var state = {
            availableLines: Math.min(Math.floor(height / measurer.measure().height), this._maxLines),
            availableWidth: width,
            canFitText: true,
            currentLine: "",
            wrapping: initialWrappingResult,
        };
        var lines = text.split("\n");
        return lines.reduce(function (s, line, i) {
            return _this.breakLineToFitWidth(s, line, i !== lines.length - 1, measurer);
        }, state).wrapping;
    };
    Wrapper.prototype.breakLineToFitWidth = function (state, line, hasNextLine, measurer) {
        var _this = this;
        if (!state.canFitText && state.wrapping.truncatedText !== "") {
            state.wrapping.truncatedText += "\n";
        }
        var tokens = this._tokenizer.tokenize(line);
        state = tokens.reduce(function (s, token) {
            return _this.wrapNextToken(token, s, measurer);
        }, state);
        var wrappedText = Utils.StringMethods.trimEnd(state.currentLine);
        state.wrapping.noLines += +(wrappedText !== "");
        if (state.wrapping.noLines === state.availableLines && this._textTrimming !== "none" && hasNextLine) {
            // Note: no need to add more ellipses, they were added in `wrapNextToken`
            state.canFitText = false;
        }
        else {
            state.wrapping.wrappedText += wrappedText;
        }
        state.currentLine = "\n";
        return state;
    };
    Wrapper.prototype.canFitToken = function (token, width, measurer) {
        var _this = this;
        var possibleBreaks = token.split("").map(function (c, i) { return (i !== token.length - 1) ? c + _this._breakingCharacter : c; });
        return (measurer.measure(token).width <= width) || possibleBreaks.every(function (c) { return measurer.measure(c).width <= width; });
    };
    Wrapper.prototype.addEllipsis = function (line, width, measurer) {
        if (this._textTrimming === "none") {
            return {
                remainingToken: "",
                wrappedToken: line,
            };
        }
        var truncatedLine = line.substring(0).trim();
        var lineWidth = measurer.measure(truncatedLine).width;
        var ellipsesWidth = measurer.measure("...").width;
        var prefix = (line.length > 0 && line[0] === "\n") ? "\n" : "";
        if (width <= ellipsesWidth) {
            var periodWidth = ellipsesWidth / 3;
            var numPeriodsThatFit = Math.floor(width / periodWidth);
            return {
                remainingToken: line,
                wrappedToken: prefix + "...".substr(0, numPeriodsThatFit),
            };
        }
        while (lineWidth + ellipsesWidth > width) {
            truncatedLine = Utils.StringMethods.trimEnd(truncatedLine.substr(0, truncatedLine.length - 1));
            lineWidth = measurer.measure(truncatedLine).width;
        }
        return {
            remainingToken: Utils.StringMethods.trimEnd(line.substring(truncatedLine.length), "-").trim(),
            wrappedToken: prefix + truncatedLine + "...",
        };
    };
    Wrapper.prototype.wrapNextToken = function (token, state, measurer) {
        if (!state.canFitText ||
            state.availableLines === state.wrapping.noLines ||
            !this.canFitToken(token, state.availableWidth, measurer)) {
            return this.finishWrapping(token, state, measurer);
        }
        var remainingToken = token;
        while (remainingToken) {
            var result = this.breakTokenToFitInWidth(remainingToken, state.currentLine, state.availableWidth, measurer);
            state.currentLine = result.line;
            remainingToken = result.remainingToken;
            if (remainingToken != null) {
                state.wrapping.noBrokeWords += +result.breakWord;
                ++state.wrapping.noLines;
                if (state.availableLines === state.wrapping.noLines) {
                    var ellipsisResult = this.addEllipsis(state.currentLine, state.availableWidth, measurer);
                    state.wrapping.wrappedText += ellipsisResult.wrappedToken;
                    state.wrapping.truncatedText += ellipsisResult.remainingToken + remainingToken;
                    state.currentLine = "\n";
                    return state;
                }
                else {
                    state.wrapping.wrappedText += Utils.StringMethods.trimEnd(state.currentLine);
                    state.currentLine = "\n";
                }
            }
        }
        return state;
    };
    Wrapper.prototype.finishWrapping = function (token, state, measurer) {
        // Token is really long, but we have a space to put part of the word.
        if (state.canFitText &&
            state.availableLines !== state.wrapping.noLines &&
            this._textTrimming !== "none") {
            var res = this.addEllipsis(state.currentLine + token, state.availableWidth, measurer);
            state.wrapping.wrappedText += res.wrappedToken;
            state.wrapping.truncatedText += res.remainingToken;
            state.wrapping.noBrokeWords += +(res.remainingToken.length < token.length);
            state.wrapping.noLines += +(res.wrappedToken.length > 0);
            state.currentLine = "";
        }
        else {
            state.wrapping.truncatedText += token;
        }
        state.canFitText = false;
        return state;
    };
    /**
     * Breaks single token to fit current line.
     * If token contains only whitespaces then they will not be populated to next line.
     */
    Wrapper.prototype.breakTokenToFitInWidth = function (token, line, availableWidth, measurer, breakingCharacter) {
        if (breakingCharacter === void 0) { breakingCharacter = this._breakingCharacter; }
        if (measurer.measure(line + token).width <= availableWidth) {
            return {
                breakWord: false,
                line: line + token,
                remainingToken: null,
            };
        }
        if (token.trim() === "") {
            return {
                breakWord: false,
                line: line,
                remainingToken: "",
            };
        }
        // if we don't allow breaking words AND the token isn't the only thing on the current line.
        if (!this._allowBreakingWords && line.trim() !== "") {
            return {
                breakWord: false,
                line: line,
                remainingToken: token,
            };
        }
        var fitTokenLength = 0;
        while (fitTokenLength < token.length) {
            if (measurer.measure(line + token.substring(0, fitTokenLength + 1) + breakingCharacter).width <= availableWidth) {
                ++fitTokenLength;
            }
            else {
                break;
            }
        }
        var suffix = "";
        if (fitTokenLength > 0) {
            suffix = breakingCharacter;
        }
        return {
            breakWord: fitTokenLength > 0,
            line: line + token.substring(0, fitTokenLength) + suffix,
            remainingToken: token.substring(fitTokenLength),
        };
    };
    return Wrapper;
}());
exports.Wrapper = Wrapper;

},{"../utils":649}],656:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./writer"));

},{"./writer":657}],657:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-present Palantir Technologies, Inc. All rights reserved.
 * Licensed under the MIT License (the "License"); you may obtain a copy of the
 * license at https://github.com/palantir/typesettable/blob/develop/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var DEFAULT_WRITE_OPTIONS = {
    textRotation: 0,
    textShear: 0,
    xAlign: "left",
    yAlign: "top",
};
var Writer = (function () {
    function Writer(_measurer, _penFactory, _wrapper) {
        this._measurer = _measurer;
        this._penFactory = _penFactory;
        this._wrapper = _wrapper;
    }
    Writer.prototype.measurer = function (newMeasurer) {
        this._measurer = newMeasurer;
        return this;
    };
    Writer.prototype.wrapper = function (newWrapper) {
        this._wrapper = newWrapper;
        return this;
    };
    Writer.prototype.penFactory = function (newPenFactory) {
        this._penFactory = newPenFactory;
        return this;
    };
    /**
     * Writes the text into the container. If no container is specified, the pen's
     * default container will be used.
     */
    Writer.prototype.write = function (text, width, height, options, container) {
        if (options === void 0) { options = {}; }
        // apply default options
        options = utils_1.Methods.defaults({}, DEFAULT_WRITE_OPTIONS, options);
        // validate input
        if (Writer.SupportedRotation.indexOf(options.textRotation) === -1) {
            throw new Error("unsupported rotation - " + options.textRotation +
                ". Supported rotations are " + Writer.SupportedRotation.join(", "));
        }
        if (options.textShear != null && options.textShear < -80 || options.textShear > 80) {
            throw new Error("unsupported shear angle - " + options.textShear + ". Must be between -80 and 80");
        }
        var orientHorizontally = Math.abs(Math.abs(options.textRotation) - 90) > 45;
        var primaryDimension = orientHorizontally ? width : height;
        var secondaryDimension = orientHorizontally ? height : width;
        // compute shear parameters
        var shearDegrees = options.textShear;
        var shearRadians = shearDegrees * Math.PI / 180;
        var lineHeight = this._measurer.measure().height;
        var shearShift = lineHeight * Math.tan(shearRadians);
        // When we apply text shear, the primary axis grows and the secondary axis
        // shrinks, due to trigonometry. The text shear feature uses the normal
        // wrapping logic with a subsituted bounding box of the corrected size
        // (computed below). When rendering the wrapped lines, we rotate the text
        // container by the text rotation angle AND the shear angle then carefully
        // offset each one so that they are still aligned to the primary alignment
        // option.
        var shearCorrectedPrimaryDimension = primaryDimension / Math.cos(shearRadians) - Math.abs(shearShift);
        var shearCorrectedSecondaryDimension = secondaryDimension * Math.cos(shearRadians);
        // normalize and wrap text
        var normalizedText = utils_1.StringMethods.combineWhitespace(text);
        var wrappedText = this._wrapper ?
            this._wrapper.wrap(normalizedText, this._measurer, shearCorrectedPrimaryDimension, shearCorrectedSecondaryDimension).wrappedText : normalizedText;
        var lines = wrappedText.split("\n");
        // correct the intial x/y offset of the text container accounting shear and alignment
        var shearCorrectedXOffset = Writer.XOffsetFactor[options.xAlign] *
            shearCorrectedPrimaryDimension * Math.sin(shearRadians);
        var shearCorrectedYOffset = Writer.YOffsetFactor[options.yAlign] *
            (shearCorrectedSecondaryDimension - lines.length * lineHeight);
        var shearCorrection = shearCorrectedXOffset - shearCorrectedYOffset;
        // compute transform
        var translate = [0, 0];
        var rotate = options.textRotation + shearDegrees;
        switch (options.textRotation) {
            case 90:
                translate = [width + shearCorrection, 0];
                break;
            case -90:
                translate = [-shearCorrection, height];
                break;
            case 180:
                translate = [width, height + shearCorrection];
                break;
            default:
                translate = [0, -shearCorrection];
                break;
        }
        // create a new pen and write the lines
        var linePen = this._penFactory.createPen(text, { translate: translate, rotate: rotate }, container);
        this.writeLines(lines, linePen, shearCorrectedPrimaryDimension, lineHeight, shearShift, options.xAlign);
        if (linePen.destroy != null) {
            linePen.destroy();
        }
    };
    Writer.prototype.writeLines = function (lines, linePen, width, lineHeight, shearShift, xAlign) {
        lines.forEach(function (line, i) {
            var xShearOffset = (shearShift > 0) ? (i + 1) * shearShift : (i) * shearShift;
            linePen.write(line, width, xAlign, xShearOffset, (i + 1) * lineHeight);
        });
    };
    return Writer;
}());
Writer.XOffsetFactor = {
    center: 0.5,
    left: 0,
    right: 1,
};
Writer.YOffsetFactor = {
    bottom: 1,
    center: 0.5,
    top: 0,
};
Writer.SupportedRotation = [-90, 0, 180, 90];
exports.Writer = Writer;

},{"../utils":649}],658:[function(require,module,exports){
const Plottable = require('plottable');

var data = [
    { "temp": 15, "altitude": 0 },
    { "temp": -55, "altitude": 12 },
    { "temp": -55, "altitude": 20 },
    { "temp": -3, "altitude": 50 },
    { "temp": -3, "altitude": 55 },
    { "temp": -95, "altitude": 80 },
    { "temp": -95, "altitude": 90 },
    { "temp": -45, "altitude": 100 }
];

var bands = [
    { "name": "troposphere", "low": -10, "high": 12 },
    { "name": "tropopause", "low": 12, "high": 20 },
    { "name": "stratosphere", "low": 20, "high": 50 },
    { "name": "stratopause", "low": 50, "high": 55 },
    { "name": "mesosphere", "low": 55, "high": 80 },
    { "name": "mesopause", "low": 80, "high": 90 },
    { "name": "thermosphere", "low": 90, "high": 110 }
];

var xScale = new Plottable.Scales.Linear();
var yScale = new Plottable.Scales.Linear();
xScale.domain([-100, 20]);
yScale.domain([-10, 110]);

var interpolatedColorScale = new Plottable.Scales.InterpolatedColor();
interpolatedColorScale.range(["#E3F2FD", "#2196F3"]);

var linePlot = new Plottable.Plots.Line()
    .x(function (d) { return d.temp; }, xScale)
    .y(function (d) { return d.altitude; }, yScale)
    .attr("stroke-width", 3)
    .attr("stroke", "black")
    .addDataset(new Plottable.Dataset(data));

var bandPlot = new Plottable.Plots.Rectangle()
    .x(0)
    .x2(function () { return bandPlot.width(); })
    .y(function (d) { return d.low; }, yScale)
    .y2(function (d) { return d.high; })
    .attr("fill", function (d) { return d.low + d.high; }, interpolatedColorScale)
    .attr("stroke", function (d) { return d.low + d.high; }, interpolatedColorScale)
    .addDataset(new Plottable.Dataset(bands));

var plots = new Plottable.Components.Group([bandPlot, linePlot]);

var xAxisCelsius = new Plottable.Axes.Numeric(xScale, "bottom");
var xAxisFahrenheit = new Plottable.Axes.Numeric(xScale, "top")
    .formatter(function (d) { return d * 9 / 5 + 32; });
var yAxisKilometers = new Plottable.Axes.Numeric(yScale, "left");
var yAxisMiles = new Plottable.Axes.Numeric(yScale, "right")
    .formatter(function (d) { return String((d * 0.62137).toPrecision(2)); });

var xLabelCelsius = new Plottable.Components.AxisLabel("Temperature (\xB0C)", "0");
var xLabelFahrenheit = new Plottable.Components.AxisLabel("Temperature (\xB0F)", "0");
var yLabelKilometers = new Plottable.Components.AxisLabel("Altitude (km)", "270");
var yLabelMiles = new Plottable.Components.AxisLabel("Altitude (miles)", "90");

var table = new Plottable.Components.Table([
    [null, null, xLabelFahrenheit, null, null],
    [null, null, xAxisFahrenheit, null, null],
    [yLabelKilometers, yAxisKilometers, plots, yAxisMiles, yLabelMiles],
    [null, null, xAxisCelsius, null, null],
    [null, null, xLabelCelsius, null, null]
]);

table.renderTo("svg#example");

},{"plottable":575}]},{},[658]);
